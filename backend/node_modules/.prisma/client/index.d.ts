
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model License
 * 
 */
export type License = $Result.DefaultSelection<Prisma.$LicensePayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model ModelImport
 * 
 */
export type ModelImport = $Result.DefaultSelection<Prisma.$ModelImportPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model DesignVersion
 * 
 */
export type DesignVersion = $Result.DefaultSelection<Prisma.$DesignVersionPayload>
/**
 * Model Export
 * 
 */
export type Export = $Result.DefaultSelection<Prisma.$ExportPayload>
/**
 * Model ErrorLog
 * 
 */
export type ErrorLog = $Result.DefaultSelection<Prisma.$ErrorLogPayload>
/**
 * Model SharedProject
 * 
 */
export type SharedProject = $Result.DefaultSelection<Prisma.$SharedProjectPayload>
/**
 * Model CloudBackup
 * 
 */
export type CloudBackup = $Result.DefaultSelection<Prisma.$CloudBackupPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model NumExports
 * 
 */
export type NumExports = $Result.DefaultSelection<Prisma.$NumExportsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserTier: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM'
};

export type UserTier = (typeof UserTier)[keyof typeof UserTier]


export const LicenseType: {
  TRIAL: 'TRIAL',
  PAID: 'PAID'
};

export type LicenseType = (typeof LicenseType)[keyof typeof LicenseType]


export const LicenseStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  SUSPENDED: 'SUSPENDED',
  CANCELLED: 'CANCELLED'
};

export type LicenseStatus = (typeof LicenseStatus)[keyof typeof LicenseStatus]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  UPI: 'UPI',
  NET_BANKING: 'NET_BANKING',
  WALLET: 'WALLET',
  RAZORPAY: 'RAZORPAY',
  STRIPE: 'STRIPE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ImportStatus: {
  UPLOADING: 'UPLOADING',
  UPLOADED: 'UPLOADED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ImportStatus = (typeof ImportStatus)[keyof typeof ImportStatus]


export const ProjectStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED',
  DELETED: 'DELETED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ExportFormat: {
  STL: 'STL',
  OBJ: 'OBJ',
  GLTF: 'GLTF',
  GLB: 'GLB',
  THREE_MF: 'THREE_MF',
  STEP: 'STEP',
  IGES: 'IGES'
};

export type ExportFormat = (typeof ExportFormat)[keyof typeof ExportFormat]


export const ExportStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
};

export type ExportStatus = (typeof ExportStatus)[keyof typeof ExportStatus]


export const ErrorCategory: {
  IMPORT_ERROR: 'IMPORT_ERROR',
  PROCESSING_ERROR: 'PROCESSING_ERROR',
  EXPORT_ERROR: 'EXPORT_ERROR',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  SYSTEM_ERROR: 'SYSTEM_ERROR',
  NETWORK_ERROR: 'NETWORK_ERROR',
  PAYMENT_ERROR: 'PAYMENT_ERROR',
  AUTH_ERROR: 'AUTH_ERROR'
};

export type ErrorCategory = (typeof ErrorCategory)[keyof typeof ErrorCategory]


export const ErrorSeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type ErrorSeverity = (typeof ErrorSeverity)[keyof typeof ErrorSeverity]

}

export type UserTier = $Enums.UserTier

export const UserTier: typeof $Enums.UserTier

export type LicenseType = $Enums.LicenseType

export const LicenseType: typeof $Enums.LicenseType

export type LicenseStatus = $Enums.LicenseStatus

export const LicenseStatus: typeof $Enums.LicenseStatus

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ImportStatus = $Enums.ImportStatus

export const ImportStatus: typeof $Enums.ImportStatus

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type ExportFormat = $Enums.ExportFormat

export const ExportFormat: typeof $Enums.ExportFormat

export type ExportStatus = $Enums.ExportStatus

export const ExportStatus: typeof $Enums.ExportStatus

export type ErrorCategory = $Enums.ErrorCategory

export const ErrorCategory: typeof $Enums.ErrorCategory

export type ErrorSeverity = $Enums.ErrorSeverity

export const ErrorSeverity: typeof $Enums.ErrorSeverity

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.license`: Exposes CRUD operations for the **License** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenses
    * const licenses = await prisma.license.findMany()
    * ```
    */
  get license(): Prisma.LicenseDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.modelImport`: Exposes CRUD operations for the **ModelImport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelImports
    * const modelImports = await prisma.modelImport.findMany()
    * ```
    */
  get modelImport(): Prisma.ModelImportDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.designVersion`: Exposes CRUD operations for the **DesignVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DesignVersions
    * const designVersions = await prisma.designVersion.findMany()
    * ```
    */
  get designVersion(): Prisma.DesignVersionDelegate<ExtArgs>;

  /**
   * `prisma.export`: Exposes CRUD operations for the **Export** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exports
    * const exports = await prisma.export.findMany()
    * ```
    */
  get export(): Prisma.ExportDelegate<ExtArgs>;

  /**
   * `prisma.errorLog`: Exposes CRUD operations for the **ErrorLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ErrorLogs
    * const errorLogs = await prisma.errorLog.findMany()
    * ```
    */
  get errorLog(): Prisma.ErrorLogDelegate<ExtArgs>;

  /**
   * `prisma.sharedProject`: Exposes CRUD operations for the **SharedProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedProjects
    * const sharedProjects = await prisma.sharedProject.findMany()
    * ```
    */
  get sharedProject(): Prisma.SharedProjectDelegate<ExtArgs>;

  /**
   * `prisma.cloudBackup`: Exposes CRUD operations for the **CloudBackup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CloudBackups
    * const cloudBackups = await prisma.cloudBackup.findMany()
    * ```
    */
  get cloudBackup(): Prisma.CloudBackupDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.numExports`: Exposes CRUD operations for the **NumExports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NumExports
    * const numExports = await prisma.numExports.findMany()
    * ```
    */
  get numExports(): Prisma.NumExportsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    License: 'License',
    Subscription: 'Subscription',
    Payment: 'Payment',
    ModelImport: 'ModelImport',
    Project: 'Project',
    DesignVersion: 'DesignVersion',
    Export: 'Export',
    ErrorLog: 'ErrorLog',
    SharedProject: 'SharedProject',
    CloudBackup: 'CloudBackup',
    AuditLog: 'AuditLog',
    NumExports: 'NumExports'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "refreshToken" | "license" | "subscription" | "payment" | "modelImport" | "project" | "designVersion" | "export" | "errorLog" | "sharedProject" | "cloudBackup" | "auditLog" | "numExports"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      License: {
        payload: Prisma.$LicensePayload<ExtArgs>
        fields: Prisma.LicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findFirst: {
            args: Prisma.LicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findMany: {
            args: Prisma.LicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          create: {
            args: Prisma.LicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          createMany: {
            args: Prisma.LicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          delete: {
            args: Prisma.LicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          update: {
            args: Prisma.LicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          deleteMany: {
            args: Prisma.LicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          aggregate: {
            args: Prisma.LicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicense>
          }
          groupBy: {
            args: Prisma.LicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      ModelImport: {
        payload: Prisma.$ModelImportPayload<ExtArgs>
        fields: Prisma.ModelImportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelImportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelImportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload>
          }
          findFirst: {
            args: Prisma.ModelImportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelImportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload>
          }
          findMany: {
            args: Prisma.ModelImportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload>[]
          }
          create: {
            args: Prisma.ModelImportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload>
          }
          createMany: {
            args: Prisma.ModelImportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelImportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload>[]
          }
          delete: {
            args: Prisma.ModelImportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload>
          }
          update: {
            args: Prisma.ModelImportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload>
          }
          deleteMany: {
            args: Prisma.ModelImportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelImportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelImportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelImportPayload>
          }
          aggregate: {
            args: Prisma.ModelImportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelImport>
          }
          groupBy: {
            args: Prisma.ModelImportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelImportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelImportCountArgs<ExtArgs>
            result: $Utils.Optional<ModelImportCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      DesignVersion: {
        payload: Prisma.$DesignVersionPayload<ExtArgs>
        fields: Prisma.DesignVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          findFirst: {
            args: Prisma.DesignVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          findMany: {
            args: Prisma.DesignVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>[]
          }
          create: {
            args: Prisma.DesignVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          createMany: {
            args: Prisma.DesignVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>[]
          }
          delete: {
            args: Prisma.DesignVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          update: {
            args: Prisma.DesignVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          deleteMany: {
            args: Prisma.DesignVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DesignVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignVersionPayload>
          }
          aggregate: {
            args: Prisma.DesignVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignVersion>
          }
          groupBy: {
            args: Prisma.DesignVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignVersionCountArgs<ExtArgs>
            result: $Utils.Optional<DesignVersionCountAggregateOutputType> | number
          }
        }
      }
      Export: {
        payload: Prisma.$ExportPayload<ExtArgs>
        fields: Prisma.ExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          findFirst: {
            args: Prisma.ExportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          findMany: {
            args: Prisma.ExportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>[]
          }
          create: {
            args: Prisma.ExportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          createMany: {
            args: Prisma.ExportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>[]
          }
          delete: {
            args: Prisma.ExportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          update: {
            args: Prisma.ExportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          deleteMany: {
            args: Prisma.ExportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          aggregate: {
            args: Prisma.ExportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExport>
          }
          groupBy: {
            args: Prisma.ExportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportCountArgs<ExtArgs>
            result: $Utils.Optional<ExportCountAggregateOutputType> | number
          }
        }
      }
      ErrorLog: {
        payload: Prisma.$ErrorLogPayload<ExtArgs>
        fields: Prisma.ErrorLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ErrorLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ErrorLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload>
          }
          findFirst: {
            args: Prisma.ErrorLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ErrorLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload>
          }
          findMany: {
            args: Prisma.ErrorLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload>[]
          }
          create: {
            args: Prisma.ErrorLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload>
          }
          createMany: {
            args: Prisma.ErrorLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ErrorLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload>[]
          }
          delete: {
            args: Prisma.ErrorLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload>
          }
          update: {
            args: Prisma.ErrorLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload>
          }
          deleteMany: {
            args: Prisma.ErrorLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ErrorLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ErrorLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorLogPayload>
          }
          aggregate: {
            args: Prisma.ErrorLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateErrorLog>
          }
          groupBy: {
            args: Prisma.ErrorLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ErrorLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ErrorLogCountArgs<ExtArgs>
            result: $Utils.Optional<ErrorLogCountAggregateOutputType> | number
          }
        }
      }
      SharedProject: {
        payload: Prisma.$SharedProjectPayload<ExtArgs>
        fields: Prisma.SharedProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload>
          }
          findFirst: {
            args: Prisma.SharedProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload>
          }
          findMany: {
            args: Prisma.SharedProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload>[]
          }
          create: {
            args: Prisma.SharedProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload>
          }
          createMany: {
            args: Prisma.SharedProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload>[]
          }
          delete: {
            args: Prisma.SharedProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload>
          }
          update: {
            args: Prisma.SharedProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload>
          }
          deleteMany: {
            args: Prisma.SharedProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SharedProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedProjectPayload>
          }
          aggregate: {
            args: Prisma.SharedProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedProject>
          }
          groupBy: {
            args: Prisma.SharedProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedProjectCountArgs<ExtArgs>
            result: $Utils.Optional<SharedProjectCountAggregateOutputType> | number
          }
        }
      }
      CloudBackup: {
        payload: Prisma.$CloudBackupPayload<ExtArgs>
        fields: Prisma.CloudBackupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CloudBackupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CloudBackupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload>
          }
          findFirst: {
            args: Prisma.CloudBackupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CloudBackupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload>
          }
          findMany: {
            args: Prisma.CloudBackupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload>[]
          }
          create: {
            args: Prisma.CloudBackupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload>
          }
          createMany: {
            args: Prisma.CloudBackupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CloudBackupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload>[]
          }
          delete: {
            args: Prisma.CloudBackupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload>
          }
          update: {
            args: Prisma.CloudBackupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload>
          }
          deleteMany: {
            args: Prisma.CloudBackupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CloudBackupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CloudBackupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudBackupPayload>
          }
          aggregate: {
            args: Prisma.CloudBackupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCloudBackup>
          }
          groupBy: {
            args: Prisma.CloudBackupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CloudBackupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CloudBackupCountArgs<ExtArgs>
            result: $Utils.Optional<CloudBackupCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      NumExports: {
        payload: Prisma.$NumExportsPayload<ExtArgs>
        fields: Prisma.NumExportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NumExportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NumExportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload>
          }
          findFirst: {
            args: Prisma.NumExportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NumExportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload>
          }
          findMany: {
            args: Prisma.NumExportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload>[]
          }
          create: {
            args: Prisma.NumExportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload>
          }
          createMany: {
            args: Prisma.NumExportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NumExportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload>[]
          }
          delete: {
            args: Prisma.NumExportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload>
          }
          update: {
            args: Prisma.NumExportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload>
          }
          deleteMany: {
            args: Prisma.NumExportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NumExportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NumExportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NumExportsPayload>
          }
          aggregate: {
            args: Prisma.NumExportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNumExports>
          }
          groupBy: {
            args: Prisma.NumExportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NumExportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NumExportsCountArgs<ExtArgs>
            result: $Utils.Optional<NumExportsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    projects: number
    modelImports: number
    exports: number
    payments: number
    errorLogs: number
    cloudBackups: number
    sharedProjects: number
    receivedShares: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    modelImports?: boolean | UserCountOutputTypeCountModelImportsArgs
    exports?: boolean | UserCountOutputTypeCountExportsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    errorLogs?: boolean | UserCountOutputTypeCountErrorLogsArgs
    cloudBackups?: boolean | UserCountOutputTypeCountCloudBackupsArgs
    sharedProjects?: boolean | UserCountOutputTypeCountSharedProjectsArgs
    receivedShares?: boolean | UserCountOutputTypeCountReceivedSharesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModelImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelImportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountErrorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCloudBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CloudBackupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    payments: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type ModelImportCountOutputType
   */

  export type ModelImportCountOutputType = {
    errorLogs: number
  }

  export type ModelImportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    errorLogs?: boolean | ModelImportCountOutputTypeCountErrorLogsArgs
  }

  // Custom InputTypes
  /**
   * ModelImportCountOutputType without action
   */
  export type ModelImportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImportCountOutputType
     */
    select?: ModelImportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelImportCountOutputType without action
   */
  export type ModelImportCountOutputTypeCountErrorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorLogWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    modelImports: number
    designVersions: number
    exports: number
    cloudBackups: number
    sharedProjects: number
    errorLogs: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelImports?: boolean | ProjectCountOutputTypeCountModelImportsArgs
    designVersions?: boolean | ProjectCountOutputTypeCountDesignVersionsArgs
    exports?: boolean | ProjectCountOutputTypeCountExportsArgs
    cloudBackups?: boolean | ProjectCountOutputTypeCountCloudBackupsArgs
    sharedProjects?: boolean | ProjectCountOutputTypeCountSharedProjectsArgs
    errorLogs?: boolean | ProjectCountOutputTypeCountErrorLogsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountModelImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelImportWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDesignVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignVersionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCloudBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CloudBackupWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSharedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedProjectWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountErrorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorLogWhereInput
  }


  /**
   * Count Type ExportCountOutputType
   */

  export type ExportCountOutputType = {
    errorLogs: number
  }

  export type ExportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    errorLogs?: boolean | ExportCountOutputTypeCountErrorLogsArgs
  }

  // Custom InputTypes
  /**
   * ExportCountOutputType without action
   */
  export type ExportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportCountOutputType
     */
    select?: ExportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExportCountOutputType without action
   */
  export type ExportCountOutputTypeCountErrorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    modelLimit: number | null
    modelsUsed: number | null
    timeSpent: number | null
    maxStepReached: number | null
    lastSessionFinalStep: number | null
    failedLoginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    modelLimit: number | null
    modelsUsed: number | null
    timeSpent: number | null
    maxStepReached: number | null
    lastSessionFinalStep: number | null
    failedLoginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    emailVerified: boolean | null
    verificationToken: string | null
    verificationTokenExpiry: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    name: string | null
    phoneNumber: string | null
    organization: string | null
    jobTitle: string | null
    country: string | null
    industry: string | null
    tier: $Enums.UserTier | null
    modelLimit: number | null
    modelsUsed: number | null
    timeSpent: number | null
    maxStepReached: number | null
    lastSessionFinalStep: number | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    emailVerified: boolean | null
    verificationToken: string | null
    verificationTokenExpiry: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    name: string | null
    phoneNumber: string | null
    organization: string | null
    jobTitle: string | null
    country: string | null
    industry: string | null
    tier: $Enums.UserTier | null
    modelLimit: number | null
    modelsUsed: number | null
    timeSpent: number | null
    maxStepReached: number | null
    lastSessionFinalStep: number | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    emailVerified: number
    verificationToken: number
    verificationTokenExpiry: number
    passwordResetToken: number
    passwordResetExpiry: number
    name: number
    phoneNumber: number
    organization: number
    jobTitle: number
    country: number
    industry: number
    tier: number
    modelLimit: number
    modelsUsed: number
    timeSpent: number
    maxStepReached: number
    lastSessionFinalStep: number
    failedLoginAttempts: number
    lockedUntil: number
    mfaEnabled: number
    mfaSecret: number
    avatarUrl: number
    preferences: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    modelLimit?: true
    modelsUsed?: true
    timeSpent?: true
    maxStepReached?: true
    lastSessionFinalStep?: true
    failedLoginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    modelLimit?: true
    modelsUsed?: true
    timeSpent?: true
    maxStepReached?: true
    lastSessionFinalStep?: true
    failedLoginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    emailVerified?: true
    verificationToken?: true
    verificationTokenExpiry?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    name?: true
    phoneNumber?: true
    organization?: true
    jobTitle?: true
    country?: true
    industry?: true
    tier?: true
    modelLimit?: true
    modelsUsed?: true
    timeSpent?: true
    maxStepReached?: true
    lastSessionFinalStep?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    mfaEnabled?: true
    mfaSecret?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    emailVerified?: true
    verificationToken?: true
    verificationTokenExpiry?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    name?: true
    phoneNumber?: true
    organization?: true
    jobTitle?: true
    country?: true
    industry?: true
    tier?: true
    modelLimit?: true
    modelsUsed?: true
    timeSpent?: true
    maxStepReached?: true
    lastSessionFinalStep?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    mfaEnabled?: true
    mfaSecret?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    emailVerified?: true
    verificationToken?: true
    verificationTokenExpiry?: true
    passwordResetToken?: true
    passwordResetExpiry?: true
    name?: true
    phoneNumber?: true
    organization?: true
    jobTitle?: true
    country?: true
    industry?: true
    tier?: true
    modelLimit?: true
    modelsUsed?: true
    timeSpent?: true
    maxStepReached?: true
    lastSessionFinalStep?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    mfaEnabled?: true
    mfaSecret?: true
    avatarUrl?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    emailVerified: boolean
    verificationToken: string | null
    verificationTokenExpiry: Date | null
    passwordResetToken: string | null
    passwordResetExpiry: Date | null
    name: string
    phoneNumber: string | null
    organization: string | null
    jobTitle: string | null
    country: string | null
    industry: string | null
    tier: $Enums.UserTier
    modelLimit: number
    modelsUsed: number
    timeSpent: number
    maxStepReached: number
    lastSessionFinalStep: number
    failedLoginAttempts: number
    lockedUntil: Date | null
    mfaEnabled: boolean
    mfaSecret: string | null
    avatarUrl: string | null
    preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiry?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    name?: boolean
    phoneNumber?: boolean
    organization?: boolean
    jobTitle?: boolean
    country?: boolean
    industry?: boolean
    tier?: boolean
    modelLimit?: boolean
    modelsUsed?: boolean
    timeSpent?: boolean
    maxStepReached?: boolean
    lastSessionFinalStep?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    deletedAt?: boolean
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    license?: boolean | User$licenseArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    modelImports?: boolean | User$modelImportsArgs<ExtArgs>
    exports?: boolean | User$exportsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    errorLogs?: boolean | User$errorLogsArgs<ExtArgs>
    cloudBackups?: boolean | User$cloudBackupsArgs<ExtArgs>
    sharedProjects?: boolean | User$sharedProjectsArgs<ExtArgs>
    receivedShares?: boolean | User$receivedSharesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    numExports?: boolean | User$numExportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiry?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    name?: boolean
    phoneNumber?: boolean
    organization?: boolean
    jobTitle?: boolean
    country?: boolean
    industry?: boolean
    tier?: boolean
    modelLimit?: boolean
    modelsUsed?: boolean
    timeSpent?: boolean
    maxStepReached?: boolean
    lastSessionFinalStep?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiry?: boolean
    passwordResetToken?: boolean
    passwordResetExpiry?: boolean
    name?: boolean
    phoneNumber?: boolean
    organization?: boolean
    jobTitle?: boolean
    country?: boolean
    industry?: boolean
    tier?: boolean
    modelLimit?: boolean
    modelsUsed?: boolean
    timeSpent?: boolean
    maxStepReached?: boolean
    lastSessionFinalStep?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    license?: boolean | User$licenseArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    modelImports?: boolean | User$modelImportsArgs<ExtArgs>
    exports?: boolean | User$exportsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    errorLogs?: boolean | User$errorLogsArgs<ExtArgs>
    cloudBackups?: boolean | User$cloudBackupsArgs<ExtArgs>
    sharedProjects?: boolean | User$sharedProjectsArgs<ExtArgs>
    receivedShares?: boolean | User$receivedSharesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    numExports?: boolean | User$numExportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      license: Prisma.$LicensePayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      modelImports: Prisma.$ModelImportPayload<ExtArgs>[]
      exports: Prisma.$ExportPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      errorLogs: Prisma.$ErrorLogPayload<ExtArgs>[]
      cloudBackups: Prisma.$CloudBackupPayload<ExtArgs>[]
      sharedProjects: Prisma.$SharedProjectPayload<ExtArgs>[]
      receivedShares: Prisma.$SharedProjectPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      numExports: Prisma.$NumExportsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      emailVerified: boolean
      verificationToken: string | null
      verificationTokenExpiry: Date | null
      passwordResetToken: string | null
      passwordResetExpiry: Date | null
      name: string
      phoneNumber: string | null
      organization: string | null
      jobTitle: string | null
      country: string | null
      industry: string | null
      tier: $Enums.UserTier
      modelLimit: number
      modelsUsed: number
      timeSpent: number
      maxStepReached: number
      lastSessionFinalStep: number
      failedLoginAttempts: number
      lockedUntil: Date | null
      mfaEnabled: boolean
      mfaSecret: string | null
      avatarUrl: string | null
      preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    license<T extends User$licenseArgs<ExtArgs> = {}>(args?: Subset<T, User$licenseArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    modelImports<T extends User$modelImportsArgs<ExtArgs> = {}>(args?: Subset<T, User$modelImportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "findMany"> | Null>
    exports<T extends User$exportsArgs<ExtArgs> = {}>(args?: Subset<T, User$exportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    errorLogs<T extends User$errorLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$errorLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findMany"> | Null>
    cloudBackups<T extends User$cloudBackupsArgs<ExtArgs> = {}>(args?: Subset<T, User$cloudBackupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "findMany"> | Null>
    sharedProjects<T extends User$sharedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "findMany"> | Null>
    receivedShares<T extends User$receivedSharesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    numExports<T extends User$numExportsArgs<ExtArgs> = {}>(args?: Subset<T, User$numExportsArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly verificationTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpiry: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly organization: FieldRef<"User", 'String'>
    readonly jobTitle: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly industry: FieldRef<"User", 'String'>
    readonly tier: FieldRef<"User", 'UserTier'>
    readonly modelLimit: FieldRef<"User", 'Int'>
    readonly modelsUsed: FieldRef<"User", 'Int'>
    readonly timeSpent: FieldRef<"User", 'Int'>
    readonly maxStepReached: FieldRef<"User", 'Int'>
    readonly lastSessionFinalStep: FieldRef<"User", 'Int'>
    readonly failedLoginAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly mfaEnabled: FieldRef<"User", 'Boolean'>
    readonly mfaSecret: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.license
   */
  export type User$licenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    where?: LicenseWhereInput
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.modelImports
   */
  export type User$modelImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    where?: ModelImportWhereInput
    orderBy?: ModelImportOrderByWithRelationInput | ModelImportOrderByWithRelationInput[]
    cursor?: ModelImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelImportScalarFieldEnum | ModelImportScalarFieldEnum[]
  }

  /**
   * User.exports
   */
  export type User$exportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    where?: ExportWhereInput
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    cursor?: ExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportScalarFieldEnum | ExportScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.errorLogs
   */
  export type User$errorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    where?: ErrorLogWhereInput
    orderBy?: ErrorLogOrderByWithRelationInput | ErrorLogOrderByWithRelationInput[]
    cursor?: ErrorLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ErrorLogScalarFieldEnum | ErrorLogScalarFieldEnum[]
  }

  /**
   * User.cloudBackups
   */
  export type User$cloudBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    where?: CloudBackupWhereInput
    orderBy?: CloudBackupOrderByWithRelationInput | CloudBackupOrderByWithRelationInput[]
    cursor?: CloudBackupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CloudBackupScalarFieldEnum | CloudBackupScalarFieldEnum[]
  }

  /**
   * User.sharedProjects
   */
  export type User$sharedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    where?: SharedProjectWhereInput
    orderBy?: SharedProjectOrderByWithRelationInput | SharedProjectOrderByWithRelationInput[]
    cursor?: SharedProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedProjectScalarFieldEnum | SharedProjectScalarFieldEnum[]
  }

  /**
   * User.receivedShares
   */
  export type User$receivedSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    where?: SharedProjectWhereInput
    orderBy?: SharedProjectOrderByWithRelationInput | SharedProjectOrderByWithRelationInput[]
    cursor?: SharedProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedProjectScalarFieldEnum | SharedProjectScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.numExports
   */
  export type User$numExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    where?: NumExportsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    revoked: boolean | null
    revokedAt: Date | null
    replacedByToken: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    revoked: boolean | null
    revokedAt: Date | null
    replacedByToken: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    expiresAt: number
    revoked: number
    revokedAt: number
    replacedByToken: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    revoked?: true
    revokedAt?: true
    replacedByToken?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    revoked?: true
    revokedAt?: true
    replacedByToken?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    revoked?: true
    revokedAt?: true
    replacedByToken?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    expiresAt: Date
    revoked: boolean
    revokedAt: Date | null
    replacedByToken: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    revoked?: boolean
    revokedAt?: boolean
    replacedByToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    revoked?: boolean
    revokedAt?: boolean
    replacedByToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    revoked?: boolean
    revokedAt?: boolean
    replacedByToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      expiresAt: Date
      revoked: boolean
      revokedAt: Date | null
      replacedByToken: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly tokenHash: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly replacedByToken: FieldRef<"RefreshToken", 'String'>
    readonly ipAddress: FieldRef<"RefreshToken", 'String'>
    readonly userAgent: FieldRef<"RefreshToken", 'String'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model License
   */

  export type AggregateLicense = {
    _count: LicenseCountAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  export type LicenseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    licenseType: $Enums.LicenseType | null
    status: $Enums.LicenseStatus | null
    dateStart: Date | null
    dateEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LicenseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    licenseType: $Enums.LicenseType | null
    status: $Enums.LicenseStatus | null
    dateStart: Date | null
    dateEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LicenseCountAggregateOutputType = {
    id: number
    userId: number
    licenseType: number
    status: number
    dateStart: number
    dateEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LicenseMinAggregateInputType = {
    id?: true
    userId?: true
    licenseType?: true
    status?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LicenseMaxAggregateInputType = {
    id?: true
    userId?: true
    licenseType?: true
    status?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LicenseCountAggregateInputType = {
    id?: true
    userId?: true
    licenseType?: true
    status?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which License to aggregate.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenses
    **/
    _count?: true | LicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseMaxAggregateInputType
  }

  export type GetLicenseAggregateType<T extends LicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicense[P]>
      : GetScalarType<T[P], AggregateLicense[P]>
  }




  export type LicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithAggregationInput | LicenseOrderByWithAggregationInput[]
    by: LicenseScalarFieldEnum[] | LicenseScalarFieldEnum
    having?: LicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseCountAggregateInputType | true
    _min?: LicenseMinAggregateInputType
    _max?: LicenseMaxAggregateInputType
  }

  export type LicenseGroupByOutputType = {
    id: string
    userId: string
    licenseType: $Enums.LicenseType
    status: $Enums.LicenseStatus
    dateStart: Date
    dateEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LicenseCountAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  type GetLicenseGroupByPayload<T extends LicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseGroupByOutputType[P]>
        }
      >
    >


  export type LicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseType?: boolean
    status?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseType?: boolean
    status?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectScalar = {
    id?: boolean
    userId?: boolean
    licenseType?: boolean
    status?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LicenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LicenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "License"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      licenseType: $Enums.LicenseType
      status: $Enums.LicenseStatus
      dateStart: Date
      dateEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["license"]>
    composites: {}
  }

  type LicenseGetPayload<S extends boolean | null | undefined | LicenseDefaultArgs> = $Result.GetResult<Prisma.$LicensePayload, S>

  type LicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LicenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LicenseCountAggregateInputType | true
    }

  export interface LicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['License'], meta: { name: 'License' } }
    /**
     * Find zero or one License that matches the filter.
     * @param {LicenseFindUniqueArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseFindUniqueArgs>(args: SelectSubset<T, LicenseFindUniqueArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one License that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LicenseFindUniqueOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first License that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseFindFirstArgs>(args?: SelectSubset<T, LicenseFindFirstArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first License that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenses
     * const licenses = await prisma.license.findMany()
     * 
     * // Get first 10 Licenses
     * const licenses = await prisma.license.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenseWithIdOnly = await prisma.license.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenseFindManyArgs>(args?: SelectSubset<T, LicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a License.
     * @param {LicenseCreateArgs} args - Arguments to create a License.
     * @example
     * // Create one License
     * const License = await prisma.license.create({
     *   data: {
     *     // ... data to create a License
     *   }
     * })
     * 
     */
    create<T extends LicenseCreateArgs>(args: SelectSubset<T, LicenseCreateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Licenses.
     * @param {LicenseCreateManyArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseCreateManyArgs>(args?: SelectSubset<T, LicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Licenses and returns the data saved in the database.
     * @param {LicenseCreateManyAndReturnArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Licenses and only return the `id`
     * const licenseWithIdOnly = await prisma.license.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenseCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a License.
     * @param {LicenseDeleteArgs} args - Arguments to delete one License.
     * @example
     * // Delete one License
     * const License = await prisma.license.delete({
     *   where: {
     *     // ... filter to delete one License
     *   }
     * })
     * 
     */
    delete<T extends LicenseDeleteArgs>(args: SelectSubset<T, LicenseDeleteArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one License.
     * @param {LicenseUpdateArgs} args - Arguments to update one License.
     * @example
     * // Update one License
     * const license = await prisma.license.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseUpdateArgs>(args: SelectSubset<T, LicenseUpdateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Licenses.
     * @param {LicenseDeleteManyArgs} args - Arguments to filter Licenses to delete.
     * @example
     * // Delete a few Licenses
     * const { count } = await prisma.license.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseDeleteManyArgs>(args?: SelectSubset<T, LicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseUpdateManyArgs>(args: SelectSubset<T, LicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one License.
     * @param {LicenseUpsertArgs} args - Arguments to update or create a License.
     * @example
     * // Update or create a License
     * const license = await prisma.license.upsert({
     *   create: {
     *     // ... data to create a License
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the License we want to update
     *   }
     * })
     */
    upsert<T extends LicenseUpsertArgs>(args: SelectSubset<T, LicenseUpsertArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseCountArgs} args - Arguments to filter Licenses to count.
     * @example
     * // Count the number of Licenses
     * const count = await prisma.license.count({
     *   where: {
     *     // ... the filter for the Licenses we want to count
     *   }
     * })
    **/
    count<T extends LicenseCountArgs>(
      args?: Subset<T, LicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAggregateArgs>(args: Subset<T, LicenseAggregateArgs>): Prisma.PrismaPromise<GetLicenseAggregateType<T>>

    /**
     * Group by License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseGroupByArgs['orderBy'] }
        : { orderBy?: LicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the License model
   */
  readonly fields: LicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for License.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the License model
   */ 
  interface LicenseFieldRefs {
    readonly id: FieldRef<"License", 'String'>
    readonly userId: FieldRef<"License", 'String'>
    readonly licenseType: FieldRef<"License", 'LicenseType'>
    readonly status: FieldRef<"License", 'LicenseStatus'>
    readonly dateStart: FieldRef<"License", 'DateTime'>
    readonly dateEnd: FieldRef<"License", 'DateTime'>
    readonly createdAt: FieldRef<"License", 'DateTime'>
    readonly updatedAt: FieldRef<"License", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * License findUnique
   */
  export type LicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findUniqueOrThrow
   */
  export type LicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findFirst
   */
  export type LicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findFirstOrThrow
   */
  export type LicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findMany
   */
  export type LicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License create
   */
  export type LicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to create a License.
     */
    data: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
  }

  /**
   * License createMany
   */
  export type LicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * License createManyAndReturn
   */
  export type LicenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * License update
   */
  export type LicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to update a License.
     */
    data: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
    /**
     * Choose, which License to update.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License updateMany
   */
  export type LicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
  }

  /**
   * License upsert
   */
  export type LicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The filter to search for the License to update in case it exists.
     */
    where: LicenseWhereUniqueInput
    /**
     * In case the License found by the `where` argument doesn't exist, create a new License with this data.
     */
    create: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
    /**
     * In case the License was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
  }

  /**
   * License delete
   */
  export type LicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter which License to delete.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License deleteMany
   */
  export type LicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to delete
     */
    where?: LicenseWhereInput
  }

  /**
   * License without action
   */
  export type LicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    amount: number | null
    modelLimit: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    amount: number | null
    modelLimit: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: $Enums.UserTier | null
    status: $Enums.SubscriptionStatus | null
    billingCycle: string | null
    amount: number | null
    currency: string | null
    modelLimit: number | null
    startDate: Date | null
    endDate: Date | null
    nextBillingDate: Date | null
    cancelledAt: Date | null
    autoRenew: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: $Enums.UserTier | null
    status: $Enums.SubscriptionStatus | null
    billingCycle: string | null
    amount: number | null
    currency: string | null
    modelLimit: number | null
    startDate: Date | null
    endDate: Date | null
    nextBillingDate: Date | null
    cancelledAt: Date | null
    autoRenew: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    tier: number
    status: number
    billingCycle: number
    amount: number
    currency: number
    modelLimit: number
    startDate: number
    endDate: number
    nextBillingDate: number
    cancelledAt: number
    autoRenew: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    amount?: true
    modelLimit?: true
  }

  export type SubscriptionSumAggregateInputType = {
    amount?: true
    modelLimit?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    status?: true
    billingCycle?: true
    amount?: true
    currency?: true
    modelLimit?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    cancelledAt?: true
    autoRenew?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    status?: true
    billingCycle?: true
    amount?: true
    currency?: true
    modelLimit?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    cancelledAt?: true
    autoRenew?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    status?: true
    billingCycle?: true
    amount?: true
    currency?: true
    modelLimit?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    cancelledAt?: true
    autoRenew?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    tier: $Enums.UserTier
    status: $Enums.SubscriptionStatus
    billingCycle: string
    amount: number
    currency: string
    modelLimit: number
    startDate: Date
    endDate: Date | null
    nextBillingDate: Date | null
    cancelledAt: Date | null
    autoRenew: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    status?: boolean
    billingCycle?: boolean
    amount?: boolean
    currency?: boolean
    modelLimit?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    cancelledAt?: boolean
    autoRenew?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    status?: boolean
    billingCycle?: boolean
    amount?: boolean
    currency?: boolean
    modelLimit?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    cancelledAt?: boolean
    autoRenew?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    tier?: boolean
    status?: boolean
    billingCycle?: boolean
    amount?: boolean
    currency?: boolean
    modelLimit?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    cancelledAt?: boolean
    autoRenew?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tier: $Enums.UserTier
      status: $Enums.SubscriptionStatus
      billingCycle: string
      amount: number
      currency: string
      modelLimit: number
      startDate: Date
      endDate: Date | null
      nextBillingDate: Date | null
      cancelledAt: Date | null
      autoRenew: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Subscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly tier: FieldRef<"Subscription", 'UserTier'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly billingCycle: FieldRef<"Subscription", 'String'>
    readonly amount: FieldRef<"Subscription", 'Float'>
    readonly currency: FieldRef<"Subscription", 'String'>
    readonly modelLimit: FieldRef<"Subscription", 'Int'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly nextBillingDate: FieldRef<"Subscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly autoRenew: FieldRef<"Subscription", 'Boolean'>
    readonly metadata: FieldRef<"Subscription", 'Json'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.payments
   */
  export type Subscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
    refundedAmount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
    refundedAmount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    gatewayProvider: string | null
    gatewayOrderId: string | null
    gatewayPaymentId: string | null
    gatewaySignature: string | null
    transactionId: string | null
    receiptUrl: string | null
    invoiceUrl: string | null
    failureReason: string | null
    failureCode: string | null
    refundedAmount: number | null
    refundedAt: Date | null
    refundReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    gatewayProvider: string | null
    gatewayOrderId: string | null
    gatewayPaymentId: string | null
    gatewaySignature: string | null
    transactionId: string | null
    receiptUrl: string | null
    invoiceUrl: string | null
    failureReason: string | null
    failureCode: string | null
    refundedAmount: number | null
    refundedAt: Date | null
    refundReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    subscriptionId: number
    amount: number
    currency: number
    status: number
    paymentMethod: number
    gatewayProvider: number
    gatewayOrderId: number
    gatewayPaymentId: number
    gatewaySignature: number
    transactionId: number
    receiptUrl: number
    invoiceUrl: number
    failureReason: number
    failureCode: number
    refundedAmount: number
    refundedAt: number
    refundReason: number
    metadata: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    refundedAmount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    refundedAmount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    gatewayProvider?: true
    gatewayOrderId?: true
    gatewayPaymentId?: true
    gatewaySignature?: true
    transactionId?: true
    receiptUrl?: true
    invoiceUrl?: true
    failureReason?: true
    failureCode?: true
    refundedAmount?: true
    refundedAt?: true
    refundReason?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    gatewayProvider?: true
    gatewayOrderId?: true
    gatewayPaymentId?: true
    gatewaySignature?: true
    transactionId?: true
    receiptUrl?: true
    invoiceUrl?: true
    failureReason?: true
    failureCode?: true
    refundedAmount?: true
    refundedAt?: true
    refundReason?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    gatewayProvider?: true
    gatewayOrderId?: true
    gatewayPaymentId?: true
    gatewaySignature?: true
    transactionId?: true
    receiptUrl?: true
    invoiceUrl?: true
    failureReason?: true
    failureCode?: true
    refundedAmount?: true
    refundedAt?: true
    refundReason?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    subscriptionId: string | null
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId: string | null
    gatewayPaymentId: string | null
    gatewaySignature: string | null
    transactionId: string | null
    receiptUrl: string | null
    invoiceUrl: string | null
    failureReason: string | null
    failureCode: string | null
    refundedAmount: number | null
    refundedAt: Date | null
    refundReason: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    gatewayProvider?: boolean
    gatewayOrderId?: boolean
    gatewayPaymentId?: boolean
    gatewaySignature?: boolean
    transactionId?: boolean
    receiptUrl?: boolean
    invoiceUrl?: boolean
    failureReason?: boolean
    failureCode?: boolean
    refundedAmount?: boolean
    refundedAt?: boolean
    refundReason?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    gatewayProvider?: boolean
    gatewayOrderId?: boolean
    gatewayPaymentId?: boolean
    gatewaySignature?: boolean
    transactionId?: boolean
    receiptUrl?: boolean
    invoiceUrl?: boolean
    failureReason?: boolean
    failureCode?: boolean
    refundedAmount?: boolean
    refundedAt?: boolean
    refundReason?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    gatewayProvider?: boolean
    gatewayOrderId?: boolean
    gatewayPaymentId?: boolean
    gatewaySignature?: boolean
    transactionId?: boolean
    receiptUrl?: boolean
    invoiceUrl?: boolean
    failureReason?: boolean
    failureCode?: boolean
    refundedAmount?: boolean
    refundedAt?: boolean
    refundReason?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subscriptionId: string | null
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      paymentMethod: $Enums.PaymentMethod
      gatewayProvider: string
      gatewayOrderId: string | null
      gatewayPaymentId: string | null
      gatewaySignature: string | null
      transactionId: string | null
      receiptUrl: string | null
      invoiceUrl: string | null
      failureReason: string | null
      failureCode: string | null
      refundedAmount: number | null
      refundedAt: Date | null
      refundReason: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subscription<T extends Payment$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly subscriptionId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly gatewayProvider: FieldRef<"Payment", 'String'>
    readonly gatewayOrderId: FieldRef<"Payment", 'String'>
    readonly gatewayPaymentId: FieldRef<"Payment", 'String'>
    readonly gatewaySignature: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly receiptUrl: FieldRef<"Payment", 'String'>
    readonly invoiceUrl: FieldRef<"Payment", 'String'>
    readonly failureReason: FieldRef<"Payment", 'String'>
    readonly failureCode: FieldRef<"Payment", 'String'>
    readonly refundedAmount: FieldRef<"Payment", 'Float'>
    readonly refundedAt: FieldRef<"Payment", 'DateTime'>
    readonly refundReason: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly completedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.subscription
   */
  export type Payment$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model ModelImport
   */

  export type AggregateModelImport = {
    _count: ModelImportCountAggregateOutputType | null
    _avg: ModelImportAvgAggregateOutputType | null
    _sum: ModelImportSumAggregateOutputType | null
    _min: ModelImportMinAggregateOutputType | null
    _max: ModelImportMaxAggregateOutputType | null
  }

  export type ModelImportAvgAggregateOutputType = {
    fileSize: number | null
    progress: number | null
    processingDuration: number | null
    vertexCount: number | null
    faceCount: number | null
    volume: number | null
  }

  export type ModelImportSumAggregateOutputType = {
    fileSize: number | null
    progress: number | null
    processingDuration: number | null
    vertexCount: number | null
    faceCount: number | null
    volume: number | null
  }

  export type ModelImportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    filename: string | null
    originalFilename: string | null
    fileSize: number | null
    fileHash: string | null
    modelData: Buffer | null
    thumbnailData: Buffer | null
    status: $Enums.ImportStatus | null
    progress: number | null
    processingStartedAt: Date | null
    processingCompletedAt: Date | null
    processingDuration: number | null
    vertexCount: number | null
    faceCount: number | null
    volume: number | null
    isValid: boolean | null
    errorMessage: string | null
    errorCode: string | null
    countsTowardLimit: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ModelImportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    filename: string | null
    originalFilename: string | null
    fileSize: number | null
    fileHash: string | null
    modelData: Buffer | null
    thumbnailData: Buffer | null
    status: $Enums.ImportStatus | null
    progress: number | null
    processingStartedAt: Date | null
    processingCompletedAt: Date | null
    processingDuration: number | null
    vertexCount: number | null
    faceCount: number | null
    volume: number | null
    isValid: boolean | null
    errorMessage: string | null
    errorCode: string | null
    countsTowardLimit: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ModelImportCountAggregateOutputType = {
    id: number
    userId: number
    projectId: number
    filename: number
    originalFilename: number
    fileSize: number
    fileHash: number
    modelData: number
    thumbnailData: number
    status: number
    progress: number
    processingStartedAt: number
    processingCompletedAt: number
    processingDuration: number
    vertexCount: number
    faceCount: number
    boundingBox: number
    dimensions: number
    volume: number
    isValid: number
    validationErrors: number
    errorMessage: number
    errorCode: number
    countsTowardLimit: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ModelImportAvgAggregateInputType = {
    fileSize?: true
    progress?: true
    processingDuration?: true
    vertexCount?: true
    faceCount?: true
    volume?: true
  }

  export type ModelImportSumAggregateInputType = {
    fileSize?: true
    progress?: true
    processingDuration?: true
    vertexCount?: true
    faceCount?: true
    volume?: true
  }

  export type ModelImportMinAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    filename?: true
    originalFilename?: true
    fileSize?: true
    fileHash?: true
    modelData?: true
    thumbnailData?: true
    status?: true
    progress?: true
    processingStartedAt?: true
    processingCompletedAt?: true
    processingDuration?: true
    vertexCount?: true
    faceCount?: true
    volume?: true
    isValid?: true
    errorMessage?: true
    errorCode?: true
    countsTowardLimit?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ModelImportMaxAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    filename?: true
    originalFilename?: true
    fileSize?: true
    fileHash?: true
    modelData?: true
    thumbnailData?: true
    status?: true
    progress?: true
    processingStartedAt?: true
    processingCompletedAt?: true
    processingDuration?: true
    vertexCount?: true
    faceCount?: true
    volume?: true
    isValid?: true
    errorMessage?: true
    errorCode?: true
    countsTowardLimit?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ModelImportCountAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    filename?: true
    originalFilename?: true
    fileSize?: true
    fileHash?: true
    modelData?: true
    thumbnailData?: true
    status?: true
    progress?: true
    processingStartedAt?: true
    processingCompletedAt?: true
    processingDuration?: true
    vertexCount?: true
    faceCount?: true
    boundingBox?: true
    dimensions?: true
    volume?: true
    isValid?: true
    validationErrors?: true
    errorMessage?: true
    errorCode?: true
    countsTowardLimit?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ModelImportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelImport to aggregate.
     */
    where?: ModelImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelImports to fetch.
     */
    orderBy?: ModelImportOrderByWithRelationInput | ModelImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelImports
    **/
    _count?: true | ModelImportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelImportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelImportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelImportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelImportMaxAggregateInputType
  }

  export type GetModelImportAggregateType<T extends ModelImportAggregateArgs> = {
        [P in keyof T & keyof AggregateModelImport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelImport[P]>
      : GetScalarType<T[P], AggregateModelImport[P]>
  }




  export type ModelImportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelImportWhereInput
    orderBy?: ModelImportOrderByWithAggregationInput | ModelImportOrderByWithAggregationInput[]
    by: ModelImportScalarFieldEnum[] | ModelImportScalarFieldEnum
    having?: ModelImportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelImportCountAggregateInputType | true
    _avg?: ModelImportAvgAggregateInputType
    _sum?: ModelImportSumAggregateInputType
    _min?: ModelImportMinAggregateInputType
    _max?: ModelImportMaxAggregateInputType
  }

  export type ModelImportGroupByOutputType = {
    id: string
    userId: string
    projectId: string | null
    filename: string
    originalFilename: string
    fileSize: number
    fileHash: string | null
    modelData: Buffer | null
    thumbnailData: Buffer | null
    status: $Enums.ImportStatus
    progress: number
    processingStartedAt: Date | null
    processingCompletedAt: Date | null
    processingDuration: number | null
    vertexCount: number | null
    faceCount: number | null
    boundingBox: JsonValue | null
    dimensions: JsonValue | null
    volume: number | null
    isValid: boolean
    validationErrors: JsonValue | null
    errorMessage: string | null
    errorCode: string | null
    countsTowardLimit: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ModelImportCountAggregateOutputType | null
    _avg: ModelImportAvgAggregateOutputType | null
    _sum: ModelImportSumAggregateOutputType | null
    _min: ModelImportMinAggregateOutputType | null
    _max: ModelImportMaxAggregateOutputType | null
  }

  type GetModelImportGroupByPayload<T extends ModelImportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelImportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelImportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelImportGroupByOutputType[P]>
            : GetScalarType<T[P], ModelImportGroupByOutputType[P]>
        }
      >
    >


  export type ModelImportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    fileHash?: boolean
    modelData?: boolean
    thumbnailData?: boolean
    status?: boolean
    progress?: boolean
    processingStartedAt?: boolean
    processingCompletedAt?: boolean
    processingDuration?: boolean
    vertexCount?: boolean
    faceCount?: boolean
    boundingBox?: boolean
    dimensions?: boolean
    volume?: boolean
    isValid?: boolean
    validationErrors?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    countsTowardLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ModelImport$projectArgs<ExtArgs>
    errorLogs?: boolean | ModelImport$errorLogsArgs<ExtArgs>
    _count?: boolean | ModelImportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelImport"]>

  export type ModelImportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    fileHash?: boolean
    modelData?: boolean
    thumbnailData?: boolean
    status?: boolean
    progress?: boolean
    processingStartedAt?: boolean
    processingCompletedAt?: boolean
    processingDuration?: boolean
    vertexCount?: boolean
    faceCount?: boolean
    boundingBox?: boolean
    dimensions?: boolean
    volume?: boolean
    isValid?: boolean
    validationErrors?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    countsTowardLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ModelImport$projectArgs<ExtArgs>
  }, ExtArgs["result"]["modelImport"]>

  export type ModelImportSelectScalar = {
    id?: boolean
    userId?: boolean
    projectId?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileSize?: boolean
    fileHash?: boolean
    modelData?: boolean
    thumbnailData?: boolean
    status?: boolean
    progress?: boolean
    processingStartedAt?: boolean
    processingCompletedAt?: boolean
    processingDuration?: boolean
    vertexCount?: boolean
    faceCount?: boolean
    boundingBox?: boolean
    dimensions?: boolean
    volume?: boolean
    isValid?: boolean
    validationErrors?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    countsTowardLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ModelImportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ModelImport$projectArgs<ExtArgs>
    errorLogs?: boolean | ModelImport$errorLogsArgs<ExtArgs>
    _count?: boolean | ModelImportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModelImportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ModelImport$projectArgs<ExtArgs>
  }

  export type $ModelImportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelImport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      errorLogs: Prisma.$ErrorLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      projectId: string | null
      filename: string
      originalFilename: string
      fileSize: number
      fileHash: string | null
      modelData: Buffer | null
      thumbnailData: Buffer | null
      status: $Enums.ImportStatus
      progress: number
      processingStartedAt: Date | null
      processingCompletedAt: Date | null
      processingDuration: number | null
      vertexCount: number | null
      faceCount: number | null
      boundingBox: Prisma.JsonValue | null
      dimensions: Prisma.JsonValue | null
      volume: number | null
      isValid: boolean
      validationErrors: Prisma.JsonValue | null
      errorMessage: string | null
      errorCode: string | null
      countsTowardLimit: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["modelImport"]>
    composites: {}
  }

  type ModelImportGetPayload<S extends boolean | null | undefined | ModelImportDefaultArgs> = $Result.GetResult<Prisma.$ModelImportPayload, S>

  type ModelImportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModelImportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModelImportCountAggregateInputType | true
    }

  export interface ModelImportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelImport'], meta: { name: 'ModelImport' } }
    /**
     * Find zero or one ModelImport that matches the filter.
     * @param {ModelImportFindUniqueArgs} args - Arguments to find a ModelImport
     * @example
     * // Get one ModelImport
     * const modelImport = await prisma.modelImport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelImportFindUniqueArgs>(args: SelectSubset<T, ModelImportFindUniqueArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModelImport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModelImportFindUniqueOrThrowArgs} args - Arguments to find a ModelImport
     * @example
     * // Get one ModelImport
     * const modelImport = await prisma.modelImport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelImportFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelImportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModelImport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelImportFindFirstArgs} args - Arguments to find a ModelImport
     * @example
     * // Get one ModelImport
     * const modelImport = await prisma.modelImport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelImportFindFirstArgs>(args?: SelectSubset<T, ModelImportFindFirstArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModelImport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelImportFindFirstOrThrowArgs} args - Arguments to find a ModelImport
     * @example
     * // Get one ModelImport
     * const modelImport = await prisma.modelImport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelImportFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelImportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModelImports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelImportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelImports
     * const modelImports = await prisma.modelImport.findMany()
     * 
     * // Get first 10 ModelImports
     * const modelImports = await prisma.modelImport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelImportWithIdOnly = await prisma.modelImport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelImportFindManyArgs>(args?: SelectSubset<T, ModelImportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModelImport.
     * @param {ModelImportCreateArgs} args - Arguments to create a ModelImport.
     * @example
     * // Create one ModelImport
     * const ModelImport = await prisma.modelImport.create({
     *   data: {
     *     // ... data to create a ModelImport
     *   }
     * })
     * 
     */
    create<T extends ModelImportCreateArgs>(args: SelectSubset<T, ModelImportCreateArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModelImports.
     * @param {ModelImportCreateManyArgs} args - Arguments to create many ModelImports.
     * @example
     * // Create many ModelImports
     * const modelImport = await prisma.modelImport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelImportCreateManyArgs>(args?: SelectSubset<T, ModelImportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelImports and returns the data saved in the database.
     * @param {ModelImportCreateManyAndReturnArgs} args - Arguments to create many ModelImports.
     * @example
     * // Create many ModelImports
     * const modelImport = await prisma.modelImport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelImports and only return the `id`
     * const modelImportWithIdOnly = await prisma.modelImport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelImportCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelImportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModelImport.
     * @param {ModelImportDeleteArgs} args - Arguments to delete one ModelImport.
     * @example
     * // Delete one ModelImport
     * const ModelImport = await prisma.modelImport.delete({
     *   where: {
     *     // ... filter to delete one ModelImport
     *   }
     * })
     * 
     */
    delete<T extends ModelImportDeleteArgs>(args: SelectSubset<T, ModelImportDeleteArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModelImport.
     * @param {ModelImportUpdateArgs} args - Arguments to update one ModelImport.
     * @example
     * // Update one ModelImport
     * const modelImport = await prisma.modelImport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelImportUpdateArgs>(args: SelectSubset<T, ModelImportUpdateArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModelImports.
     * @param {ModelImportDeleteManyArgs} args - Arguments to filter ModelImports to delete.
     * @example
     * // Delete a few ModelImports
     * const { count } = await prisma.modelImport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelImportDeleteManyArgs>(args?: SelectSubset<T, ModelImportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelImportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelImports
     * const modelImport = await prisma.modelImport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelImportUpdateManyArgs>(args: SelectSubset<T, ModelImportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModelImport.
     * @param {ModelImportUpsertArgs} args - Arguments to update or create a ModelImport.
     * @example
     * // Update or create a ModelImport
     * const modelImport = await prisma.modelImport.upsert({
     *   create: {
     *     // ... data to create a ModelImport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelImport we want to update
     *   }
     * })
     */
    upsert<T extends ModelImportUpsertArgs>(args: SelectSubset<T, ModelImportUpsertArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModelImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelImportCountArgs} args - Arguments to filter ModelImports to count.
     * @example
     * // Count the number of ModelImports
     * const count = await prisma.modelImport.count({
     *   where: {
     *     // ... the filter for the ModelImports we want to count
     *   }
     * })
    **/
    count<T extends ModelImportCountArgs>(
      args?: Subset<T, ModelImportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelImportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelImportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelImportAggregateArgs>(args: Subset<T, ModelImportAggregateArgs>): Prisma.PrismaPromise<GetModelImportAggregateType<T>>

    /**
     * Group by ModelImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelImportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelImportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelImportGroupByArgs['orderBy'] }
        : { orderBy?: ModelImportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelImportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelImportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelImport model
   */
  readonly fields: ModelImportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelImport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelImportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ModelImport$projectArgs<ExtArgs> = {}>(args?: Subset<T, ModelImport$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    errorLogs<T extends ModelImport$errorLogsArgs<ExtArgs> = {}>(args?: Subset<T, ModelImport$errorLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelImport model
   */ 
  interface ModelImportFieldRefs {
    readonly id: FieldRef<"ModelImport", 'String'>
    readonly userId: FieldRef<"ModelImport", 'String'>
    readonly projectId: FieldRef<"ModelImport", 'String'>
    readonly filename: FieldRef<"ModelImport", 'String'>
    readonly originalFilename: FieldRef<"ModelImport", 'String'>
    readonly fileSize: FieldRef<"ModelImport", 'Int'>
    readonly fileHash: FieldRef<"ModelImport", 'String'>
    readonly modelData: FieldRef<"ModelImport", 'Bytes'>
    readonly thumbnailData: FieldRef<"ModelImport", 'Bytes'>
    readonly status: FieldRef<"ModelImport", 'ImportStatus'>
    readonly progress: FieldRef<"ModelImport", 'Int'>
    readonly processingStartedAt: FieldRef<"ModelImport", 'DateTime'>
    readonly processingCompletedAt: FieldRef<"ModelImport", 'DateTime'>
    readonly processingDuration: FieldRef<"ModelImport", 'Int'>
    readonly vertexCount: FieldRef<"ModelImport", 'Int'>
    readonly faceCount: FieldRef<"ModelImport", 'Int'>
    readonly boundingBox: FieldRef<"ModelImport", 'Json'>
    readonly dimensions: FieldRef<"ModelImport", 'Json'>
    readonly volume: FieldRef<"ModelImport", 'Float'>
    readonly isValid: FieldRef<"ModelImport", 'Boolean'>
    readonly validationErrors: FieldRef<"ModelImport", 'Json'>
    readonly errorMessage: FieldRef<"ModelImport", 'String'>
    readonly errorCode: FieldRef<"ModelImport", 'String'>
    readonly countsTowardLimit: FieldRef<"ModelImport", 'Boolean'>
    readonly createdAt: FieldRef<"ModelImport", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelImport", 'DateTime'>
    readonly deletedAt: FieldRef<"ModelImport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelImport findUnique
   */
  export type ModelImportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * Filter, which ModelImport to fetch.
     */
    where: ModelImportWhereUniqueInput
  }

  /**
   * ModelImport findUniqueOrThrow
   */
  export type ModelImportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * Filter, which ModelImport to fetch.
     */
    where: ModelImportWhereUniqueInput
  }

  /**
   * ModelImport findFirst
   */
  export type ModelImportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * Filter, which ModelImport to fetch.
     */
    where?: ModelImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelImports to fetch.
     */
    orderBy?: ModelImportOrderByWithRelationInput | ModelImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelImports.
     */
    cursor?: ModelImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelImports.
     */
    distinct?: ModelImportScalarFieldEnum | ModelImportScalarFieldEnum[]
  }

  /**
   * ModelImport findFirstOrThrow
   */
  export type ModelImportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * Filter, which ModelImport to fetch.
     */
    where?: ModelImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelImports to fetch.
     */
    orderBy?: ModelImportOrderByWithRelationInput | ModelImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelImports.
     */
    cursor?: ModelImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelImports.
     */
    distinct?: ModelImportScalarFieldEnum | ModelImportScalarFieldEnum[]
  }

  /**
   * ModelImport findMany
   */
  export type ModelImportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * Filter, which ModelImports to fetch.
     */
    where?: ModelImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelImports to fetch.
     */
    orderBy?: ModelImportOrderByWithRelationInput | ModelImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelImports.
     */
    cursor?: ModelImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelImports.
     */
    skip?: number
    distinct?: ModelImportScalarFieldEnum | ModelImportScalarFieldEnum[]
  }

  /**
   * ModelImport create
   */
  export type ModelImportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * The data needed to create a ModelImport.
     */
    data: XOR<ModelImportCreateInput, ModelImportUncheckedCreateInput>
  }

  /**
   * ModelImport createMany
   */
  export type ModelImportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelImports.
     */
    data: ModelImportCreateManyInput | ModelImportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelImport createManyAndReturn
   */
  export type ModelImportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModelImports.
     */
    data: ModelImportCreateManyInput | ModelImportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModelImport update
   */
  export type ModelImportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * The data needed to update a ModelImport.
     */
    data: XOR<ModelImportUpdateInput, ModelImportUncheckedUpdateInput>
    /**
     * Choose, which ModelImport to update.
     */
    where: ModelImportWhereUniqueInput
  }

  /**
   * ModelImport updateMany
   */
  export type ModelImportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelImports.
     */
    data: XOR<ModelImportUpdateManyMutationInput, ModelImportUncheckedUpdateManyInput>
    /**
     * Filter which ModelImports to update
     */
    where?: ModelImportWhereInput
  }

  /**
   * ModelImport upsert
   */
  export type ModelImportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * The filter to search for the ModelImport to update in case it exists.
     */
    where: ModelImportWhereUniqueInput
    /**
     * In case the ModelImport found by the `where` argument doesn't exist, create a new ModelImport with this data.
     */
    create: XOR<ModelImportCreateInput, ModelImportUncheckedCreateInput>
    /**
     * In case the ModelImport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelImportUpdateInput, ModelImportUncheckedUpdateInput>
  }

  /**
   * ModelImport delete
   */
  export type ModelImportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    /**
     * Filter which ModelImport to delete.
     */
    where: ModelImportWhereUniqueInput
  }

  /**
   * ModelImport deleteMany
   */
  export type ModelImportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelImports to delete
     */
    where?: ModelImportWhereInput
  }

  /**
   * ModelImport.project
   */
  export type ModelImport$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * ModelImport.errorLogs
   */
  export type ModelImport$errorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    where?: ErrorLogWhereInput
    orderBy?: ErrorLogOrderByWithRelationInput | ErrorLogOrderByWithRelationInput[]
    cursor?: ErrorLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ErrorLogScalarFieldEnum | ErrorLogScalarFieldEnum[]
  }

  /**
   * ModelImport without action
   */
  export type ModelImportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    modelFileSize: number | null
    supportsCount: number | null
    clampsCount: number | null
    processingTime: number | null
  }

  export type ProjectSumAggregateOutputType = {
    modelFileSize: number | null
    supportsCount: number | null
    clampsCount: number | null
    processingTime: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    thumbnailUrl: string | null
    modelFilename: string | null
    modelFileType: string | null
    modelFileSize: number | null
    supportsCount: number | null
    clampsCount: number | null
    hasBaseplate: boolean | null
    processingTime: number | null
    status: $Enums.ProjectStatus | null
    isPublic: boolean | null
    shareToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastOpenedAt: Date | null
    completedAt: Date | null
    deletedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    thumbnailUrl: string | null
    modelFilename: string | null
    modelFileType: string | null
    modelFileSize: number | null
    supportsCount: number | null
    clampsCount: number | null
    hasBaseplate: boolean | null
    processingTime: number | null
    status: $Enums.ProjectStatus | null
    isPublic: boolean | null
    shareToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastOpenedAt: Date | null
    completedAt: Date | null
    deletedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    thumbnailUrl: number
    modelFilename: number
    modelFileType: number
    modelFileSize: number
    supportsCount: number
    clampsCount: number
    hasBaseplate: number
    processingTime: number
    toolingApplied: number
    status: number
    isPublic: number
    shareToken: number
    createdAt: number
    updatedAt: number
    lastOpenedAt: number
    completedAt: number
    deletedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    modelFileSize?: true
    supportsCount?: true
    clampsCount?: true
    processingTime?: true
  }

  export type ProjectSumAggregateInputType = {
    modelFileSize?: true
    supportsCount?: true
    clampsCount?: true
    processingTime?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    thumbnailUrl?: true
    modelFilename?: true
    modelFileType?: true
    modelFileSize?: true
    supportsCount?: true
    clampsCount?: true
    hasBaseplate?: true
    processingTime?: true
    status?: true
    isPublic?: true
    shareToken?: true
    createdAt?: true
    updatedAt?: true
    lastOpenedAt?: true
    completedAt?: true
    deletedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    thumbnailUrl?: true
    modelFilename?: true
    modelFileType?: true
    modelFileSize?: true
    supportsCount?: true
    clampsCount?: true
    hasBaseplate?: true
    processingTime?: true
    status?: true
    isPublic?: true
    shareToken?: true
    createdAt?: true
    updatedAt?: true
    lastOpenedAt?: true
    completedAt?: true
    deletedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    thumbnailUrl?: true
    modelFilename?: true
    modelFileType?: true
    modelFileSize?: true
    supportsCount?: true
    clampsCount?: true
    hasBaseplate?: true
    processingTime?: true
    toolingApplied?: true
    status?: true
    isPublic?: true
    shareToken?: true
    createdAt?: true
    updatedAt?: true
    lastOpenedAt?: true
    completedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    thumbnailUrl: string | null
    modelFilename: string | null
    modelFileType: string | null
    modelFileSize: number | null
    supportsCount: number
    clampsCount: number
    hasBaseplate: boolean
    processingTime: number | null
    toolingApplied: JsonValue | null
    status: $Enums.ProjectStatus
    isPublic: boolean
    shareToken: string | null
    createdAt: Date
    updatedAt: Date
    lastOpenedAt: Date | null
    completedAt: Date | null
    deletedAt: Date | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    modelFilename?: boolean
    modelFileType?: boolean
    modelFileSize?: boolean
    supportsCount?: boolean
    clampsCount?: boolean
    hasBaseplate?: boolean
    processingTime?: boolean
    toolingApplied?: boolean
    status?: boolean
    isPublic?: boolean
    shareToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastOpenedAt?: boolean
    completedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    modelImports?: boolean | Project$modelImportsArgs<ExtArgs>
    designVersions?: boolean | Project$designVersionsArgs<ExtArgs>
    exports?: boolean | Project$exportsArgs<ExtArgs>
    cloudBackups?: boolean | Project$cloudBackupsArgs<ExtArgs>
    sharedProjects?: boolean | Project$sharedProjectsArgs<ExtArgs>
    errorLogs?: boolean | Project$errorLogsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    modelFilename?: boolean
    modelFileType?: boolean
    modelFileSize?: boolean
    supportsCount?: boolean
    clampsCount?: boolean
    hasBaseplate?: boolean
    processingTime?: boolean
    toolingApplied?: boolean
    status?: boolean
    isPublic?: boolean
    shareToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastOpenedAt?: boolean
    completedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    modelFilename?: boolean
    modelFileType?: boolean
    modelFileSize?: boolean
    supportsCount?: boolean
    clampsCount?: boolean
    hasBaseplate?: boolean
    processingTime?: boolean
    toolingApplied?: boolean
    status?: boolean
    isPublic?: boolean
    shareToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastOpenedAt?: boolean
    completedAt?: boolean
    deletedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    modelImports?: boolean | Project$modelImportsArgs<ExtArgs>
    designVersions?: boolean | Project$designVersionsArgs<ExtArgs>
    exports?: boolean | Project$exportsArgs<ExtArgs>
    cloudBackups?: boolean | Project$cloudBackupsArgs<ExtArgs>
    sharedProjects?: boolean | Project$sharedProjectsArgs<ExtArgs>
    errorLogs?: boolean | Project$errorLogsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      modelImports: Prisma.$ModelImportPayload<ExtArgs>[]
      designVersions: Prisma.$DesignVersionPayload<ExtArgs>[]
      exports: Prisma.$ExportPayload<ExtArgs>[]
      cloudBackups: Prisma.$CloudBackupPayload<ExtArgs>[]
      sharedProjects: Prisma.$SharedProjectPayload<ExtArgs>[]
      errorLogs: Prisma.$ErrorLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      thumbnailUrl: string | null
      modelFilename: string | null
      modelFileType: string | null
      modelFileSize: number | null
      supportsCount: number
      clampsCount: number
      hasBaseplate: boolean
      processingTime: number | null
      toolingApplied: Prisma.JsonValue | null
      status: $Enums.ProjectStatus
      isPublic: boolean
      shareToken: string | null
      createdAt: Date
      updatedAt: Date
      lastOpenedAt: Date | null
      completedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    modelImports<T extends Project$modelImportsArgs<ExtArgs> = {}>(args?: Subset<T, Project$modelImportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "findMany"> | Null>
    designVersions<T extends Project$designVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$designVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findMany"> | Null>
    exports<T extends Project$exportsArgs<ExtArgs> = {}>(args?: Subset<T, Project$exportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findMany"> | Null>
    cloudBackups<T extends Project$cloudBackupsArgs<ExtArgs> = {}>(args?: Subset<T, Project$cloudBackupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "findMany"> | Null>
    sharedProjects<T extends Project$sharedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sharedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "findMany"> | Null>
    errorLogs<T extends Project$errorLogsArgs<ExtArgs> = {}>(args?: Subset<T, Project$errorLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly userId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly thumbnailUrl: FieldRef<"Project", 'String'>
    readonly modelFilename: FieldRef<"Project", 'String'>
    readonly modelFileType: FieldRef<"Project", 'String'>
    readonly modelFileSize: FieldRef<"Project", 'Int'>
    readonly supportsCount: FieldRef<"Project", 'Int'>
    readonly clampsCount: FieldRef<"Project", 'Int'>
    readonly hasBaseplate: FieldRef<"Project", 'Boolean'>
    readonly processingTime: FieldRef<"Project", 'Int'>
    readonly toolingApplied: FieldRef<"Project", 'Json'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly isPublic: FieldRef<"Project", 'Boolean'>
    readonly shareToken: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly lastOpenedAt: FieldRef<"Project", 'DateTime'>
    readonly completedAt: FieldRef<"Project", 'DateTime'>
    readonly deletedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.modelImports
   */
  export type Project$modelImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    where?: ModelImportWhereInput
    orderBy?: ModelImportOrderByWithRelationInput | ModelImportOrderByWithRelationInput[]
    cursor?: ModelImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelImportScalarFieldEnum | ModelImportScalarFieldEnum[]
  }

  /**
   * Project.designVersions
   */
  export type Project$designVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    where?: DesignVersionWhereInput
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    cursor?: DesignVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * Project.exports
   */
  export type Project$exportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    where?: ExportWhereInput
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    cursor?: ExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportScalarFieldEnum | ExportScalarFieldEnum[]
  }

  /**
   * Project.cloudBackups
   */
  export type Project$cloudBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    where?: CloudBackupWhereInput
    orderBy?: CloudBackupOrderByWithRelationInput | CloudBackupOrderByWithRelationInput[]
    cursor?: CloudBackupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CloudBackupScalarFieldEnum | CloudBackupScalarFieldEnum[]
  }

  /**
   * Project.sharedProjects
   */
  export type Project$sharedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    where?: SharedProjectWhereInput
    orderBy?: SharedProjectOrderByWithRelationInput | SharedProjectOrderByWithRelationInput[]
    cursor?: SharedProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedProjectScalarFieldEnum | SharedProjectScalarFieldEnum[]
  }

  /**
   * Project.errorLogs
   */
  export type Project$errorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    where?: ErrorLogWhereInput
    orderBy?: ErrorLogOrderByWithRelationInput | ErrorLogOrderByWithRelationInput[]
    cursor?: ErrorLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ErrorLogScalarFieldEnum | ErrorLogScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model DesignVersion
   */

  export type AggregateDesignVersion = {
    _count: DesignVersionCountAggregateOutputType | null
    _avg: DesignVersionAvgAggregateOutputType | null
    _sum: DesignVersionSumAggregateOutputType | null
    _min: DesignVersionMinAggregateOutputType | null
    _max: DesignVersionMaxAggregateOutputType | null
  }

  export type DesignVersionAvgAggregateOutputType = {
    versionNumber: number | null
    supportsCount: number | null
    clampsCount: number | null
  }

  export type DesignVersionSumAggregateOutputType = {
    versionNumber: number | null
    supportsCount: number | null
    clampsCount: number | null
  }

  export type DesignVersionMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    versionNumber: number | null
    name: string | null
    description: string | null
    thumbnailUrl: string | null
    changesSummary: string | null
    supportsCount: number | null
    clampsCount: number | null
    isAutoSave: boolean | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type DesignVersionMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    versionNumber: number | null
    name: string | null
    description: string | null
    thumbnailUrl: string | null
    changesSummary: string | null
    supportsCount: number | null
    clampsCount: number | null
    isAutoSave: boolean | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type DesignVersionCountAggregateOutputType = {
    id: number
    projectId: number
    versionNumber: number
    name: number
    description: number
    thumbnailUrl: number
    changesSummary: number
    supportsCount: number
    clampsCount: number
    isAutoSave: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type DesignVersionAvgAggregateInputType = {
    versionNumber?: true
    supportsCount?: true
    clampsCount?: true
  }

  export type DesignVersionSumAggregateInputType = {
    versionNumber?: true
    supportsCount?: true
    clampsCount?: true
  }

  export type DesignVersionMinAggregateInputType = {
    id?: true
    projectId?: true
    versionNumber?: true
    name?: true
    description?: true
    thumbnailUrl?: true
    changesSummary?: true
    supportsCount?: true
    clampsCount?: true
    isAutoSave?: true
    createdAt?: true
    createdBy?: true
  }

  export type DesignVersionMaxAggregateInputType = {
    id?: true
    projectId?: true
    versionNumber?: true
    name?: true
    description?: true
    thumbnailUrl?: true
    changesSummary?: true
    supportsCount?: true
    clampsCount?: true
    isAutoSave?: true
    createdAt?: true
    createdBy?: true
  }

  export type DesignVersionCountAggregateInputType = {
    id?: true
    projectId?: true
    versionNumber?: true
    name?: true
    description?: true
    thumbnailUrl?: true
    changesSummary?: true
    supportsCount?: true
    clampsCount?: true
    isAutoSave?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type DesignVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignVersion to aggregate.
     */
    where?: DesignVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignVersions to fetch.
     */
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DesignVersions
    **/
    _count?: true | DesignVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignVersionMaxAggregateInputType
  }

  export type GetDesignVersionAggregateType<T extends DesignVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignVersion[P]>
      : GetScalarType<T[P], AggregateDesignVersion[P]>
  }




  export type DesignVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignVersionWhereInput
    orderBy?: DesignVersionOrderByWithAggregationInput | DesignVersionOrderByWithAggregationInput[]
    by: DesignVersionScalarFieldEnum[] | DesignVersionScalarFieldEnum
    having?: DesignVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignVersionCountAggregateInputType | true
    _avg?: DesignVersionAvgAggregateInputType
    _sum?: DesignVersionSumAggregateInputType
    _min?: DesignVersionMinAggregateInputType
    _max?: DesignVersionMaxAggregateInputType
  }

  export type DesignVersionGroupByOutputType = {
    id: string
    projectId: string
    versionNumber: number
    name: string | null
    description: string | null
    thumbnailUrl: string | null
    changesSummary: string | null
    supportsCount: number
    clampsCount: number
    isAutoSave: boolean
    createdAt: Date
    createdBy: string | null
    _count: DesignVersionCountAggregateOutputType | null
    _avg: DesignVersionAvgAggregateOutputType | null
    _sum: DesignVersionSumAggregateOutputType | null
    _min: DesignVersionMinAggregateOutputType | null
    _max: DesignVersionMaxAggregateOutputType | null
  }

  type GetDesignVersionGroupByPayload<T extends DesignVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignVersionGroupByOutputType[P]>
            : GetScalarType<T[P], DesignVersionGroupByOutputType[P]>
        }
      >
    >


  export type DesignVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    versionNumber?: boolean
    name?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    changesSummary?: boolean
    supportsCount?: boolean
    clampsCount?: boolean
    isAutoSave?: boolean
    createdAt?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designVersion"]>

  export type DesignVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    versionNumber?: boolean
    name?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    changesSummary?: boolean
    supportsCount?: boolean
    clampsCount?: boolean
    isAutoSave?: boolean
    createdAt?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designVersion"]>

  export type DesignVersionSelectScalar = {
    id?: boolean
    projectId?: boolean
    versionNumber?: boolean
    name?: boolean
    description?: boolean
    thumbnailUrl?: boolean
    changesSummary?: boolean
    supportsCount?: boolean
    clampsCount?: boolean
    isAutoSave?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type DesignVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type DesignVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $DesignVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DesignVersion"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      versionNumber: number
      name: string | null
      description: string | null
      thumbnailUrl: string | null
      changesSummary: string | null
      supportsCount: number
      clampsCount: number
      isAutoSave: boolean
      createdAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["designVersion"]>
    composites: {}
  }

  type DesignVersionGetPayload<S extends boolean | null | undefined | DesignVersionDefaultArgs> = $Result.GetResult<Prisma.$DesignVersionPayload, S>

  type DesignVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DesignVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DesignVersionCountAggregateInputType | true
    }

  export interface DesignVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DesignVersion'], meta: { name: 'DesignVersion' } }
    /**
     * Find zero or one DesignVersion that matches the filter.
     * @param {DesignVersionFindUniqueArgs} args - Arguments to find a DesignVersion
     * @example
     * // Get one DesignVersion
     * const designVersion = await prisma.designVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignVersionFindUniqueArgs>(args: SelectSubset<T, DesignVersionFindUniqueArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DesignVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DesignVersionFindUniqueOrThrowArgs} args - Arguments to find a DesignVersion
     * @example
     * // Get one DesignVersion
     * const designVersion = await prisma.designVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DesignVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionFindFirstArgs} args - Arguments to find a DesignVersion
     * @example
     * // Get one DesignVersion
     * const designVersion = await prisma.designVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignVersionFindFirstArgs>(args?: SelectSubset<T, DesignVersionFindFirstArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DesignVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionFindFirstOrThrowArgs} args - Arguments to find a DesignVersion
     * @example
     * // Get one DesignVersion
     * const designVersion = await prisma.designVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DesignVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DesignVersions
     * const designVersions = await prisma.designVersion.findMany()
     * 
     * // Get first 10 DesignVersions
     * const designVersions = await prisma.designVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designVersionWithIdOnly = await prisma.designVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignVersionFindManyArgs>(args?: SelectSubset<T, DesignVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DesignVersion.
     * @param {DesignVersionCreateArgs} args - Arguments to create a DesignVersion.
     * @example
     * // Create one DesignVersion
     * const DesignVersion = await prisma.designVersion.create({
     *   data: {
     *     // ... data to create a DesignVersion
     *   }
     * })
     * 
     */
    create<T extends DesignVersionCreateArgs>(args: SelectSubset<T, DesignVersionCreateArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DesignVersions.
     * @param {DesignVersionCreateManyArgs} args - Arguments to create many DesignVersions.
     * @example
     * // Create many DesignVersions
     * const designVersion = await prisma.designVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignVersionCreateManyArgs>(args?: SelectSubset<T, DesignVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DesignVersions and returns the data saved in the database.
     * @param {DesignVersionCreateManyAndReturnArgs} args - Arguments to create many DesignVersions.
     * @example
     * // Create many DesignVersions
     * const designVersion = await prisma.designVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DesignVersions and only return the `id`
     * const designVersionWithIdOnly = await prisma.designVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DesignVersion.
     * @param {DesignVersionDeleteArgs} args - Arguments to delete one DesignVersion.
     * @example
     * // Delete one DesignVersion
     * const DesignVersion = await prisma.designVersion.delete({
     *   where: {
     *     // ... filter to delete one DesignVersion
     *   }
     * })
     * 
     */
    delete<T extends DesignVersionDeleteArgs>(args: SelectSubset<T, DesignVersionDeleteArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DesignVersion.
     * @param {DesignVersionUpdateArgs} args - Arguments to update one DesignVersion.
     * @example
     * // Update one DesignVersion
     * const designVersion = await prisma.designVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignVersionUpdateArgs>(args: SelectSubset<T, DesignVersionUpdateArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DesignVersions.
     * @param {DesignVersionDeleteManyArgs} args - Arguments to filter DesignVersions to delete.
     * @example
     * // Delete a few DesignVersions
     * const { count } = await prisma.designVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignVersionDeleteManyArgs>(args?: SelectSubset<T, DesignVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DesignVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DesignVersions
     * const designVersion = await prisma.designVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignVersionUpdateManyArgs>(args: SelectSubset<T, DesignVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DesignVersion.
     * @param {DesignVersionUpsertArgs} args - Arguments to update or create a DesignVersion.
     * @example
     * // Update or create a DesignVersion
     * const designVersion = await prisma.designVersion.upsert({
     *   create: {
     *     // ... data to create a DesignVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DesignVersion we want to update
     *   }
     * })
     */
    upsert<T extends DesignVersionUpsertArgs>(args: SelectSubset<T, DesignVersionUpsertArgs<ExtArgs>>): Prisma__DesignVersionClient<$Result.GetResult<Prisma.$DesignVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DesignVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionCountArgs} args - Arguments to filter DesignVersions to count.
     * @example
     * // Count the number of DesignVersions
     * const count = await prisma.designVersion.count({
     *   where: {
     *     // ... the filter for the DesignVersions we want to count
     *   }
     * })
    **/
    count<T extends DesignVersionCountArgs>(
      args?: Subset<T, DesignVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DesignVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignVersionAggregateArgs>(args: Subset<T, DesignVersionAggregateArgs>): Prisma.PrismaPromise<GetDesignVersionAggregateType<T>>

    /**
     * Group by DesignVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignVersionGroupByArgs['orderBy'] }
        : { orderBy?: DesignVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DesignVersion model
   */
  readonly fields: DesignVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DesignVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DesignVersion model
   */ 
  interface DesignVersionFieldRefs {
    readonly id: FieldRef<"DesignVersion", 'String'>
    readonly projectId: FieldRef<"DesignVersion", 'String'>
    readonly versionNumber: FieldRef<"DesignVersion", 'Int'>
    readonly name: FieldRef<"DesignVersion", 'String'>
    readonly description: FieldRef<"DesignVersion", 'String'>
    readonly thumbnailUrl: FieldRef<"DesignVersion", 'String'>
    readonly changesSummary: FieldRef<"DesignVersion", 'String'>
    readonly supportsCount: FieldRef<"DesignVersion", 'Int'>
    readonly clampsCount: FieldRef<"DesignVersion", 'Int'>
    readonly isAutoSave: FieldRef<"DesignVersion", 'Boolean'>
    readonly createdAt: FieldRef<"DesignVersion", 'DateTime'>
    readonly createdBy: FieldRef<"DesignVersion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DesignVersion findUnique
   */
  export type DesignVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersion to fetch.
     */
    where: DesignVersionWhereUniqueInput
  }

  /**
   * DesignVersion findUniqueOrThrow
   */
  export type DesignVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersion to fetch.
     */
    where: DesignVersionWhereUniqueInput
  }

  /**
   * DesignVersion findFirst
   */
  export type DesignVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersion to fetch.
     */
    where?: DesignVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignVersions to fetch.
     */
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignVersions.
     */
    cursor?: DesignVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignVersions.
     */
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * DesignVersion findFirstOrThrow
   */
  export type DesignVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersion to fetch.
     */
    where?: DesignVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignVersions to fetch.
     */
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DesignVersions.
     */
    cursor?: DesignVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DesignVersions.
     */
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * DesignVersion findMany
   */
  export type DesignVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter, which DesignVersions to fetch.
     */
    where?: DesignVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DesignVersions to fetch.
     */
    orderBy?: DesignVersionOrderByWithRelationInput | DesignVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DesignVersions.
     */
    cursor?: DesignVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DesignVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DesignVersions.
     */
    skip?: number
    distinct?: DesignVersionScalarFieldEnum | DesignVersionScalarFieldEnum[]
  }

  /**
   * DesignVersion create
   */
  export type DesignVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a DesignVersion.
     */
    data: XOR<DesignVersionCreateInput, DesignVersionUncheckedCreateInput>
  }

  /**
   * DesignVersion createMany
   */
  export type DesignVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DesignVersions.
     */
    data: DesignVersionCreateManyInput | DesignVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DesignVersion createManyAndReturn
   */
  export type DesignVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DesignVersions.
     */
    data: DesignVersionCreateManyInput | DesignVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DesignVersion update
   */
  export type DesignVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a DesignVersion.
     */
    data: XOR<DesignVersionUpdateInput, DesignVersionUncheckedUpdateInput>
    /**
     * Choose, which DesignVersion to update.
     */
    where: DesignVersionWhereUniqueInput
  }

  /**
   * DesignVersion updateMany
   */
  export type DesignVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DesignVersions.
     */
    data: XOR<DesignVersionUpdateManyMutationInput, DesignVersionUncheckedUpdateManyInput>
    /**
     * Filter which DesignVersions to update
     */
    where?: DesignVersionWhereInput
  }

  /**
   * DesignVersion upsert
   */
  export type DesignVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the DesignVersion to update in case it exists.
     */
    where: DesignVersionWhereUniqueInput
    /**
     * In case the DesignVersion found by the `where` argument doesn't exist, create a new DesignVersion with this data.
     */
    create: XOR<DesignVersionCreateInput, DesignVersionUncheckedCreateInput>
    /**
     * In case the DesignVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignVersionUpdateInput, DesignVersionUncheckedUpdateInput>
  }

  /**
   * DesignVersion delete
   */
  export type DesignVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
    /**
     * Filter which DesignVersion to delete.
     */
    where: DesignVersionWhereUniqueInput
  }

  /**
   * DesignVersion deleteMany
   */
  export type DesignVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DesignVersions to delete
     */
    where?: DesignVersionWhereInput
  }

  /**
   * DesignVersion without action
   */
  export type DesignVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignVersion
     */
    select?: DesignVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignVersionInclude<ExtArgs> | null
  }


  /**
   * Model Export
   */

  export type AggregateExport = {
    _count: ExportCountAggregateOutputType | null
    _avg: ExportAvgAggregateOutputType | null
    _sum: ExportSumAggregateOutputType | null
    _min: ExportMinAggregateOutputType | null
    _max: ExportMaxAggregateOutputType | null
  }

  export type ExportAvgAggregateOutputType = {
    fileSize: number | null
    processingTime: number | null
    numberOfExportsDone: number | null
    downloadCount: number | null
  }

  export type ExportSumAggregateOutputType = {
    fileSize: number | null
    processingTime: number | null
    numberOfExportsDone: number | null
    downloadCount: number | null
  }

  export type ExportMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    format: $Enums.ExportFormat | null
    filename: string | null
    fileSize: number | null
    exportData: Buffer | null
    fileUrl: string | null
    includeSupports: boolean | null
    includeClamps: boolean | null
    includeBaseplate: boolean | null
    processingTime: number | null
    status: $Enums.ExportStatus | null
    errorMessage: string | null
    numberOfExportsDone: number | null
    downloadCount: number | null
    lastDownloadedAt: Date | null
    createdAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
  }

  export type ExportMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    format: $Enums.ExportFormat | null
    filename: string | null
    fileSize: number | null
    exportData: Buffer | null
    fileUrl: string | null
    includeSupports: boolean | null
    includeClamps: boolean | null
    includeBaseplate: boolean | null
    processingTime: number | null
    status: $Enums.ExportStatus | null
    errorMessage: string | null
    numberOfExportsDone: number | null
    downloadCount: number | null
    lastDownloadedAt: Date | null
    createdAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
  }

  export type ExportCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    format: number
    filename: number
    fileSize: number
    exportData: number
    fileUrl: number
    settings: number
    includeSupports: number
    includeClamps: number
    includeBaseplate: number
    processingTime: number
    status: number
    errorMessage: number
    numberOfExportsDone: number
    downloadCount: number
    lastDownloadedAt: number
    createdAt: number
    completedAt: number
    expiresAt: number
    _all: number
  }


  export type ExportAvgAggregateInputType = {
    fileSize?: true
    processingTime?: true
    numberOfExportsDone?: true
    downloadCount?: true
  }

  export type ExportSumAggregateInputType = {
    fileSize?: true
    processingTime?: true
    numberOfExportsDone?: true
    downloadCount?: true
  }

  export type ExportMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    format?: true
    filename?: true
    fileSize?: true
    exportData?: true
    fileUrl?: true
    includeSupports?: true
    includeClamps?: true
    includeBaseplate?: true
    processingTime?: true
    status?: true
    errorMessage?: true
    numberOfExportsDone?: true
    downloadCount?: true
    lastDownloadedAt?: true
    createdAt?: true
    completedAt?: true
    expiresAt?: true
  }

  export type ExportMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    format?: true
    filename?: true
    fileSize?: true
    exportData?: true
    fileUrl?: true
    includeSupports?: true
    includeClamps?: true
    includeBaseplate?: true
    processingTime?: true
    status?: true
    errorMessage?: true
    numberOfExportsDone?: true
    downloadCount?: true
    lastDownloadedAt?: true
    createdAt?: true
    completedAt?: true
    expiresAt?: true
  }

  export type ExportCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    format?: true
    filename?: true
    fileSize?: true
    exportData?: true
    fileUrl?: true
    settings?: true
    includeSupports?: true
    includeClamps?: true
    includeBaseplate?: true
    processingTime?: true
    status?: true
    errorMessage?: true
    numberOfExportsDone?: true
    downloadCount?: true
    lastDownloadedAt?: true
    createdAt?: true
    completedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type ExportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Export to aggregate.
     */
    where?: ExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exports to fetch.
     */
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exports
    **/
    _count?: true | ExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportMaxAggregateInputType
  }

  export type GetExportAggregateType<T extends ExportAggregateArgs> = {
        [P in keyof T & keyof AggregateExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExport[P]>
      : GetScalarType<T[P], AggregateExport[P]>
  }




  export type ExportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportWhereInput
    orderBy?: ExportOrderByWithAggregationInput | ExportOrderByWithAggregationInput[]
    by: ExportScalarFieldEnum[] | ExportScalarFieldEnum
    having?: ExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportCountAggregateInputType | true
    _avg?: ExportAvgAggregateInputType
    _sum?: ExportSumAggregateInputType
    _min?: ExportMinAggregateInputType
    _max?: ExportMaxAggregateInputType
  }

  export type ExportGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    format: $Enums.ExportFormat
    filename: string
    fileSize: number | null
    exportData: Buffer | null
    fileUrl: string | null
    settings: JsonValue | null
    includeSupports: boolean
    includeClamps: boolean
    includeBaseplate: boolean
    processingTime: number | null
    status: $Enums.ExportStatus
    errorMessage: string | null
    numberOfExportsDone: number
    downloadCount: number
    lastDownloadedAt: Date | null
    createdAt: Date
    completedAt: Date | null
    expiresAt: Date | null
    _count: ExportCountAggregateOutputType | null
    _avg: ExportAvgAggregateOutputType | null
    _sum: ExportSumAggregateOutputType | null
    _min: ExportMinAggregateOutputType | null
    _max: ExportMaxAggregateOutputType | null
  }

  type GetExportGroupByPayload<T extends ExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportGroupByOutputType[P]>
            : GetScalarType<T[P], ExportGroupByOutputType[P]>
        }
      >
    >


  export type ExportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    format?: boolean
    filename?: boolean
    fileSize?: boolean
    exportData?: boolean
    fileUrl?: boolean
    settings?: boolean
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: boolean
    status?: boolean
    errorMessage?: boolean
    numberOfExportsDone?: boolean
    downloadCount?: boolean
    lastDownloadedAt?: boolean
    createdAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    errorLogs?: boolean | Export$errorLogsArgs<ExtArgs>
    _count?: boolean | ExportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["export"]>

  export type ExportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    format?: boolean
    filename?: boolean
    fileSize?: boolean
    exportData?: boolean
    fileUrl?: boolean
    settings?: boolean
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: boolean
    status?: boolean
    errorMessage?: boolean
    numberOfExportsDone?: boolean
    downloadCount?: boolean
    lastDownloadedAt?: boolean
    createdAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["export"]>

  export type ExportSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    format?: boolean
    filename?: boolean
    fileSize?: boolean
    exportData?: boolean
    fileUrl?: boolean
    settings?: boolean
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: boolean
    status?: boolean
    errorMessage?: boolean
    numberOfExportsDone?: boolean
    downloadCount?: boolean
    lastDownloadedAt?: boolean
    createdAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
  }

  export type ExportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    errorLogs?: boolean | Export$errorLogsArgs<ExtArgs>
    _count?: boolean | ExportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Export"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      errorLogs: Prisma.$ErrorLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      format: $Enums.ExportFormat
      filename: string
      fileSize: number | null
      exportData: Buffer | null
      fileUrl: string | null
      settings: Prisma.JsonValue | null
      includeSupports: boolean
      includeClamps: boolean
      includeBaseplate: boolean
      processingTime: number | null
      status: $Enums.ExportStatus
      errorMessage: string | null
      numberOfExportsDone: number
      downloadCount: number
      lastDownloadedAt: Date | null
      createdAt: Date
      completedAt: Date | null
      expiresAt: Date | null
    }, ExtArgs["result"]["export"]>
    composites: {}
  }

  type ExportGetPayload<S extends boolean | null | undefined | ExportDefaultArgs> = $Result.GetResult<Prisma.$ExportPayload, S>

  type ExportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExportCountAggregateInputType | true
    }

  export interface ExportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Export'], meta: { name: 'Export' } }
    /**
     * Find zero or one Export that matches the filter.
     * @param {ExportFindUniqueArgs} args - Arguments to find a Export
     * @example
     * // Get one Export
     * const export = await prisma.export.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportFindUniqueArgs>(args: SelectSubset<T, ExportFindUniqueArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Export that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExportFindUniqueOrThrowArgs} args - Arguments to find a Export
     * @example
     * // Get one Export
     * const export = await prisma.export.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Export that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportFindFirstArgs} args - Arguments to find a Export
     * @example
     * // Get one Export
     * const export = await prisma.export.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportFindFirstArgs>(args?: SelectSubset<T, ExportFindFirstArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Export that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportFindFirstOrThrowArgs} args - Arguments to find a Export
     * @example
     * // Get one Export
     * const export = await prisma.export.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exports
     * const exports = await prisma.export.findMany()
     * 
     * // Get first 10 Exports
     * const exports = await prisma.export.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportWithIdOnly = await prisma.export.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportFindManyArgs>(args?: SelectSubset<T, ExportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Export.
     * @param {ExportCreateArgs} args - Arguments to create a Export.
     * @example
     * // Create one Export
     * const Export = await prisma.export.create({
     *   data: {
     *     // ... data to create a Export
     *   }
     * })
     * 
     */
    create<T extends ExportCreateArgs>(args: SelectSubset<T, ExportCreateArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exports.
     * @param {ExportCreateManyArgs} args - Arguments to create many Exports.
     * @example
     * // Create many Exports
     * const export = await prisma.export.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportCreateManyArgs>(args?: SelectSubset<T, ExportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exports and returns the data saved in the database.
     * @param {ExportCreateManyAndReturnArgs} args - Arguments to create many Exports.
     * @example
     * // Create many Exports
     * const export = await prisma.export.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exports and only return the `id`
     * const exportWithIdOnly = await prisma.export.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Export.
     * @param {ExportDeleteArgs} args - Arguments to delete one Export.
     * @example
     * // Delete one Export
     * const Export = await prisma.export.delete({
     *   where: {
     *     // ... filter to delete one Export
     *   }
     * })
     * 
     */
    delete<T extends ExportDeleteArgs>(args: SelectSubset<T, ExportDeleteArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Export.
     * @param {ExportUpdateArgs} args - Arguments to update one Export.
     * @example
     * // Update one Export
     * const export = await prisma.export.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportUpdateArgs>(args: SelectSubset<T, ExportUpdateArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exports.
     * @param {ExportDeleteManyArgs} args - Arguments to filter Exports to delete.
     * @example
     * // Delete a few Exports
     * const { count } = await prisma.export.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportDeleteManyArgs>(args?: SelectSubset<T, ExportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exports
     * const export = await prisma.export.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportUpdateManyArgs>(args: SelectSubset<T, ExportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Export.
     * @param {ExportUpsertArgs} args - Arguments to update or create a Export.
     * @example
     * // Update or create a Export
     * const export = await prisma.export.upsert({
     *   create: {
     *     // ... data to create a Export
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Export we want to update
     *   }
     * })
     */
    upsert<T extends ExportUpsertArgs>(args: SelectSubset<T, ExportUpsertArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportCountArgs} args - Arguments to filter Exports to count.
     * @example
     * // Count the number of Exports
     * const count = await prisma.export.count({
     *   where: {
     *     // ... the filter for the Exports we want to count
     *   }
     * })
    **/
    count<T extends ExportCountArgs>(
      args?: Subset<T, ExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Export.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportAggregateArgs>(args: Subset<T, ExportAggregateArgs>): Prisma.PrismaPromise<GetExportAggregateType<T>>

    /**
     * Group by Export.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportGroupByArgs['orderBy'] }
        : { orderBy?: ExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Export model
   */
  readonly fields: ExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Export.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    errorLogs<T extends Export$errorLogsArgs<ExtArgs> = {}>(args?: Subset<T, Export$errorLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Export model
   */ 
  interface ExportFieldRefs {
    readonly id: FieldRef<"Export", 'String'>
    readonly projectId: FieldRef<"Export", 'String'>
    readonly userId: FieldRef<"Export", 'String'>
    readonly format: FieldRef<"Export", 'ExportFormat'>
    readonly filename: FieldRef<"Export", 'String'>
    readonly fileSize: FieldRef<"Export", 'Int'>
    readonly exportData: FieldRef<"Export", 'Bytes'>
    readonly fileUrl: FieldRef<"Export", 'String'>
    readonly settings: FieldRef<"Export", 'Json'>
    readonly includeSupports: FieldRef<"Export", 'Boolean'>
    readonly includeClamps: FieldRef<"Export", 'Boolean'>
    readonly includeBaseplate: FieldRef<"Export", 'Boolean'>
    readonly processingTime: FieldRef<"Export", 'Int'>
    readonly status: FieldRef<"Export", 'ExportStatus'>
    readonly errorMessage: FieldRef<"Export", 'String'>
    readonly numberOfExportsDone: FieldRef<"Export", 'Int'>
    readonly downloadCount: FieldRef<"Export", 'Int'>
    readonly lastDownloadedAt: FieldRef<"Export", 'DateTime'>
    readonly createdAt: FieldRef<"Export", 'DateTime'>
    readonly completedAt: FieldRef<"Export", 'DateTime'>
    readonly expiresAt: FieldRef<"Export", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Export findUnique
   */
  export type ExportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * Filter, which Export to fetch.
     */
    where: ExportWhereUniqueInput
  }

  /**
   * Export findUniqueOrThrow
   */
  export type ExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * Filter, which Export to fetch.
     */
    where: ExportWhereUniqueInput
  }

  /**
   * Export findFirst
   */
  export type ExportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * Filter, which Export to fetch.
     */
    where?: ExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exports to fetch.
     */
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exports.
     */
    cursor?: ExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exports.
     */
    distinct?: ExportScalarFieldEnum | ExportScalarFieldEnum[]
  }

  /**
   * Export findFirstOrThrow
   */
  export type ExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * Filter, which Export to fetch.
     */
    where?: ExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exports to fetch.
     */
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exports.
     */
    cursor?: ExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exports.
     */
    distinct?: ExportScalarFieldEnum | ExportScalarFieldEnum[]
  }

  /**
   * Export findMany
   */
  export type ExportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * Filter, which Exports to fetch.
     */
    where?: ExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exports to fetch.
     */
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exports.
     */
    cursor?: ExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exports.
     */
    skip?: number
    distinct?: ExportScalarFieldEnum | ExportScalarFieldEnum[]
  }

  /**
   * Export create
   */
  export type ExportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * The data needed to create a Export.
     */
    data: XOR<ExportCreateInput, ExportUncheckedCreateInput>
  }

  /**
   * Export createMany
   */
  export type ExportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exports.
     */
    data: ExportCreateManyInput | ExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Export createManyAndReturn
   */
  export type ExportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exports.
     */
    data: ExportCreateManyInput | ExportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Export update
   */
  export type ExportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * The data needed to update a Export.
     */
    data: XOR<ExportUpdateInput, ExportUncheckedUpdateInput>
    /**
     * Choose, which Export to update.
     */
    where: ExportWhereUniqueInput
  }

  /**
   * Export updateMany
   */
  export type ExportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exports.
     */
    data: XOR<ExportUpdateManyMutationInput, ExportUncheckedUpdateManyInput>
    /**
     * Filter which Exports to update
     */
    where?: ExportWhereInput
  }

  /**
   * Export upsert
   */
  export type ExportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * The filter to search for the Export to update in case it exists.
     */
    where: ExportWhereUniqueInput
    /**
     * In case the Export found by the `where` argument doesn't exist, create a new Export with this data.
     */
    create: XOR<ExportCreateInput, ExportUncheckedCreateInput>
    /**
     * In case the Export was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportUpdateInput, ExportUncheckedUpdateInput>
  }

  /**
   * Export delete
   */
  export type ExportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    /**
     * Filter which Export to delete.
     */
    where: ExportWhereUniqueInput
  }

  /**
   * Export deleteMany
   */
  export type ExportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exports to delete
     */
    where?: ExportWhereInput
  }

  /**
   * Export.errorLogs
   */
  export type Export$errorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    where?: ErrorLogWhereInput
    orderBy?: ErrorLogOrderByWithRelationInput | ErrorLogOrderByWithRelationInput[]
    cursor?: ErrorLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ErrorLogScalarFieldEnum | ErrorLogScalarFieldEnum[]
  }

  /**
   * Export without action
   */
  export type ExportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
  }


  /**
   * Model ErrorLog
   */

  export type AggregateErrorLog = {
    _count: ErrorLogCountAggregateOutputType | null
    _avg: ErrorLogAvgAggregateOutputType | null
    _sum: ErrorLogSumAggregateOutputType | null
    _min: ErrorLogMinAggregateOutputType | null
    _max: ErrorLogMaxAggregateOutputType | null
  }

  export type ErrorLogAvgAggregateOutputType = {
    statusCode: number | null
  }

  export type ErrorLogSumAggregateOutputType = {
    statusCode: number | null
  }

  export type ErrorLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    modelImportId: string | null
    exportId: string | null
    category: $Enums.ErrorCategory | null
    severity: $Enums.ErrorSeverity | null
    errorCode: string | null
    errorMessage: string | null
    errorStack: string | null
    operation: string | null
    step: string | null
    url: string | null
    method: string | null
    statusCode: number | null
    userAction: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolution: string | null
    createdAt: Date | null
  }

  export type ErrorLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    modelImportId: string | null
    exportId: string | null
    category: $Enums.ErrorCategory | null
    severity: $Enums.ErrorSeverity | null
    errorCode: string | null
    errorMessage: string | null
    errorStack: string | null
    operation: string | null
    step: string | null
    url: string | null
    method: string | null
    statusCode: number | null
    userAction: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolution: string | null
    createdAt: Date | null
  }

  export type ErrorLogCountAggregateOutputType = {
    id: number
    userId: number
    projectId: number
    modelImportId: number
    exportId: number
    category: number
    severity: number
    errorCode: number
    errorMessage: number
    errorStack: number
    operation: number
    step: number
    browserInfo: number
    deviceInfo: number
    url: number
    method: number
    statusCode: number
    userAction: number
    resolved: number
    resolvedAt: number
    resolution: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ErrorLogAvgAggregateInputType = {
    statusCode?: true
  }

  export type ErrorLogSumAggregateInputType = {
    statusCode?: true
  }

  export type ErrorLogMinAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    modelImportId?: true
    exportId?: true
    category?: true
    severity?: true
    errorCode?: true
    errorMessage?: true
    errorStack?: true
    operation?: true
    step?: true
    url?: true
    method?: true
    statusCode?: true
    userAction?: true
    resolved?: true
    resolvedAt?: true
    resolution?: true
    createdAt?: true
  }

  export type ErrorLogMaxAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    modelImportId?: true
    exportId?: true
    category?: true
    severity?: true
    errorCode?: true
    errorMessage?: true
    errorStack?: true
    operation?: true
    step?: true
    url?: true
    method?: true
    statusCode?: true
    userAction?: true
    resolved?: true
    resolvedAt?: true
    resolution?: true
    createdAt?: true
  }

  export type ErrorLogCountAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    modelImportId?: true
    exportId?: true
    category?: true
    severity?: true
    errorCode?: true
    errorMessage?: true
    errorStack?: true
    operation?: true
    step?: true
    browserInfo?: true
    deviceInfo?: true
    url?: true
    method?: true
    statusCode?: true
    userAction?: true
    resolved?: true
    resolvedAt?: true
    resolution?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ErrorLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ErrorLog to aggregate.
     */
    where?: ErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorLogs to fetch.
     */
    orderBy?: ErrorLogOrderByWithRelationInput | ErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ErrorLogs
    **/
    _count?: true | ErrorLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ErrorLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ErrorLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ErrorLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ErrorLogMaxAggregateInputType
  }

  export type GetErrorLogAggregateType<T extends ErrorLogAggregateArgs> = {
        [P in keyof T & keyof AggregateErrorLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateErrorLog[P]>
      : GetScalarType<T[P], AggregateErrorLog[P]>
  }




  export type ErrorLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorLogWhereInput
    orderBy?: ErrorLogOrderByWithAggregationInput | ErrorLogOrderByWithAggregationInput[]
    by: ErrorLogScalarFieldEnum[] | ErrorLogScalarFieldEnum
    having?: ErrorLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ErrorLogCountAggregateInputType | true
    _avg?: ErrorLogAvgAggregateInputType
    _sum?: ErrorLogSumAggregateInputType
    _min?: ErrorLogMinAggregateInputType
    _max?: ErrorLogMaxAggregateInputType
  }

  export type ErrorLogGroupByOutputType = {
    id: string
    userId: string | null
    projectId: string | null
    modelImportId: string | null
    exportId: string | null
    category: $Enums.ErrorCategory
    severity: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack: string | null
    operation: string
    step: string | null
    browserInfo: JsonValue | null
    deviceInfo: JsonValue | null
    url: string | null
    method: string | null
    statusCode: number | null
    userAction: string | null
    resolved: boolean
    resolvedAt: Date | null
    resolution: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: ErrorLogCountAggregateOutputType | null
    _avg: ErrorLogAvgAggregateOutputType | null
    _sum: ErrorLogSumAggregateOutputType | null
    _min: ErrorLogMinAggregateOutputType | null
    _max: ErrorLogMaxAggregateOutputType | null
  }

  type GetErrorLogGroupByPayload<T extends ErrorLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ErrorLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ErrorLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ErrorLogGroupByOutputType[P]>
            : GetScalarType<T[P], ErrorLogGroupByOutputType[P]>
        }
      >
    >


  export type ErrorLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    modelImportId?: boolean
    exportId?: boolean
    category?: boolean
    severity?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    operation?: boolean
    step?: boolean
    browserInfo?: boolean
    deviceInfo?: boolean
    url?: boolean
    method?: boolean
    statusCode?: boolean
    userAction?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolution?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | ErrorLog$userArgs<ExtArgs>
    project?: boolean | ErrorLog$projectArgs<ExtArgs>
    modelImport?: boolean | ErrorLog$modelImportArgs<ExtArgs>
    export?: boolean | ErrorLog$exportArgs<ExtArgs>
  }, ExtArgs["result"]["errorLog"]>

  export type ErrorLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    modelImportId?: boolean
    exportId?: boolean
    category?: boolean
    severity?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    operation?: boolean
    step?: boolean
    browserInfo?: boolean
    deviceInfo?: boolean
    url?: boolean
    method?: boolean
    statusCode?: boolean
    userAction?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolution?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | ErrorLog$userArgs<ExtArgs>
    project?: boolean | ErrorLog$projectArgs<ExtArgs>
    modelImport?: boolean | ErrorLog$modelImportArgs<ExtArgs>
    export?: boolean | ErrorLog$exportArgs<ExtArgs>
  }, ExtArgs["result"]["errorLog"]>

  export type ErrorLogSelectScalar = {
    id?: boolean
    userId?: boolean
    projectId?: boolean
    modelImportId?: boolean
    exportId?: boolean
    category?: boolean
    severity?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    operation?: boolean
    step?: boolean
    browserInfo?: boolean
    deviceInfo?: boolean
    url?: boolean
    method?: boolean
    statusCode?: boolean
    userAction?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolution?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ErrorLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ErrorLog$userArgs<ExtArgs>
    project?: boolean | ErrorLog$projectArgs<ExtArgs>
    modelImport?: boolean | ErrorLog$modelImportArgs<ExtArgs>
    export?: boolean | ErrorLog$exportArgs<ExtArgs>
  }
  export type ErrorLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ErrorLog$userArgs<ExtArgs>
    project?: boolean | ErrorLog$projectArgs<ExtArgs>
    modelImport?: boolean | ErrorLog$modelImportArgs<ExtArgs>
    export?: boolean | ErrorLog$exportArgs<ExtArgs>
  }

  export type $ErrorLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ErrorLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      modelImport: Prisma.$ModelImportPayload<ExtArgs> | null
      export: Prisma.$ExportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      projectId: string | null
      modelImportId: string | null
      exportId: string | null
      category: $Enums.ErrorCategory
      severity: $Enums.ErrorSeverity
      errorCode: string
      errorMessage: string
      errorStack: string | null
      operation: string
      step: string | null
      browserInfo: Prisma.JsonValue | null
      deviceInfo: Prisma.JsonValue | null
      url: string | null
      method: string | null
      statusCode: number | null
      userAction: string | null
      resolved: boolean
      resolvedAt: Date | null
      resolution: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["errorLog"]>
    composites: {}
  }

  type ErrorLogGetPayload<S extends boolean | null | undefined | ErrorLogDefaultArgs> = $Result.GetResult<Prisma.$ErrorLogPayload, S>

  type ErrorLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ErrorLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ErrorLogCountAggregateInputType | true
    }

  export interface ErrorLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ErrorLog'], meta: { name: 'ErrorLog' } }
    /**
     * Find zero or one ErrorLog that matches the filter.
     * @param {ErrorLogFindUniqueArgs} args - Arguments to find a ErrorLog
     * @example
     * // Get one ErrorLog
     * const errorLog = await prisma.errorLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ErrorLogFindUniqueArgs>(args: SelectSubset<T, ErrorLogFindUniqueArgs<ExtArgs>>): Prisma__ErrorLogClient<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ErrorLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ErrorLogFindUniqueOrThrowArgs} args - Arguments to find a ErrorLog
     * @example
     * // Get one ErrorLog
     * const errorLog = await prisma.errorLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ErrorLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ErrorLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ErrorLogClient<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ErrorLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorLogFindFirstArgs} args - Arguments to find a ErrorLog
     * @example
     * // Get one ErrorLog
     * const errorLog = await prisma.errorLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ErrorLogFindFirstArgs>(args?: SelectSubset<T, ErrorLogFindFirstArgs<ExtArgs>>): Prisma__ErrorLogClient<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ErrorLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorLogFindFirstOrThrowArgs} args - Arguments to find a ErrorLog
     * @example
     * // Get one ErrorLog
     * const errorLog = await prisma.errorLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ErrorLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ErrorLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ErrorLogClient<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ErrorLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ErrorLogs
     * const errorLogs = await prisma.errorLog.findMany()
     * 
     * // Get first 10 ErrorLogs
     * const errorLogs = await prisma.errorLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const errorLogWithIdOnly = await prisma.errorLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ErrorLogFindManyArgs>(args?: SelectSubset<T, ErrorLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ErrorLog.
     * @param {ErrorLogCreateArgs} args - Arguments to create a ErrorLog.
     * @example
     * // Create one ErrorLog
     * const ErrorLog = await prisma.errorLog.create({
     *   data: {
     *     // ... data to create a ErrorLog
     *   }
     * })
     * 
     */
    create<T extends ErrorLogCreateArgs>(args: SelectSubset<T, ErrorLogCreateArgs<ExtArgs>>): Prisma__ErrorLogClient<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ErrorLogs.
     * @param {ErrorLogCreateManyArgs} args - Arguments to create many ErrorLogs.
     * @example
     * // Create many ErrorLogs
     * const errorLog = await prisma.errorLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ErrorLogCreateManyArgs>(args?: SelectSubset<T, ErrorLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ErrorLogs and returns the data saved in the database.
     * @param {ErrorLogCreateManyAndReturnArgs} args - Arguments to create many ErrorLogs.
     * @example
     * // Create many ErrorLogs
     * const errorLog = await prisma.errorLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ErrorLogs and only return the `id`
     * const errorLogWithIdOnly = await prisma.errorLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ErrorLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ErrorLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ErrorLog.
     * @param {ErrorLogDeleteArgs} args - Arguments to delete one ErrorLog.
     * @example
     * // Delete one ErrorLog
     * const ErrorLog = await prisma.errorLog.delete({
     *   where: {
     *     // ... filter to delete one ErrorLog
     *   }
     * })
     * 
     */
    delete<T extends ErrorLogDeleteArgs>(args: SelectSubset<T, ErrorLogDeleteArgs<ExtArgs>>): Prisma__ErrorLogClient<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ErrorLog.
     * @param {ErrorLogUpdateArgs} args - Arguments to update one ErrorLog.
     * @example
     * // Update one ErrorLog
     * const errorLog = await prisma.errorLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ErrorLogUpdateArgs>(args: SelectSubset<T, ErrorLogUpdateArgs<ExtArgs>>): Prisma__ErrorLogClient<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ErrorLogs.
     * @param {ErrorLogDeleteManyArgs} args - Arguments to filter ErrorLogs to delete.
     * @example
     * // Delete a few ErrorLogs
     * const { count } = await prisma.errorLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ErrorLogDeleteManyArgs>(args?: SelectSubset<T, ErrorLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ErrorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ErrorLogs
     * const errorLog = await prisma.errorLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ErrorLogUpdateManyArgs>(args: SelectSubset<T, ErrorLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ErrorLog.
     * @param {ErrorLogUpsertArgs} args - Arguments to update or create a ErrorLog.
     * @example
     * // Update or create a ErrorLog
     * const errorLog = await prisma.errorLog.upsert({
     *   create: {
     *     // ... data to create a ErrorLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ErrorLog we want to update
     *   }
     * })
     */
    upsert<T extends ErrorLogUpsertArgs>(args: SelectSubset<T, ErrorLogUpsertArgs<ExtArgs>>): Prisma__ErrorLogClient<$Result.GetResult<Prisma.$ErrorLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ErrorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorLogCountArgs} args - Arguments to filter ErrorLogs to count.
     * @example
     * // Count the number of ErrorLogs
     * const count = await prisma.errorLog.count({
     *   where: {
     *     // ... the filter for the ErrorLogs we want to count
     *   }
     * })
    **/
    count<T extends ErrorLogCountArgs>(
      args?: Subset<T, ErrorLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ErrorLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ErrorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ErrorLogAggregateArgs>(args: Subset<T, ErrorLogAggregateArgs>): Prisma.PrismaPromise<GetErrorLogAggregateType<T>>

    /**
     * Group by ErrorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ErrorLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ErrorLogGroupByArgs['orderBy'] }
        : { orderBy?: ErrorLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ErrorLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErrorLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ErrorLog model
   */
  readonly fields: ErrorLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ErrorLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ErrorLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ErrorLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ErrorLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ErrorLog$projectArgs<ExtArgs> = {}>(args?: Subset<T, ErrorLog$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    modelImport<T extends ErrorLog$modelImportArgs<ExtArgs> = {}>(args?: Subset<T, ErrorLog$modelImportArgs<ExtArgs>>): Prisma__ModelImportClient<$Result.GetResult<Prisma.$ModelImportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    export<T extends ErrorLog$exportArgs<ExtArgs> = {}>(args?: Subset<T, ErrorLog$exportArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ErrorLog model
   */ 
  interface ErrorLogFieldRefs {
    readonly id: FieldRef<"ErrorLog", 'String'>
    readonly userId: FieldRef<"ErrorLog", 'String'>
    readonly projectId: FieldRef<"ErrorLog", 'String'>
    readonly modelImportId: FieldRef<"ErrorLog", 'String'>
    readonly exportId: FieldRef<"ErrorLog", 'String'>
    readonly category: FieldRef<"ErrorLog", 'ErrorCategory'>
    readonly severity: FieldRef<"ErrorLog", 'ErrorSeverity'>
    readonly errorCode: FieldRef<"ErrorLog", 'String'>
    readonly errorMessage: FieldRef<"ErrorLog", 'String'>
    readonly errorStack: FieldRef<"ErrorLog", 'String'>
    readonly operation: FieldRef<"ErrorLog", 'String'>
    readonly step: FieldRef<"ErrorLog", 'String'>
    readonly browserInfo: FieldRef<"ErrorLog", 'Json'>
    readonly deviceInfo: FieldRef<"ErrorLog", 'Json'>
    readonly url: FieldRef<"ErrorLog", 'String'>
    readonly method: FieldRef<"ErrorLog", 'String'>
    readonly statusCode: FieldRef<"ErrorLog", 'Int'>
    readonly userAction: FieldRef<"ErrorLog", 'String'>
    readonly resolved: FieldRef<"ErrorLog", 'Boolean'>
    readonly resolvedAt: FieldRef<"ErrorLog", 'DateTime'>
    readonly resolution: FieldRef<"ErrorLog", 'String'>
    readonly metadata: FieldRef<"ErrorLog", 'Json'>
    readonly createdAt: FieldRef<"ErrorLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ErrorLog findUnique
   */
  export type ErrorLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which ErrorLog to fetch.
     */
    where: ErrorLogWhereUniqueInput
  }

  /**
   * ErrorLog findUniqueOrThrow
   */
  export type ErrorLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which ErrorLog to fetch.
     */
    where: ErrorLogWhereUniqueInput
  }

  /**
   * ErrorLog findFirst
   */
  export type ErrorLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which ErrorLog to fetch.
     */
    where?: ErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorLogs to fetch.
     */
    orderBy?: ErrorLogOrderByWithRelationInput | ErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ErrorLogs.
     */
    cursor?: ErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ErrorLogs.
     */
    distinct?: ErrorLogScalarFieldEnum | ErrorLogScalarFieldEnum[]
  }

  /**
   * ErrorLog findFirstOrThrow
   */
  export type ErrorLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which ErrorLog to fetch.
     */
    where?: ErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorLogs to fetch.
     */
    orderBy?: ErrorLogOrderByWithRelationInput | ErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ErrorLogs.
     */
    cursor?: ErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ErrorLogs.
     */
    distinct?: ErrorLogScalarFieldEnum | ErrorLogScalarFieldEnum[]
  }

  /**
   * ErrorLog findMany
   */
  export type ErrorLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which ErrorLogs to fetch.
     */
    where?: ErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorLogs to fetch.
     */
    orderBy?: ErrorLogOrderByWithRelationInput | ErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ErrorLogs.
     */
    cursor?: ErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorLogs.
     */
    skip?: number
    distinct?: ErrorLogScalarFieldEnum | ErrorLogScalarFieldEnum[]
  }

  /**
   * ErrorLog create
   */
  export type ErrorLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ErrorLog.
     */
    data: XOR<ErrorLogCreateInput, ErrorLogUncheckedCreateInput>
  }

  /**
   * ErrorLog createMany
   */
  export type ErrorLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ErrorLogs.
     */
    data: ErrorLogCreateManyInput | ErrorLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ErrorLog createManyAndReturn
   */
  export type ErrorLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ErrorLogs.
     */
    data: ErrorLogCreateManyInput | ErrorLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ErrorLog update
   */
  export type ErrorLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ErrorLog.
     */
    data: XOR<ErrorLogUpdateInput, ErrorLogUncheckedUpdateInput>
    /**
     * Choose, which ErrorLog to update.
     */
    where: ErrorLogWhereUniqueInput
  }

  /**
   * ErrorLog updateMany
   */
  export type ErrorLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ErrorLogs.
     */
    data: XOR<ErrorLogUpdateManyMutationInput, ErrorLogUncheckedUpdateManyInput>
    /**
     * Filter which ErrorLogs to update
     */
    where?: ErrorLogWhereInput
  }

  /**
   * ErrorLog upsert
   */
  export type ErrorLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ErrorLog to update in case it exists.
     */
    where: ErrorLogWhereUniqueInput
    /**
     * In case the ErrorLog found by the `where` argument doesn't exist, create a new ErrorLog with this data.
     */
    create: XOR<ErrorLogCreateInput, ErrorLogUncheckedCreateInput>
    /**
     * In case the ErrorLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ErrorLogUpdateInput, ErrorLogUncheckedUpdateInput>
  }

  /**
   * ErrorLog delete
   */
  export type ErrorLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
    /**
     * Filter which ErrorLog to delete.
     */
    where: ErrorLogWhereUniqueInput
  }

  /**
   * ErrorLog deleteMany
   */
  export type ErrorLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ErrorLogs to delete
     */
    where?: ErrorLogWhereInput
  }

  /**
   * ErrorLog.user
   */
  export type ErrorLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ErrorLog.project
   */
  export type ErrorLog$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * ErrorLog.modelImport
   */
  export type ErrorLog$modelImportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelImport
     */
    select?: ModelImportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelImportInclude<ExtArgs> | null
    where?: ModelImportWhereInput
  }

  /**
   * ErrorLog.export
   */
  export type ErrorLog$exportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportInclude<ExtArgs> | null
    where?: ExportWhereInput
  }

  /**
   * ErrorLog without action
   */
  export type ErrorLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorLog
     */
    select?: ErrorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ErrorLogInclude<ExtArgs> | null
  }


  /**
   * Model SharedProject
   */

  export type AggregateSharedProject = {
    _count: SharedProjectCountAggregateOutputType | null
    _min: SharedProjectMinAggregateOutputType | null
    _max: SharedProjectMaxAggregateOutputType | null
  }

  export type SharedProjectMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    sharedBy: string | null
    sharedWith: string | null
    permission: string | null
    shareType: string | null
    shareToken: string | null
    accepted: boolean | null
    revoked: boolean | null
    createdAt: Date | null
    acceptedAt: Date | null
    revokedAt: Date | null
    expiresAt: Date | null
  }

  export type SharedProjectMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    sharedBy: string | null
    sharedWith: string | null
    permission: string | null
    shareType: string | null
    shareToken: string | null
    accepted: boolean | null
    revoked: boolean | null
    createdAt: Date | null
    acceptedAt: Date | null
    revokedAt: Date | null
    expiresAt: Date | null
  }

  export type SharedProjectCountAggregateOutputType = {
    id: number
    projectId: number
    sharedBy: number
    sharedWith: number
    permission: number
    shareType: number
    shareToken: number
    accepted: number
    revoked: number
    createdAt: number
    acceptedAt: number
    revokedAt: number
    expiresAt: number
    _all: number
  }


  export type SharedProjectMinAggregateInputType = {
    id?: true
    projectId?: true
    sharedBy?: true
    sharedWith?: true
    permission?: true
    shareType?: true
    shareToken?: true
    accepted?: true
    revoked?: true
    createdAt?: true
    acceptedAt?: true
    revokedAt?: true
    expiresAt?: true
  }

  export type SharedProjectMaxAggregateInputType = {
    id?: true
    projectId?: true
    sharedBy?: true
    sharedWith?: true
    permission?: true
    shareType?: true
    shareToken?: true
    accepted?: true
    revoked?: true
    createdAt?: true
    acceptedAt?: true
    revokedAt?: true
    expiresAt?: true
  }

  export type SharedProjectCountAggregateInputType = {
    id?: true
    projectId?: true
    sharedBy?: true
    sharedWith?: true
    permission?: true
    shareType?: true
    shareToken?: true
    accepted?: true
    revoked?: true
    createdAt?: true
    acceptedAt?: true
    revokedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type SharedProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedProject to aggregate.
     */
    where?: SharedProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedProjects to fetch.
     */
    orderBy?: SharedProjectOrderByWithRelationInput | SharedProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedProjects
    **/
    _count?: true | SharedProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedProjectMaxAggregateInputType
  }

  export type GetSharedProjectAggregateType<T extends SharedProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedProject[P]>
      : GetScalarType<T[P], AggregateSharedProject[P]>
  }




  export type SharedProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedProjectWhereInput
    orderBy?: SharedProjectOrderByWithAggregationInput | SharedProjectOrderByWithAggregationInput[]
    by: SharedProjectScalarFieldEnum[] | SharedProjectScalarFieldEnum
    having?: SharedProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedProjectCountAggregateInputType | true
    _min?: SharedProjectMinAggregateInputType
    _max?: SharedProjectMaxAggregateInputType
  }

  export type SharedProjectGroupByOutputType = {
    id: string
    projectId: string
    sharedBy: string
    sharedWith: string | null
    permission: string
    shareType: string
    shareToken: string | null
    accepted: boolean
    revoked: boolean
    createdAt: Date
    acceptedAt: Date | null
    revokedAt: Date | null
    expiresAt: Date | null
    _count: SharedProjectCountAggregateOutputType | null
    _min: SharedProjectMinAggregateOutputType | null
    _max: SharedProjectMaxAggregateOutputType | null
  }

  type GetSharedProjectGroupByPayload<T extends SharedProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedProjectGroupByOutputType[P]>
            : GetScalarType<T[P], SharedProjectGroupByOutputType[P]>
        }
      >
    >


  export type SharedProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permission?: boolean
    shareType?: boolean
    shareToken?: boolean
    accepted?: boolean
    revoked?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sharedByUser?: boolean | UserDefaultArgs<ExtArgs>
    sharedWithUser?: boolean | SharedProject$sharedWithUserArgs<ExtArgs>
  }, ExtArgs["result"]["sharedProject"]>

  export type SharedProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permission?: boolean
    shareType?: boolean
    shareToken?: boolean
    accepted?: boolean
    revoked?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sharedByUser?: boolean | UserDefaultArgs<ExtArgs>
    sharedWithUser?: boolean | SharedProject$sharedWithUserArgs<ExtArgs>
  }, ExtArgs["result"]["sharedProject"]>

  export type SharedProjectSelectScalar = {
    id?: boolean
    projectId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permission?: boolean
    shareType?: boolean
    shareToken?: boolean
    accepted?: boolean
    revoked?: boolean
    createdAt?: boolean
    acceptedAt?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
  }

  export type SharedProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sharedByUser?: boolean | UserDefaultArgs<ExtArgs>
    sharedWithUser?: boolean | SharedProject$sharedWithUserArgs<ExtArgs>
  }
  export type SharedProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sharedByUser?: boolean | UserDefaultArgs<ExtArgs>
    sharedWithUser?: boolean | SharedProject$sharedWithUserArgs<ExtArgs>
  }

  export type $SharedProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedProject"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      sharedByUser: Prisma.$UserPayload<ExtArgs>
      sharedWithUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      sharedBy: string
      sharedWith: string | null
      permission: string
      shareType: string
      shareToken: string | null
      accepted: boolean
      revoked: boolean
      createdAt: Date
      acceptedAt: Date | null
      revokedAt: Date | null
      expiresAt: Date | null
    }, ExtArgs["result"]["sharedProject"]>
    composites: {}
  }

  type SharedProjectGetPayload<S extends boolean | null | undefined | SharedProjectDefaultArgs> = $Result.GetResult<Prisma.$SharedProjectPayload, S>

  type SharedProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SharedProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SharedProjectCountAggregateInputType | true
    }

  export interface SharedProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedProject'], meta: { name: 'SharedProject' } }
    /**
     * Find zero or one SharedProject that matches the filter.
     * @param {SharedProjectFindUniqueArgs} args - Arguments to find a SharedProject
     * @example
     * // Get one SharedProject
     * const sharedProject = await prisma.sharedProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedProjectFindUniqueArgs>(args: SelectSubset<T, SharedProjectFindUniqueArgs<ExtArgs>>): Prisma__SharedProjectClient<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SharedProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SharedProjectFindUniqueOrThrowArgs} args - Arguments to find a SharedProject
     * @example
     * // Get one SharedProject
     * const sharedProject = await prisma.sharedProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedProjectClient<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SharedProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProjectFindFirstArgs} args - Arguments to find a SharedProject
     * @example
     * // Get one SharedProject
     * const sharedProject = await prisma.sharedProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedProjectFindFirstArgs>(args?: SelectSubset<T, SharedProjectFindFirstArgs<ExtArgs>>): Prisma__SharedProjectClient<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SharedProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProjectFindFirstOrThrowArgs} args - Arguments to find a SharedProject
     * @example
     * // Get one SharedProject
     * const sharedProject = await prisma.sharedProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedProjectClient<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SharedProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedProjects
     * const sharedProjects = await prisma.sharedProject.findMany()
     * 
     * // Get first 10 SharedProjects
     * const sharedProjects = await prisma.sharedProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedProjectWithIdOnly = await prisma.sharedProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedProjectFindManyArgs>(args?: SelectSubset<T, SharedProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SharedProject.
     * @param {SharedProjectCreateArgs} args - Arguments to create a SharedProject.
     * @example
     * // Create one SharedProject
     * const SharedProject = await prisma.sharedProject.create({
     *   data: {
     *     // ... data to create a SharedProject
     *   }
     * })
     * 
     */
    create<T extends SharedProjectCreateArgs>(args: SelectSubset<T, SharedProjectCreateArgs<ExtArgs>>): Prisma__SharedProjectClient<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SharedProjects.
     * @param {SharedProjectCreateManyArgs} args - Arguments to create many SharedProjects.
     * @example
     * // Create many SharedProjects
     * const sharedProject = await prisma.sharedProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedProjectCreateManyArgs>(args?: SelectSubset<T, SharedProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedProjects and returns the data saved in the database.
     * @param {SharedProjectCreateManyAndReturnArgs} args - Arguments to create many SharedProjects.
     * @example
     * // Create many SharedProjects
     * const sharedProject = await prisma.sharedProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedProjects and only return the `id`
     * const sharedProjectWithIdOnly = await prisma.sharedProject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SharedProject.
     * @param {SharedProjectDeleteArgs} args - Arguments to delete one SharedProject.
     * @example
     * // Delete one SharedProject
     * const SharedProject = await prisma.sharedProject.delete({
     *   where: {
     *     // ... filter to delete one SharedProject
     *   }
     * })
     * 
     */
    delete<T extends SharedProjectDeleteArgs>(args: SelectSubset<T, SharedProjectDeleteArgs<ExtArgs>>): Prisma__SharedProjectClient<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SharedProject.
     * @param {SharedProjectUpdateArgs} args - Arguments to update one SharedProject.
     * @example
     * // Update one SharedProject
     * const sharedProject = await prisma.sharedProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedProjectUpdateArgs>(args: SelectSubset<T, SharedProjectUpdateArgs<ExtArgs>>): Prisma__SharedProjectClient<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SharedProjects.
     * @param {SharedProjectDeleteManyArgs} args - Arguments to filter SharedProjects to delete.
     * @example
     * // Delete a few SharedProjects
     * const { count } = await prisma.sharedProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedProjectDeleteManyArgs>(args?: SelectSubset<T, SharedProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedProjects
     * const sharedProject = await prisma.sharedProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedProjectUpdateManyArgs>(args: SelectSubset<T, SharedProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SharedProject.
     * @param {SharedProjectUpsertArgs} args - Arguments to update or create a SharedProject.
     * @example
     * // Update or create a SharedProject
     * const sharedProject = await prisma.sharedProject.upsert({
     *   create: {
     *     // ... data to create a SharedProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedProject we want to update
     *   }
     * })
     */
    upsert<T extends SharedProjectUpsertArgs>(args: SelectSubset<T, SharedProjectUpsertArgs<ExtArgs>>): Prisma__SharedProjectClient<$Result.GetResult<Prisma.$SharedProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SharedProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProjectCountArgs} args - Arguments to filter SharedProjects to count.
     * @example
     * // Count the number of SharedProjects
     * const count = await prisma.sharedProject.count({
     *   where: {
     *     // ... the filter for the SharedProjects we want to count
     *   }
     * })
    **/
    count<T extends SharedProjectCountArgs>(
      args?: Subset<T, SharedProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedProjectAggregateArgs>(args: Subset<T, SharedProjectAggregateArgs>): Prisma.PrismaPromise<GetSharedProjectAggregateType<T>>

    /**
     * Group by SharedProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedProjectGroupByArgs['orderBy'] }
        : { orderBy?: SharedProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedProject model
   */
  readonly fields: SharedProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sharedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sharedWithUser<T extends SharedProject$sharedWithUserArgs<ExtArgs> = {}>(args?: Subset<T, SharedProject$sharedWithUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedProject model
   */ 
  interface SharedProjectFieldRefs {
    readonly id: FieldRef<"SharedProject", 'String'>
    readonly projectId: FieldRef<"SharedProject", 'String'>
    readonly sharedBy: FieldRef<"SharedProject", 'String'>
    readonly sharedWith: FieldRef<"SharedProject", 'String'>
    readonly permission: FieldRef<"SharedProject", 'String'>
    readonly shareType: FieldRef<"SharedProject", 'String'>
    readonly shareToken: FieldRef<"SharedProject", 'String'>
    readonly accepted: FieldRef<"SharedProject", 'Boolean'>
    readonly revoked: FieldRef<"SharedProject", 'Boolean'>
    readonly createdAt: FieldRef<"SharedProject", 'DateTime'>
    readonly acceptedAt: FieldRef<"SharedProject", 'DateTime'>
    readonly revokedAt: FieldRef<"SharedProject", 'DateTime'>
    readonly expiresAt: FieldRef<"SharedProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharedProject findUnique
   */
  export type SharedProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * Filter, which SharedProject to fetch.
     */
    where: SharedProjectWhereUniqueInput
  }

  /**
   * SharedProject findUniqueOrThrow
   */
  export type SharedProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * Filter, which SharedProject to fetch.
     */
    where: SharedProjectWhereUniqueInput
  }

  /**
   * SharedProject findFirst
   */
  export type SharedProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * Filter, which SharedProject to fetch.
     */
    where?: SharedProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedProjects to fetch.
     */
    orderBy?: SharedProjectOrderByWithRelationInput | SharedProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedProjects.
     */
    cursor?: SharedProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedProjects.
     */
    distinct?: SharedProjectScalarFieldEnum | SharedProjectScalarFieldEnum[]
  }

  /**
   * SharedProject findFirstOrThrow
   */
  export type SharedProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * Filter, which SharedProject to fetch.
     */
    where?: SharedProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedProjects to fetch.
     */
    orderBy?: SharedProjectOrderByWithRelationInput | SharedProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedProjects.
     */
    cursor?: SharedProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedProjects.
     */
    distinct?: SharedProjectScalarFieldEnum | SharedProjectScalarFieldEnum[]
  }

  /**
   * SharedProject findMany
   */
  export type SharedProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * Filter, which SharedProjects to fetch.
     */
    where?: SharedProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedProjects to fetch.
     */
    orderBy?: SharedProjectOrderByWithRelationInput | SharedProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedProjects.
     */
    cursor?: SharedProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedProjects.
     */
    skip?: number
    distinct?: SharedProjectScalarFieldEnum | SharedProjectScalarFieldEnum[]
  }

  /**
   * SharedProject create
   */
  export type SharedProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a SharedProject.
     */
    data: XOR<SharedProjectCreateInput, SharedProjectUncheckedCreateInput>
  }

  /**
   * SharedProject createMany
   */
  export type SharedProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedProjects.
     */
    data: SharedProjectCreateManyInput | SharedProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedProject createManyAndReturn
   */
  export type SharedProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SharedProjects.
     */
    data: SharedProjectCreateManyInput | SharedProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedProject update
   */
  export type SharedProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a SharedProject.
     */
    data: XOR<SharedProjectUpdateInput, SharedProjectUncheckedUpdateInput>
    /**
     * Choose, which SharedProject to update.
     */
    where: SharedProjectWhereUniqueInput
  }

  /**
   * SharedProject updateMany
   */
  export type SharedProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedProjects.
     */
    data: XOR<SharedProjectUpdateManyMutationInput, SharedProjectUncheckedUpdateManyInput>
    /**
     * Filter which SharedProjects to update
     */
    where?: SharedProjectWhereInput
  }

  /**
   * SharedProject upsert
   */
  export type SharedProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the SharedProject to update in case it exists.
     */
    where: SharedProjectWhereUniqueInput
    /**
     * In case the SharedProject found by the `where` argument doesn't exist, create a new SharedProject with this data.
     */
    create: XOR<SharedProjectCreateInput, SharedProjectUncheckedCreateInput>
    /**
     * In case the SharedProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedProjectUpdateInput, SharedProjectUncheckedUpdateInput>
  }

  /**
   * SharedProject delete
   */
  export type SharedProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
    /**
     * Filter which SharedProject to delete.
     */
    where: SharedProjectWhereUniqueInput
  }

  /**
   * SharedProject deleteMany
   */
  export type SharedProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedProjects to delete
     */
    where?: SharedProjectWhereInput
  }

  /**
   * SharedProject.sharedWithUser
   */
  export type SharedProject$sharedWithUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SharedProject without action
   */
  export type SharedProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedProject
     */
    select?: SharedProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedProjectInclude<ExtArgs> | null
  }


  /**
   * Model CloudBackup
   */

  export type AggregateCloudBackup = {
    _count: CloudBackupCountAggregateOutputType | null
    _avg: CloudBackupAvgAggregateOutputType | null
    _sum: CloudBackupSumAggregateOutputType | null
    _min: CloudBackupMinAggregateOutputType | null
    _max: CloudBackupMaxAggregateOutputType | null
  }

  export type CloudBackupAvgAggregateOutputType = {
    fileSize: number | null
    originalSize: number | null
  }

  export type CloudBackupSumAggregateOutputType = {
    fileSize: number | null
    originalSize: number | null
  }

  export type CloudBackupMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    backupName: string | null
    compressedData: Buffer | null
    fileSize: number | null
    checksum: string | null
    compressionType: string | null
    originalSize: number | null
    createdAt: Date | null
    accessedAt: Date | null
  }

  export type CloudBackupMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    backupName: string | null
    compressedData: Buffer | null
    fileSize: number | null
    checksum: string | null
    compressionType: string | null
    originalSize: number | null
    createdAt: Date | null
    accessedAt: Date | null
  }

  export type CloudBackupCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    backupName: number
    compressedData: number
    fileSize: number
    checksum: number
    compressionType: number
    originalSize: number
    metadata: number
    createdAt: number
    accessedAt: number
    _all: number
  }


  export type CloudBackupAvgAggregateInputType = {
    fileSize?: true
    originalSize?: true
  }

  export type CloudBackupSumAggregateInputType = {
    fileSize?: true
    originalSize?: true
  }

  export type CloudBackupMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    backupName?: true
    compressedData?: true
    fileSize?: true
    checksum?: true
    compressionType?: true
    originalSize?: true
    createdAt?: true
    accessedAt?: true
  }

  export type CloudBackupMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    backupName?: true
    compressedData?: true
    fileSize?: true
    checksum?: true
    compressionType?: true
    originalSize?: true
    createdAt?: true
    accessedAt?: true
  }

  export type CloudBackupCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    backupName?: true
    compressedData?: true
    fileSize?: true
    checksum?: true
    compressionType?: true
    originalSize?: true
    metadata?: true
    createdAt?: true
    accessedAt?: true
    _all?: true
  }

  export type CloudBackupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CloudBackup to aggregate.
     */
    where?: CloudBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloudBackups to fetch.
     */
    orderBy?: CloudBackupOrderByWithRelationInput | CloudBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CloudBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloudBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloudBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CloudBackups
    **/
    _count?: true | CloudBackupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CloudBackupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CloudBackupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CloudBackupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CloudBackupMaxAggregateInputType
  }

  export type GetCloudBackupAggregateType<T extends CloudBackupAggregateArgs> = {
        [P in keyof T & keyof AggregateCloudBackup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCloudBackup[P]>
      : GetScalarType<T[P], AggregateCloudBackup[P]>
  }




  export type CloudBackupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CloudBackupWhereInput
    orderBy?: CloudBackupOrderByWithAggregationInput | CloudBackupOrderByWithAggregationInput[]
    by: CloudBackupScalarFieldEnum[] | CloudBackupScalarFieldEnum
    having?: CloudBackupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CloudBackupCountAggregateInputType | true
    _avg?: CloudBackupAvgAggregateInputType
    _sum?: CloudBackupSumAggregateInputType
    _min?: CloudBackupMinAggregateInputType
    _max?: CloudBackupMaxAggregateInputType
  }

  export type CloudBackupGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    backupName: string | null
    compressedData: Buffer | null
    fileSize: number
    checksum: string
    compressionType: string
    originalSize: number | null
    metadata: JsonValue | null
    createdAt: Date
    accessedAt: Date | null
    _count: CloudBackupCountAggregateOutputType | null
    _avg: CloudBackupAvgAggregateOutputType | null
    _sum: CloudBackupSumAggregateOutputType | null
    _min: CloudBackupMinAggregateOutputType | null
    _max: CloudBackupMaxAggregateOutputType | null
  }

  type GetCloudBackupGroupByPayload<T extends CloudBackupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CloudBackupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CloudBackupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CloudBackupGroupByOutputType[P]>
            : GetScalarType<T[P], CloudBackupGroupByOutputType[P]>
        }
      >
    >


  export type CloudBackupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    backupName?: boolean
    compressedData?: boolean
    fileSize?: boolean
    checksum?: boolean
    compressionType?: boolean
    originalSize?: boolean
    metadata?: boolean
    createdAt?: boolean
    accessedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cloudBackup"]>

  export type CloudBackupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    backupName?: boolean
    compressedData?: boolean
    fileSize?: boolean
    checksum?: boolean
    compressionType?: boolean
    originalSize?: boolean
    metadata?: boolean
    createdAt?: boolean
    accessedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cloudBackup"]>

  export type CloudBackupSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    backupName?: boolean
    compressedData?: boolean
    fileSize?: boolean
    checksum?: boolean
    compressionType?: boolean
    originalSize?: boolean
    metadata?: boolean
    createdAt?: boolean
    accessedAt?: boolean
  }

  export type CloudBackupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CloudBackupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CloudBackupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CloudBackup"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      backupName: string | null
      compressedData: Buffer | null
      fileSize: number
      checksum: string
      compressionType: string
      originalSize: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      accessedAt: Date | null
    }, ExtArgs["result"]["cloudBackup"]>
    composites: {}
  }

  type CloudBackupGetPayload<S extends boolean | null | undefined | CloudBackupDefaultArgs> = $Result.GetResult<Prisma.$CloudBackupPayload, S>

  type CloudBackupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CloudBackupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CloudBackupCountAggregateInputType | true
    }

  export interface CloudBackupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CloudBackup'], meta: { name: 'CloudBackup' } }
    /**
     * Find zero or one CloudBackup that matches the filter.
     * @param {CloudBackupFindUniqueArgs} args - Arguments to find a CloudBackup
     * @example
     * // Get one CloudBackup
     * const cloudBackup = await prisma.cloudBackup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CloudBackupFindUniqueArgs>(args: SelectSubset<T, CloudBackupFindUniqueArgs<ExtArgs>>): Prisma__CloudBackupClient<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CloudBackup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CloudBackupFindUniqueOrThrowArgs} args - Arguments to find a CloudBackup
     * @example
     * // Get one CloudBackup
     * const cloudBackup = await prisma.cloudBackup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CloudBackupFindUniqueOrThrowArgs>(args: SelectSubset<T, CloudBackupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CloudBackupClient<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CloudBackup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudBackupFindFirstArgs} args - Arguments to find a CloudBackup
     * @example
     * // Get one CloudBackup
     * const cloudBackup = await prisma.cloudBackup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CloudBackupFindFirstArgs>(args?: SelectSubset<T, CloudBackupFindFirstArgs<ExtArgs>>): Prisma__CloudBackupClient<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CloudBackup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudBackupFindFirstOrThrowArgs} args - Arguments to find a CloudBackup
     * @example
     * // Get one CloudBackup
     * const cloudBackup = await prisma.cloudBackup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CloudBackupFindFirstOrThrowArgs>(args?: SelectSubset<T, CloudBackupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CloudBackupClient<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CloudBackups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudBackupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CloudBackups
     * const cloudBackups = await prisma.cloudBackup.findMany()
     * 
     * // Get first 10 CloudBackups
     * const cloudBackups = await prisma.cloudBackup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cloudBackupWithIdOnly = await prisma.cloudBackup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CloudBackupFindManyArgs>(args?: SelectSubset<T, CloudBackupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CloudBackup.
     * @param {CloudBackupCreateArgs} args - Arguments to create a CloudBackup.
     * @example
     * // Create one CloudBackup
     * const CloudBackup = await prisma.cloudBackup.create({
     *   data: {
     *     // ... data to create a CloudBackup
     *   }
     * })
     * 
     */
    create<T extends CloudBackupCreateArgs>(args: SelectSubset<T, CloudBackupCreateArgs<ExtArgs>>): Prisma__CloudBackupClient<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CloudBackups.
     * @param {CloudBackupCreateManyArgs} args - Arguments to create many CloudBackups.
     * @example
     * // Create many CloudBackups
     * const cloudBackup = await prisma.cloudBackup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CloudBackupCreateManyArgs>(args?: SelectSubset<T, CloudBackupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CloudBackups and returns the data saved in the database.
     * @param {CloudBackupCreateManyAndReturnArgs} args - Arguments to create many CloudBackups.
     * @example
     * // Create many CloudBackups
     * const cloudBackup = await prisma.cloudBackup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CloudBackups and only return the `id`
     * const cloudBackupWithIdOnly = await prisma.cloudBackup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CloudBackupCreateManyAndReturnArgs>(args?: SelectSubset<T, CloudBackupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CloudBackup.
     * @param {CloudBackupDeleteArgs} args - Arguments to delete one CloudBackup.
     * @example
     * // Delete one CloudBackup
     * const CloudBackup = await prisma.cloudBackup.delete({
     *   where: {
     *     // ... filter to delete one CloudBackup
     *   }
     * })
     * 
     */
    delete<T extends CloudBackupDeleteArgs>(args: SelectSubset<T, CloudBackupDeleteArgs<ExtArgs>>): Prisma__CloudBackupClient<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CloudBackup.
     * @param {CloudBackupUpdateArgs} args - Arguments to update one CloudBackup.
     * @example
     * // Update one CloudBackup
     * const cloudBackup = await prisma.cloudBackup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CloudBackupUpdateArgs>(args: SelectSubset<T, CloudBackupUpdateArgs<ExtArgs>>): Prisma__CloudBackupClient<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CloudBackups.
     * @param {CloudBackupDeleteManyArgs} args - Arguments to filter CloudBackups to delete.
     * @example
     * // Delete a few CloudBackups
     * const { count } = await prisma.cloudBackup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CloudBackupDeleteManyArgs>(args?: SelectSubset<T, CloudBackupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CloudBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudBackupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CloudBackups
     * const cloudBackup = await prisma.cloudBackup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CloudBackupUpdateManyArgs>(args: SelectSubset<T, CloudBackupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CloudBackup.
     * @param {CloudBackupUpsertArgs} args - Arguments to update or create a CloudBackup.
     * @example
     * // Update or create a CloudBackup
     * const cloudBackup = await prisma.cloudBackup.upsert({
     *   create: {
     *     // ... data to create a CloudBackup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CloudBackup we want to update
     *   }
     * })
     */
    upsert<T extends CloudBackupUpsertArgs>(args: SelectSubset<T, CloudBackupUpsertArgs<ExtArgs>>): Prisma__CloudBackupClient<$Result.GetResult<Prisma.$CloudBackupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CloudBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudBackupCountArgs} args - Arguments to filter CloudBackups to count.
     * @example
     * // Count the number of CloudBackups
     * const count = await prisma.cloudBackup.count({
     *   where: {
     *     // ... the filter for the CloudBackups we want to count
     *   }
     * })
    **/
    count<T extends CloudBackupCountArgs>(
      args?: Subset<T, CloudBackupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CloudBackupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CloudBackup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudBackupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CloudBackupAggregateArgs>(args: Subset<T, CloudBackupAggregateArgs>): Prisma.PrismaPromise<GetCloudBackupAggregateType<T>>

    /**
     * Group by CloudBackup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudBackupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CloudBackupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CloudBackupGroupByArgs['orderBy'] }
        : { orderBy?: CloudBackupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CloudBackupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCloudBackupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CloudBackup model
   */
  readonly fields: CloudBackupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CloudBackup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CloudBackupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CloudBackup model
   */ 
  interface CloudBackupFieldRefs {
    readonly id: FieldRef<"CloudBackup", 'String'>
    readonly projectId: FieldRef<"CloudBackup", 'String'>
    readonly userId: FieldRef<"CloudBackup", 'String'>
    readonly backupName: FieldRef<"CloudBackup", 'String'>
    readonly compressedData: FieldRef<"CloudBackup", 'Bytes'>
    readonly fileSize: FieldRef<"CloudBackup", 'Int'>
    readonly checksum: FieldRef<"CloudBackup", 'String'>
    readonly compressionType: FieldRef<"CloudBackup", 'String'>
    readonly originalSize: FieldRef<"CloudBackup", 'Int'>
    readonly metadata: FieldRef<"CloudBackup", 'Json'>
    readonly createdAt: FieldRef<"CloudBackup", 'DateTime'>
    readonly accessedAt: FieldRef<"CloudBackup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CloudBackup findUnique
   */
  export type CloudBackupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * Filter, which CloudBackup to fetch.
     */
    where: CloudBackupWhereUniqueInput
  }

  /**
   * CloudBackup findUniqueOrThrow
   */
  export type CloudBackupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * Filter, which CloudBackup to fetch.
     */
    where: CloudBackupWhereUniqueInput
  }

  /**
   * CloudBackup findFirst
   */
  export type CloudBackupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * Filter, which CloudBackup to fetch.
     */
    where?: CloudBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloudBackups to fetch.
     */
    orderBy?: CloudBackupOrderByWithRelationInput | CloudBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CloudBackups.
     */
    cursor?: CloudBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloudBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloudBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CloudBackups.
     */
    distinct?: CloudBackupScalarFieldEnum | CloudBackupScalarFieldEnum[]
  }

  /**
   * CloudBackup findFirstOrThrow
   */
  export type CloudBackupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * Filter, which CloudBackup to fetch.
     */
    where?: CloudBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloudBackups to fetch.
     */
    orderBy?: CloudBackupOrderByWithRelationInput | CloudBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CloudBackups.
     */
    cursor?: CloudBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloudBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloudBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CloudBackups.
     */
    distinct?: CloudBackupScalarFieldEnum | CloudBackupScalarFieldEnum[]
  }

  /**
   * CloudBackup findMany
   */
  export type CloudBackupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * Filter, which CloudBackups to fetch.
     */
    where?: CloudBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloudBackups to fetch.
     */
    orderBy?: CloudBackupOrderByWithRelationInput | CloudBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CloudBackups.
     */
    cursor?: CloudBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloudBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloudBackups.
     */
    skip?: number
    distinct?: CloudBackupScalarFieldEnum | CloudBackupScalarFieldEnum[]
  }

  /**
   * CloudBackup create
   */
  export type CloudBackupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * The data needed to create a CloudBackup.
     */
    data: XOR<CloudBackupCreateInput, CloudBackupUncheckedCreateInput>
  }

  /**
   * CloudBackup createMany
   */
  export type CloudBackupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CloudBackups.
     */
    data: CloudBackupCreateManyInput | CloudBackupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CloudBackup createManyAndReturn
   */
  export type CloudBackupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CloudBackups.
     */
    data: CloudBackupCreateManyInput | CloudBackupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CloudBackup update
   */
  export type CloudBackupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * The data needed to update a CloudBackup.
     */
    data: XOR<CloudBackupUpdateInput, CloudBackupUncheckedUpdateInput>
    /**
     * Choose, which CloudBackup to update.
     */
    where: CloudBackupWhereUniqueInput
  }

  /**
   * CloudBackup updateMany
   */
  export type CloudBackupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CloudBackups.
     */
    data: XOR<CloudBackupUpdateManyMutationInput, CloudBackupUncheckedUpdateManyInput>
    /**
     * Filter which CloudBackups to update
     */
    where?: CloudBackupWhereInput
  }

  /**
   * CloudBackup upsert
   */
  export type CloudBackupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * The filter to search for the CloudBackup to update in case it exists.
     */
    where: CloudBackupWhereUniqueInput
    /**
     * In case the CloudBackup found by the `where` argument doesn't exist, create a new CloudBackup with this data.
     */
    create: XOR<CloudBackupCreateInput, CloudBackupUncheckedCreateInput>
    /**
     * In case the CloudBackup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CloudBackupUpdateInput, CloudBackupUncheckedUpdateInput>
  }

  /**
   * CloudBackup delete
   */
  export type CloudBackupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
    /**
     * Filter which CloudBackup to delete.
     */
    where: CloudBackupWhereUniqueInput
  }

  /**
   * CloudBackup deleteMany
   */
  export type CloudBackupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CloudBackups to delete
     */
    where?: CloudBackupWhereInput
  }

  /**
   * CloudBackup without action
   */
  export type CloudBackupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudBackup
     */
    select?: CloudBackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudBackupInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    status: string | null
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    status: string | null
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    status: number
    errorMessage: number
    ipAddress: number
    userAgent: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    status?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    status?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    status?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string | null
    resourceId: string | null
    status: string
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    status?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    status?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    status?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string | null
      resourceId: string | null
      status: string
      errorMessage: string | null
      ipAddress: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly status: FieldRef<"AuditLog", 'String'>
    readonly errorMessage: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model NumExports
   */

  export type AggregateNumExports = {
    _count: NumExportsCountAggregateOutputType | null
    _avg: NumExportsAvgAggregateOutputType | null
    _sum: NumExportsSumAggregateOutputType | null
    _min: NumExportsMinAggregateOutputType | null
    _max: NumExportsMaxAggregateOutputType | null
  }

  export type NumExportsAvgAggregateOutputType = {
    exports: number | null
  }

  export type NumExportsSumAggregateOutputType = {
    exports: number | null
  }

  export type NumExportsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    exports: number | null
    updatedAt: Date | null
  }

  export type NumExportsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    exports: number | null
    updatedAt: Date | null
  }

  export type NumExportsCountAggregateOutputType = {
    id: number
    userId: number
    exports: number
    updatedAt: number
    _all: number
  }


  export type NumExportsAvgAggregateInputType = {
    exports?: true
  }

  export type NumExportsSumAggregateInputType = {
    exports?: true
  }

  export type NumExportsMinAggregateInputType = {
    id?: true
    userId?: true
    exports?: true
    updatedAt?: true
  }

  export type NumExportsMaxAggregateInputType = {
    id?: true
    userId?: true
    exports?: true
    updatedAt?: true
  }

  export type NumExportsCountAggregateInputType = {
    id?: true
    userId?: true
    exports?: true
    updatedAt?: true
    _all?: true
  }

  export type NumExportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NumExports to aggregate.
     */
    where?: NumExportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NumExports to fetch.
     */
    orderBy?: NumExportsOrderByWithRelationInput | NumExportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NumExportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NumExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NumExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NumExports
    **/
    _count?: true | NumExportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NumExportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NumExportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NumExportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NumExportsMaxAggregateInputType
  }

  export type GetNumExportsAggregateType<T extends NumExportsAggregateArgs> = {
        [P in keyof T & keyof AggregateNumExports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNumExports[P]>
      : GetScalarType<T[P], AggregateNumExports[P]>
  }




  export type NumExportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NumExportsWhereInput
    orderBy?: NumExportsOrderByWithAggregationInput | NumExportsOrderByWithAggregationInput[]
    by: NumExportsScalarFieldEnum[] | NumExportsScalarFieldEnum
    having?: NumExportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NumExportsCountAggregateInputType | true
    _avg?: NumExportsAvgAggregateInputType
    _sum?: NumExportsSumAggregateInputType
    _min?: NumExportsMinAggregateInputType
    _max?: NumExportsMaxAggregateInputType
  }

  export type NumExportsGroupByOutputType = {
    id: string
    userId: string
    exports: number
    updatedAt: Date
    _count: NumExportsCountAggregateOutputType | null
    _avg: NumExportsAvgAggregateOutputType | null
    _sum: NumExportsSumAggregateOutputType | null
    _min: NumExportsMinAggregateOutputType | null
    _max: NumExportsMaxAggregateOutputType | null
  }

  type GetNumExportsGroupByPayload<T extends NumExportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NumExportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NumExportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NumExportsGroupByOutputType[P]>
            : GetScalarType<T[P], NumExportsGroupByOutputType[P]>
        }
      >
    >


  export type NumExportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exports?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["numExports"]>

  export type NumExportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exports?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["numExports"]>

  export type NumExportsSelectScalar = {
    id?: boolean
    userId?: boolean
    exports?: boolean
    updatedAt?: boolean
  }

  export type NumExportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NumExportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NumExportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NumExports"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      exports: number
      updatedAt: Date
    }, ExtArgs["result"]["numExports"]>
    composites: {}
  }

  type NumExportsGetPayload<S extends boolean | null | undefined | NumExportsDefaultArgs> = $Result.GetResult<Prisma.$NumExportsPayload, S>

  type NumExportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NumExportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NumExportsCountAggregateInputType | true
    }

  export interface NumExportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NumExports'], meta: { name: 'NumExports' } }
    /**
     * Find zero or one NumExports that matches the filter.
     * @param {NumExportsFindUniqueArgs} args - Arguments to find a NumExports
     * @example
     * // Get one NumExports
     * const numExports = await prisma.numExports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NumExportsFindUniqueArgs>(args: SelectSubset<T, NumExportsFindUniqueArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NumExports that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NumExportsFindUniqueOrThrowArgs} args - Arguments to find a NumExports
     * @example
     * // Get one NumExports
     * const numExports = await prisma.numExports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NumExportsFindUniqueOrThrowArgs>(args: SelectSubset<T, NumExportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NumExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NumExportsFindFirstArgs} args - Arguments to find a NumExports
     * @example
     * // Get one NumExports
     * const numExports = await prisma.numExports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NumExportsFindFirstArgs>(args?: SelectSubset<T, NumExportsFindFirstArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NumExports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NumExportsFindFirstOrThrowArgs} args - Arguments to find a NumExports
     * @example
     * // Get one NumExports
     * const numExports = await prisma.numExports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NumExportsFindFirstOrThrowArgs>(args?: SelectSubset<T, NumExportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NumExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NumExportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NumExports
     * const numExports = await prisma.numExports.findMany()
     * 
     * // Get first 10 NumExports
     * const numExports = await prisma.numExports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const numExportsWithIdOnly = await prisma.numExports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NumExportsFindManyArgs>(args?: SelectSubset<T, NumExportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NumExports.
     * @param {NumExportsCreateArgs} args - Arguments to create a NumExports.
     * @example
     * // Create one NumExports
     * const NumExports = await prisma.numExports.create({
     *   data: {
     *     // ... data to create a NumExports
     *   }
     * })
     * 
     */
    create<T extends NumExportsCreateArgs>(args: SelectSubset<T, NumExportsCreateArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NumExports.
     * @param {NumExportsCreateManyArgs} args - Arguments to create many NumExports.
     * @example
     * // Create many NumExports
     * const numExports = await prisma.numExports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NumExportsCreateManyArgs>(args?: SelectSubset<T, NumExportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NumExports and returns the data saved in the database.
     * @param {NumExportsCreateManyAndReturnArgs} args - Arguments to create many NumExports.
     * @example
     * // Create many NumExports
     * const numExports = await prisma.numExports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NumExports and only return the `id`
     * const numExportsWithIdOnly = await prisma.numExports.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NumExportsCreateManyAndReturnArgs>(args?: SelectSubset<T, NumExportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NumExports.
     * @param {NumExportsDeleteArgs} args - Arguments to delete one NumExports.
     * @example
     * // Delete one NumExports
     * const NumExports = await prisma.numExports.delete({
     *   where: {
     *     // ... filter to delete one NumExports
     *   }
     * })
     * 
     */
    delete<T extends NumExportsDeleteArgs>(args: SelectSubset<T, NumExportsDeleteArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NumExports.
     * @param {NumExportsUpdateArgs} args - Arguments to update one NumExports.
     * @example
     * // Update one NumExports
     * const numExports = await prisma.numExports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NumExportsUpdateArgs>(args: SelectSubset<T, NumExportsUpdateArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NumExports.
     * @param {NumExportsDeleteManyArgs} args - Arguments to filter NumExports to delete.
     * @example
     * // Delete a few NumExports
     * const { count } = await prisma.numExports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NumExportsDeleteManyArgs>(args?: SelectSubset<T, NumExportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NumExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NumExportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NumExports
     * const numExports = await prisma.numExports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NumExportsUpdateManyArgs>(args: SelectSubset<T, NumExportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NumExports.
     * @param {NumExportsUpsertArgs} args - Arguments to update or create a NumExports.
     * @example
     * // Update or create a NumExports
     * const numExports = await prisma.numExports.upsert({
     *   create: {
     *     // ... data to create a NumExports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NumExports we want to update
     *   }
     * })
     */
    upsert<T extends NumExportsUpsertArgs>(args: SelectSubset<T, NumExportsUpsertArgs<ExtArgs>>): Prisma__NumExportsClient<$Result.GetResult<Prisma.$NumExportsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NumExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NumExportsCountArgs} args - Arguments to filter NumExports to count.
     * @example
     * // Count the number of NumExports
     * const count = await prisma.numExports.count({
     *   where: {
     *     // ... the filter for the NumExports we want to count
     *   }
     * })
    **/
    count<T extends NumExportsCountArgs>(
      args?: Subset<T, NumExportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NumExportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NumExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NumExportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NumExportsAggregateArgs>(args: Subset<T, NumExportsAggregateArgs>): Prisma.PrismaPromise<GetNumExportsAggregateType<T>>

    /**
     * Group by NumExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NumExportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NumExportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NumExportsGroupByArgs['orderBy'] }
        : { orderBy?: NumExportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NumExportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNumExportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NumExports model
   */
  readonly fields: NumExportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NumExports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NumExportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NumExports model
   */ 
  interface NumExportsFieldRefs {
    readonly id: FieldRef<"NumExports", 'String'>
    readonly userId: FieldRef<"NumExports", 'String'>
    readonly exports: FieldRef<"NumExports", 'Int'>
    readonly updatedAt: FieldRef<"NumExports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NumExports findUnique
   */
  export type NumExportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * Filter, which NumExports to fetch.
     */
    where: NumExportsWhereUniqueInput
  }

  /**
   * NumExports findUniqueOrThrow
   */
  export type NumExportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * Filter, which NumExports to fetch.
     */
    where: NumExportsWhereUniqueInput
  }

  /**
   * NumExports findFirst
   */
  export type NumExportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * Filter, which NumExports to fetch.
     */
    where?: NumExportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NumExports to fetch.
     */
    orderBy?: NumExportsOrderByWithRelationInput | NumExportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NumExports.
     */
    cursor?: NumExportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NumExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NumExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NumExports.
     */
    distinct?: NumExportsScalarFieldEnum | NumExportsScalarFieldEnum[]
  }

  /**
   * NumExports findFirstOrThrow
   */
  export type NumExportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * Filter, which NumExports to fetch.
     */
    where?: NumExportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NumExports to fetch.
     */
    orderBy?: NumExportsOrderByWithRelationInput | NumExportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NumExports.
     */
    cursor?: NumExportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NumExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NumExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NumExports.
     */
    distinct?: NumExportsScalarFieldEnum | NumExportsScalarFieldEnum[]
  }

  /**
   * NumExports findMany
   */
  export type NumExportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * Filter, which NumExports to fetch.
     */
    where?: NumExportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NumExports to fetch.
     */
    orderBy?: NumExportsOrderByWithRelationInput | NumExportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NumExports.
     */
    cursor?: NumExportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NumExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NumExports.
     */
    skip?: number
    distinct?: NumExportsScalarFieldEnum | NumExportsScalarFieldEnum[]
  }

  /**
   * NumExports create
   */
  export type NumExportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * The data needed to create a NumExports.
     */
    data: XOR<NumExportsCreateInput, NumExportsUncheckedCreateInput>
  }

  /**
   * NumExports createMany
   */
  export type NumExportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NumExports.
     */
    data: NumExportsCreateManyInput | NumExportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NumExports createManyAndReturn
   */
  export type NumExportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NumExports.
     */
    data: NumExportsCreateManyInput | NumExportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NumExports update
   */
  export type NumExportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * The data needed to update a NumExports.
     */
    data: XOR<NumExportsUpdateInput, NumExportsUncheckedUpdateInput>
    /**
     * Choose, which NumExports to update.
     */
    where: NumExportsWhereUniqueInput
  }

  /**
   * NumExports updateMany
   */
  export type NumExportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NumExports.
     */
    data: XOR<NumExportsUpdateManyMutationInput, NumExportsUncheckedUpdateManyInput>
    /**
     * Filter which NumExports to update
     */
    where?: NumExportsWhereInput
  }

  /**
   * NumExports upsert
   */
  export type NumExportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * The filter to search for the NumExports to update in case it exists.
     */
    where: NumExportsWhereUniqueInput
    /**
     * In case the NumExports found by the `where` argument doesn't exist, create a new NumExports with this data.
     */
    create: XOR<NumExportsCreateInput, NumExportsUncheckedCreateInput>
    /**
     * In case the NumExports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NumExportsUpdateInput, NumExportsUncheckedUpdateInput>
  }

  /**
   * NumExports delete
   */
  export type NumExportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
    /**
     * Filter which NumExports to delete.
     */
    where: NumExportsWhereUniqueInput
  }

  /**
   * NumExports deleteMany
   */
  export type NumExportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NumExports to delete
     */
    where?: NumExportsWhereInput
  }

  /**
   * NumExports without action
   */
  export type NumExportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NumExports
     */
    select?: NumExportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NumExportsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    emailVerified: 'emailVerified',
    verificationToken: 'verificationToken',
    verificationTokenExpiry: 'verificationTokenExpiry',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpiry: 'passwordResetExpiry',
    name: 'name',
    phoneNumber: 'phoneNumber',
    organization: 'organization',
    jobTitle: 'jobTitle',
    country: 'country',
    industry: 'industry',
    tier: 'tier',
    modelLimit: 'modelLimit',
    modelsUsed: 'modelsUsed',
    timeSpent: 'timeSpent',
    maxStepReached: 'maxStepReached',
    lastSessionFinalStep: 'lastSessionFinalStep',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    mfaEnabled: 'mfaEnabled',
    mfaSecret: 'mfaSecret',
    avatarUrl: 'avatarUrl',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    revoked: 'revoked',
    revokedAt: 'revokedAt',
    replacedByToken: 'replacedByToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const LicenseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    licenseType: 'licenseType',
    status: 'status',
    dateStart: 'dateStart',
    dateEnd: 'dateEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LicenseScalarFieldEnum = (typeof LicenseScalarFieldEnum)[keyof typeof LicenseScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tier: 'tier',
    status: 'status',
    billingCycle: 'billingCycle',
    amount: 'amount',
    currency: 'currency',
    modelLimit: 'modelLimit',
    startDate: 'startDate',
    endDate: 'endDate',
    nextBillingDate: 'nextBillingDate',
    cancelledAt: 'cancelledAt',
    autoRenew: 'autoRenew',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    paymentMethod: 'paymentMethod',
    gatewayProvider: 'gatewayProvider',
    gatewayOrderId: 'gatewayOrderId',
    gatewayPaymentId: 'gatewayPaymentId',
    gatewaySignature: 'gatewaySignature',
    transactionId: 'transactionId',
    receiptUrl: 'receiptUrl',
    invoiceUrl: 'invoiceUrl',
    failureReason: 'failureReason',
    failureCode: 'failureCode',
    refundedAmount: 'refundedAmount',
    refundedAt: 'refundedAt',
    refundReason: 'refundReason',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ModelImportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectId: 'projectId',
    filename: 'filename',
    originalFilename: 'originalFilename',
    fileSize: 'fileSize',
    fileHash: 'fileHash',
    modelData: 'modelData',
    thumbnailData: 'thumbnailData',
    status: 'status',
    progress: 'progress',
    processingStartedAt: 'processingStartedAt',
    processingCompletedAt: 'processingCompletedAt',
    processingDuration: 'processingDuration',
    vertexCount: 'vertexCount',
    faceCount: 'faceCount',
    boundingBox: 'boundingBox',
    dimensions: 'dimensions',
    volume: 'volume',
    isValid: 'isValid',
    validationErrors: 'validationErrors',
    errorMessage: 'errorMessage',
    errorCode: 'errorCode',
    countsTowardLimit: 'countsTowardLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ModelImportScalarFieldEnum = (typeof ModelImportScalarFieldEnum)[keyof typeof ModelImportScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    thumbnailUrl: 'thumbnailUrl',
    modelFilename: 'modelFilename',
    modelFileType: 'modelFileType',
    modelFileSize: 'modelFileSize',
    supportsCount: 'supportsCount',
    clampsCount: 'clampsCount',
    hasBaseplate: 'hasBaseplate',
    processingTime: 'processingTime',
    toolingApplied: 'toolingApplied',
    status: 'status',
    isPublic: 'isPublic',
    shareToken: 'shareToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastOpenedAt: 'lastOpenedAt',
    completedAt: 'completedAt',
    deletedAt: 'deletedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const DesignVersionScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    versionNumber: 'versionNumber',
    name: 'name',
    description: 'description',
    thumbnailUrl: 'thumbnailUrl',
    changesSummary: 'changesSummary',
    supportsCount: 'supportsCount',
    clampsCount: 'clampsCount',
    isAutoSave: 'isAutoSave',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type DesignVersionScalarFieldEnum = (typeof DesignVersionScalarFieldEnum)[keyof typeof DesignVersionScalarFieldEnum]


  export const ExportScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    format: 'format',
    filename: 'filename',
    fileSize: 'fileSize',
    exportData: 'exportData',
    fileUrl: 'fileUrl',
    settings: 'settings',
    includeSupports: 'includeSupports',
    includeClamps: 'includeClamps',
    includeBaseplate: 'includeBaseplate',
    processingTime: 'processingTime',
    status: 'status',
    errorMessage: 'errorMessage',
    numberOfExportsDone: 'numberOfExportsDone',
    downloadCount: 'downloadCount',
    lastDownloadedAt: 'lastDownloadedAt',
    createdAt: 'createdAt',
    completedAt: 'completedAt',
    expiresAt: 'expiresAt'
  };

  export type ExportScalarFieldEnum = (typeof ExportScalarFieldEnum)[keyof typeof ExportScalarFieldEnum]


  export const ErrorLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectId: 'projectId',
    modelImportId: 'modelImportId',
    exportId: 'exportId',
    category: 'category',
    severity: 'severity',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    errorStack: 'errorStack',
    operation: 'operation',
    step: 'step',
    browserInfo: 'browserInfo',
    deviceInfo: 'deviceInfo',
    url: 'url',
    method: 'method',
    statusCode: 'statusCode',
    userAction: 'userAction',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    resolution: 'resolution',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ErrorLogScalarFieldEnum = (typeof ErrorLogScalarFieldEnum)[keyof typeof ErrorLogScalarFieldEnum]


  export const SharedProjectScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    sharedBy: 'sharedBy',
    sharedWith: 'sharedWith',
    permission: 'permission',
    shareType: 'shareType',
    shareToken: 'shareToken',
    accepted: 'accepted',
    revoked: 'revoked',
    createdAt: 'createdAt',
    acceptedAt: 'acceptedAt',
    revokedAt: 'revokedAt',
    expiresAt: 'expiresAt'
  };

  export type SharedProjectScalarFieldEnum = (typeof SharedProjectScalarFieldEnum)[keyof typeof SharedProjectScalarFieldEnum]


  export const CloudBackupScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    backupName: 'backupName',
    compressedData: 'compressedData',
    fileSize: 'fileSize',
    checksum: 'checksum',
    compressionType: 'compressionType',
    originalSize: 'originalSize',
    metadata: 'metadata',
    createdAt: 'createdAt',
    accessedAt: 'accessedAt'
  };

  export type CloudBackupScalarFieldEnum = (typeof CloudBackupScalarFieldEnum)[keyof typeof CloudBackupScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    status: 'status',
    errorMessage: 'errorMessage',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NumExportsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    exports: 'exports',
    updatedAt: 'updatedAt'
  };

  export type NumExportsScalarFieldEnum = (typeof NumExportsScalarFieldEnum)[keyof typeof NumExportsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserTier'
   */
  export type EnumUserTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTier'>
    


  /**
   * Reference to a field of type 'UserTier[]'
   */
  export type ListEnumUserTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTier[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'LicenseType'
   */
  export type EnumLicenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseType'>
    


  /**
   * Reference to a field of type 'LicenseType[]'
   */
  export type ListEnumLicenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseType[]'>
    


  /**
   * Reference to a field of type 'LicenseStatus'
   */
  export type EnumLicenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseStatus'>
    


  /**
   * Reference to a field of type 'LicenseStatus[]'
   */
  export type ListEnumLicenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'ImportStatus'
   */
  export type EnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus'>
    


  /**
   * Reference to a field of type 'ImportStatus[]'
   */
  export type ListEnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'ExportFormat'
   */
  export type EnumExportFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExportFormat'>
    


  /**
   * Reference to a field of type 'ExportFormat[]'
   */
  export type ListEnumExportFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExportFormat[]'>
    


  /**
   * Reference to a field of type 'ExportStatus'
   */
  export type EnumExportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExportStatus'>
    


  /**
   * Reference to a field of type 'ExportStatus[]'
   */
  export type ListEnumExportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExportStatus[]'>
    


  /**
   * Reference to a field of type 'ErrorCategory'
   */
  export type EnumErrorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ErrorCategory'>
    


  /**
   * Reference to a field of type 'ErrorCategory[]'
   */
  export type ListEnumErrorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ErrorCategory[]'>
    


  /**
   * Reference to a field of type 'ErrorSeverity'
   */
  export type EnumErrorSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ErrorSeverity'>
    


  /**
   * Reference to a field of type 'ErrorSeverity[]'
   */
  export type ListEnumErrorSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ErrorSeverity[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    name?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    organization?: StringNullableFilter<"User"> | string | null
    jobTitle?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    industry?: StringNullableFilter<"User"> | string | null
    tier?: EnumUserTierFilter<"User"> | $Enums.UserTier
    modelLimit?: IntFilter<"User"> | number
    modelsUsed?: IntFilter<"User"> | number
    timeSpent?: IntFilter<"User"> | number
    maxStepReached?: IntFilter<"User"> | number
    lastSessionFinalStep?: IntFilter<"User"> | number
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshTokens?: RefreshTokenListRelationFilter
    license?: XOR<LicenseNullableRelationFilter, LicenseWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    projects?: ProjectListRelationFilter
    modelImports?: ModelImportListRelationFilter
    exports?: ExportListRelationFilter
    payments?: PaymentListRelationFilter
    errorLogs?: ErrorLogListRelationFilter
    cloudBackups?: CloudBackupListRelationFilter
    sharedProjects?: SharedProjectListRelationFilter
    receivedShares?: SharedProjectListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    numExports?: XOR<NumExportsNullableRelationFilter, NumExportsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationTokenExpiry?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpiry?: SortOrderInput | SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    tier?: SortOrder
    modelLimit?: SortOrder
    modelsUsed?: SortOrder
    timeSpent?: SortOrder
    maxStepReached?: SortOrder
    lastSessionFinalStep?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    license?: LicenseOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    projects?: ProjectOrderByRelationAggregateInput
    modelImports?: ModelImportOrderByRelationAggregateInput
    exports?: ExportOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    errorLogs?: ErrorLogOrderByRelationAggregateInput
    cloudBackups?: CloudBackupOrderByRelationAggregateInput
    sharedProjects?: SharedProjectOrderByRelationAggregateInput
    receivedShares?: SharedProjectOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    numExports?: NumExportsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    name?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    organization?: StringNullableFilter<"User"> | string | null
    jobTitle?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    industry?: StringNullableFilter<"User"> | string | null
    tier?: EnumUserTierFilter<"User"> | $Enums.UserTier
    modelLimit?: IntFilter<"User"> | number
    modelsUsed?: IntFilter<"User"> | number
    timeSpent?: IntFilter<"User"> | number
    maxStepReached?: IntFilter<"User"> | number
    lastSessionFinalStep?: IntFilter<"User"> | number
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshTokens?: RefreshTokenListRelationFilter
    license?: XOR<LicenseNullableRelationFilter, LicenseWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    projects?: ProjectListRelationFilter
    modelImports?: ModelImportListRelationFilter
    exports?: ExportListRelationFilter
    payments?: PaymentListRelationFilter
    errorLogs?: ErrorLogListRelationFilter
    cloudBackups?: CloudBackupListRelationFilter
    sharedProjects?: SharedProjectListRelationFilter
    receivedShares?: SharedProjectListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    numExports?: XOR<NumExportsNullableRelationFilter, NumExportsWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationTokenExpiry?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpiry?: SortOrderInput | SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    tier?: SortOrder
    modelLimit?: SortOrder
    modelsUsed?: SortOrder
    timeSpent?: SortOrder
    maxStepReached?: SortOrder
    lastSessionFinalStep?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    organization?: StringNullableWithAggregatesFilter<"User"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    industry?: StringNullableWithAggregatesFilter<"User"> | string | null
    tier?: EnumUserTierWithAggregatesFilter<"User"> | $Enums.UserTier
    modelLimit?: IntWithAggregatesFilter<"User"> | number
    modelsUsed?: IntWithAggregatesFilter<"User"> | number
    timeSpent?: IntWithAggregatesFilter<"User"> | number
    maxStepReached?: IntWithAggregatesFilter<"User"> | number
    lastSessionFinalStep?: IntWithAggregatesFilter<"User"> | number
    failedLoginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    mfaEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferences?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    tokenHash?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    replacedByToken?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    replacedByToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    replacedByToken?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    replacedByToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    tokenHash?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    replacedByToken?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type LicenseWhereInput = {
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    id?: StringFilter<"License"> | string
    userId?: StringFilter<"License"> | string
    licenseType?: EnumLicenseTypeFilter<"License"> | $Enums.LicenseType
    status?: EnumLicenseStatusFilter<"License"> | $Enums.LicenseStatus
    dateStart?: DateTimeFilter<"License"> | Date | string
    dateEnd?: DateTimeNullableFilter<"License"> | Date | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LicenseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseType?: SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LicenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    licenseType?: EnumLicenseTypeFilter<"License"> | $Enums.LicenseType
    status?: EnumLicenseStatusFilter<"License"> | $Enums.LicenseStatus
    dateStart?: DateTimeFilter<"License"> | Date | string
    dateEnd?: DateTimeNullableFilter<"License"> | Date | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type LicenseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseType?: SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LicenseCountOrderByAggregateInput
    _max?: LicenseMaxOrderByAggregateInput
    _min?: LicenseMinOrderByAggregateInput
  }

  export type LicenseScalarWhereWithAggregatesInput = {
    AND?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    OR?: LicenseScalarWhereWithAggregatesInput[]
    NOT?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"License"> | string
    userId?: StringWithAggregatesFilter<"License"> | string
    licenseType?: EnumLicenseTypeWithAggregatesFilter<"License"> | $Enums.LicenseType
    status?: EnumLicenseStatusWithAggregatesFilter<"License"> | $Enums.LicenseStatus
    dateStart?: DateTimeWithAggregatesFilter<"License"> | Date | string
    dateEnd?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    tier?: EnumUserTierFilter<"Subscription"> | $Enums.UserTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    billingCycle?: StringFilter<"Subscription"> | string
    amount?: FloatFilter<"Subscription"> | number
    currency?: StringFilter<"Subscription"> | string
    modelLimit?: IntFilter<"Subscription"> | number
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    autoRenew?: BoolFilter<"Subscription"> | boolean
    metadata?: JsonNullableFilter<"Subscription">
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    modelLimit?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    tier?: EnumUserTierFilter<"Subscription"> | $Enums.UserTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    billingCycle?: StringFilter<"Subscription"> | string
    amount?: FloatFilter<"Subscription"> | number
    currency?: StringFilter<"Subscription"> | string
    modelLimit?: IntFilter<"Subscription"> | number
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    autoRenew?: BoolFilter<"Subscription"> | boolean
    metadata?: JsonNullableFilter<"Subscription">
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "userId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    modelLimit?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    tier?: EnumUserTierWithAggregatesFilter<"Subscription"> | $Enums.UserTier
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    billingCycle?: StringWithAggregatesFilter<"Subscription"> | string
    amount?: FloatWithAggregatesFilter<"Subscription"> | number
    currency?: StringWithAggregatesFilter<"Subscription"> | string
    modelLimit?: IntWithAggregatesFilter<"Subscription"> | number
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    autoRenew?: BoolWithAggregatesFilter<"Subscription"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Subscription">
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    gatewayProvider?: StringFilter<"Payment"> | string
    gatewayOrderId?: StringNullableFilter<"Payment"> | string | null
    gatewayPaymentId?: StringNullableFilter<"Payment"> | string | null
    gatewaySignature?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    invoiceUrl?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    failureCode?: StringNullableFilter<"Payment"> | string | null
    refundedAmount?: FloatNullableFilter<"Payment"> | number | null
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    refundReason?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    gatewayProvider?: SortOrder
    gatewayOrderId?: SortOrderInput | SortOrder
    gatewayPaymentId?: SortOrderInput | SortOrder
    gatewaySignature?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    failureCode?: SortOrderInput | SortOrder
    refundedAmount?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    refundReason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    gatewayProvider?: StringFilter<"Payment"> | string
    gatewayOrderId?: StringNullableFilter<"Payment"> | string | null
    gatewayPaymentId?: StringNullableFilter<"Payment"> | string | null
    gatewaySignature?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    invoiceUrl?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    failureCode?: StringNullableFilter<"Payment"> | string | null
    refundedAmount?: FloatNullableFilter<"Payment"> | number | null
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    refundReason?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }, "id" | "transactionId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    gatewayProvider?: SortOrder
    gatewayOrderId?: SortOrderInput | SortOrder
    gatewayPaymentId?: SortOrderInput | SortOrder
    gatewaySignature?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    failureCode?: SortOrderInput | SortOrder
    refundedAmount?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    refundReason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    gatewayProvider?: StringWithAggregatesFilter<"Payment"> | string
    gatewayOrderId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    gatewayPaymentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    gatewaySignature?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    invoiceUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    failureCode?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    refundedAmount?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    refundedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    refundReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
  }

  export type ModelImportWhereInput = {
    AND?: ModelImportWhereInput | ModelImportWhereInput[]
    OR?: ModelImportWhereInput[]
    NOT?: ModelImportWhereInput | ModelImportWhereInput[]
    id?: StringFilter<"ModelImport"> | string
    userId?: StringFilter<"ModelImport"> | string
    projectId?: StringNullableFilter<"ModelImport"> | string | null
    filename?: StringFilter<"ModelImport"> | string
    originalFilename?: StringFilter<"ModelImport"> | string
    fileSize?: IntFilter<"ModelImport"> | number
    fileHash?: StringNullableFilter<"ModelImport"> | string | null
    modelData?: BytesNullableFilter<"ModelImport"> | Buffer | null
    thumbnailData?: BytesNullableFilter<"ModelImport"> | Buffer | null
    status?: EnumImportStatusFilter<"ModelImport"> | $Enums.ImportStatus
    progress?: IntFilter<"ModelImport"> | number
    processingStartedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
    processingCompletedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
    processingDuration?: IntNullableFilter<"ModelImport"> | number | null
    vertexCount?: IntNullableFilter<"ModelImport"> | number | null
    faceCount?: IntNullableFilter<"ModelImport"> | number | null
    boundingBox?: JsonNullableFilter<"ModelImport">
    dimensions?: JsonNullableFilter<"ModelImport">
    volume?: FloatNullableFilter<"ModelImport"> | number | null
    isValid?: BoolFilter<"ModelImport"> | boolean
    validationErrors?: JsonNullableFilter<"ModelImport">
    errorMessage?: StringNullableFilter<"ModelImport"> | string | null
    errorCode?: StringNullableFilter<"ModelImport"> | string | null
    countsTowardLimit?: BoolFilter<"ModelImport"> | boolean
    createdAt?: DateTimeFilter<"ModelImport"> | Date | string
    updatedAt?: DateTimeFilter<"ModelImport"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    errorLogs?: ErrorLogListRelationFilter
  }

  export type ModelImportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileHash?: SortOrderInput | SortOrder
    modelData?: SortOrderInput | SortOrder
    thumbnailData?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    processingCompletedAt?: SortOrderInput | SortOrder
    processingDuration?: SortOrderInput | SortOrder
    vertexCount?: SortOrderInput | SortOrder
    faceCount?: SortOrderInput | SortOrder
    boundingBox?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    isValid?: SortOrder
    validationErrors?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    countsTowardLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    errorLogs?: ErrorLogOrderByRelationAggregateInput
  }

  export type ModelImportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModelImportWhereInput | ModelImportWhereInput[]
    OR?: ModelImportWhereInput[]
    NOT?: ModelImportWhereInput | ModelImportWhereInput[]
    userId?: StringFilter<"ModelImport"> | string
    projectId?: StringNullableFilter<"ModelImport"> | string | null
    filename?: StringFilter<"ModelImport"> | string
    originalFilename?: StringFilter<"ModelImport"> | string
    fileSize?: IntFilter<"ModelImport"> | number
    fileHash?: StringNullableFilter<"ModelImport"> | string | null
    modelData?: BytesNullableFilter<"ModelImport"> | Buffer | null
    thumbnailData?: BytesNullableFilter<"ModelImport"> | Buffer | null
    status?: EnumImportStatusFilter<"ModelImport"> | $Enums.ImportStatus
    progress?: IntFilter<"ModelImport"> | number
    processingStartedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
    processingCompletedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
    processingDuration?: IntNullableFilter<"ModelImport"> | number | null
    vertexCount?: IntNullableFilter<"ModelImport"> | number | null
    faceCount?: IntNullableFilter<"ModelImport"> | number | null
    boundingBox?: JsonNullableFilter<"ModelImport">
    dimensions?: JsonNullableFilter<"ModelImport">
    volume?: FloatNullableFilter<"ModelImport"> | number | null
    isValid?: BoolFilter<"ModelImport"> | boolean
    validationErrors?: JsonNullableFilter<"ModelImport">
    errorMessage?: StringNullableFilter<"ModelImport"> | string | null
    errorCode?: StringNullableFilter<"ModelImport"> | string | null
    countsTowardLimit?: BoolFilter<"ModelImport"> | boolean
    createdAt?: DateTimeFilter<"ModelImport"> | Date | string
    updatedAt?: DateTimeFilter<"ModelImport"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    errorLogs?: ErrorLogListRelationFilter
  }, "id">

  export type ModelImportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileHash?: SortOrderInput | SortOrder
    modelData?: SortOrderInput | SortOrder
    thumbnailData?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    processingCompletedAt?: SortOrderInput | SortOrder
    processingDuration?: SortOrderInput | SortOrder
    vertexCount?: SortOrderInput | SortOrder
    faceCount?: SortOrderInput | SortOrder
    boundingBox?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    isValid?: SortOrder
    validationErrors?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    countsTowardLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ModelImportCountOrderByAggregateInput
    _avg?: ModelImportAvgOrderByAggregateInput
    _max?: ModelImportMaxOrderByAggregateInput
    _min?: ModelImportMinOrderByAggregateInput
    _sum?: ModelImportSumOrderByAggregateInput
  }

  export type ModelImportScalarWhereWithAggregatesInput = {
    AND?: ModelImportScalarWhereWithAggregatesInput | ModelImportScalarWhereWithAggregatesInput[]
    OR?: ModelImportScalarWhereWithAggregatesInput[]
    NOT?: ModelImportScalarWhereWithAggregatesInput | ModelImportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModelImport"> | string
    userId?: StringWithAggregatesFilter<"ModelImport"> | string
    projectId?: StringNullableWithAggregatesFilter<"ModelImport"> | string | null
    filename?: StringWithAggregatesFilter<"ModelImport"> | string
    originalFilename?: StringWithAggregatesFilter<"ModelImport"> | string
    fileSize?: IntWithAggregatesFilter<"ModelImport"> | number
    fileHash?: StringNullableWithAggregatesFilter<"ModelImport"> | string | null
    modelData?: BytesNullableWithAggregatesFilter<"ModelImport"> | Buffer | null
    thumbnailData?: BytesNullableWithAggregatesFilter<"ModelImport"> | Buffer | null
    status?: EnumImportStatusWithAggregatesFilter<"ModelImport"> | $Enums.ImportStatus
    progress?: IntWithAggregatesFilter<"ModelImport"> | number
    processingStartedAt?: DateTimeNullableWithAggregatesFilter<"ModelImport"> | Date | string | null
    processingCompletedAt?: DateTimeNullableWithAggregatesFilter<"ModelImport"> | Date | string | null
    processingDuration?: IntNullableWithAggregatesFilter<"ModelImport"> | number | null
    vertexCount?: IntNullableWithAggregatesFilter<"ModelImport"> | number | null
    faceCount?: IntNullableWithAggregatesFilter<"ModelImport"> | number | null
    boundingBox?: JsonNullableWithAggregatesFilter<"ModelImport">
    dimensions?: JsonNullableWithAggregatesFilter<"ModelImport">
    volume?: FloatNullableWithAggregatesFilter<"ModelImport"> | number | null
    isValid?: BoolWithAggregatesFilter<"ModelImport"> | boolean
    validationErrors?: JsonNullableWithAggregatesFilter<"ModelImport">
    errorMessage?: StringNullableWithAggregatesFilter<"ModelImport"> | string | null
    errorCode?: StringNullableWithAggregatesFilter<"ModelImport"> | string | null
    countsTowardLimit?: BoolWithAggregatesFilter<"ModelImport"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ModelImport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModelImport"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ModelImport"> | Date | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    thumbnailUrl?: StringNullableFilter<"Project"> | string | null
    modelFilename?: StringNullableFilter<"Project"> | string | null
    modelFileType?: StringNullableFilter<"Project"> | string | null
    modelFileSize?: IntNullableFilter<"Project"> | number | null
    supportsCount?: IntFilter<"Project"> | number
    clampsCount?: IntFilter<"Project"> | number
    hasBaseplate?: BoolFilter<"Project"> | boolean
    processingTime?: IntNullableFilter<"Project"> | number | null
    toolingApplied?: JsonNullableFilter<"Project">
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    isPublic?: BoolFilter<"Project"> | boolean
    shareToken?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    lastOpenedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    modelImports?: ModelImportListRelationFilter
    designVersions?: DesignVersionListRelationFilter
    exports?: ExportListRelationFilter
    cloudBackups?: CloudBackupListRelationFilter
    sharedProjects?: SharedProjectListRelationFilter
    errorLogs?: ErrorLogListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    modelFilename?: SortOrderInput | SortOrder
    modelFileType?: SortOrderInput | SortOrder
    modelFileSize?: SortOrderInput | SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    hasBaseplate?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    toolingApplied?: SortOrderInput | SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastOpenedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    modelImports?: ModelImportOrderByRelationAggregateInput
    designVersions?: DesignVersionOrderByRelationAggregateInput
    exports?: ExportOrderByRelationAggregateInput
    cloudBackups?: CloudBackupOrderByRelationAggregateInput
    sharedProjects?: SharedProjectOrderByRelationAggregateInput
    errorLogs?: ErrorLogOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareToken?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    thumbnailUrl?: StringNullableFilter<"Project"> | string | null
    modelFilename?: StringNullableFilter<"Project"> | string | null
    modelFileType?: StringNullableFilter<"Project"> | string | null
    modelFileSize?: IntNullableFilter<"Project"> | number | null
    supportsCount?: IntFilter<"Project"> | number
    clampsCount?: IntFilter<"Project"> | number
    hasBaseplate?: BoolFilter<"Project"> | boolean
    processingTime?: IntNullableFilter<"Project"> | number | null
    toolingApplied?: JsonNullableFilter<"Project">
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    isPublic?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    lastOpenedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    modelImports?: ModelImportListRelationFilter
    designVersions?: DesignVersionListRelationFilter
    exports?: ExportListRelationFilter
    cloudBackups?: CloudBackupListRelationFilter
    sharedProjects?: SharedProjectListRelationFilter
    errorLogs?: ErrorLogListRelationFilter
  }, "id" | "shareToken">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    modelFilename?: SortOrderInput | SortOrder
    modelFileType?: SortOrderInput | SortOrder
    modelFileSize?: SortOrderInput | SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    hasBaseplate?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    toolingApplied?: SortOrderInput | SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastOpenedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    userId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    modelFilename?: StringNullableWithAggregatesFilter<"Project"> | string | null
    modelFileType?: StringNullableWithAggregatesFilter<"Project"> | string | null
    modelFileSize?: IntNullableWithAggregatesFilter<"Project"> | number | null
    supportsCount?: IntWithAggregatesFilter<"Project"> | number
    clampsCount?: IntWithAggregatesFilter<"Project"> | number
    hasBaseplate?: BoolWithAggregatesFilter<"Project"> | boolean
    processingTime?: IntNullableWithAggregatesFilter<"Project"> | number | null
    toolingApplied?: JsonNullableWithAggregatesFilter<"Project">
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    isPublic?: BoolWithAggregatesFilter<"Project"> | boolean
    shareToken?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    lastOpenedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
  }

  export type DesignVersionWhereInput = {
    AND?: DesignVersionWhereInput | DesignVersionWhereInput[]
    OR?: DesignVersionWhereInput[]
    NOT?: DesignVersionWhereInput | DesignVersionWhereInput[]
    id?: StringFilter<"DesignVersion"> | string
    projectId?: StringFilter<"DesignVersion"> | string
    versionNumber?: IntFilter<"DesignVersion"> | number
    name?: StringNullableFilter<"DesignVersion"> | string | null
    description?: StringNullableFilter<"DesignVersion"> | string | null
    thumbnailUrl?: StringNullableFilter<"DesignVersion"> | string | null
    changesSummary?: StringNullableFilter<"DesignVersion"> | string | null
    supportsCount?: IntFilter<"DesignVersion"> | number
    clampsCount?: IntFilter<"DesignVersion"> | number
    isAutoSave?: BoolFilter<"DesignVersion"> | boolean
    createdAt?: DateTimeFilter<"DesignVersion"> | Date | string
    createdBy?: StringNullableFilter<"DesignVersion"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type DesignVersionOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    versionNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    changesSummary?: SortOrderInput | SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    isAutoSave?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type DesignVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_versionNumber?: DesignVersionProjectIdVersionNumberCompoundUniqueInput
    AND?: DesignVersionWhereInput | DesignVersionWhereInput[]
    OR?: DesignVersionWhereInput[]
    NOT?: DesignVersionWhereInput | DesignVersionWhereInput[]
    projectId?: StringFilter<"DesignVersion"> | string
    versionNumber?: IntFilter<"DesignVersion"> | number
    name?: StringNullableFilter<"DesignVersion"> | string | null
    description?: StringNullableFilter<"DesignVersion"> | string | null
    thumbnailUrl?: StringNullableFilter<"DesignVersion"> | string | null
    changesSummary?: StringNullableFilter<"DesignVersion"> | string | null
    supportsCount?: IntFilter<"DesignVersion"> | number
    clampsCount?: IntFilter<"DesignVersion"> | number
    isAutoSave?: BoolFilter<"DesignVersion"> | boolean
    createdAt?: DateTimeFilter<"DesignVersion"> | Date | string
    createdBy?: StringNullableFilter<"DesignVersion"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId_versionNumber">

  export type DesignVersionOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    versionNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    changesSummary?: SortOrderInput | SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    isAutoSave?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: DesignVersionCountOrderByAggregateInput
    _avg?: DesignVersionAvgOrderByAggregateInput
    _max?: DesignVersionMaxOrderByAggregateInput
    _min?: DesignVersionMinOrderByAggregateInput
    _sum?: DesignVersionSumOrderByAggregateInput
  }

  export type DesignVersionScalarWhereWithAggregatesInput = {
    AND?: DesignVersionScalarWhereWithAggregatesInput | DesignVersionScalarWhereWithAggregatesInput[]
    OR?: DesignVersionScalarWhereWithAggregatesInput[]
    NOT?: DesignVersionScalarWhereWithAggregatesInput | DesignVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DesignVersion"> | string
    projectId?: StringWithAggregatesFilter<"DesignVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"DesignVersion"> | number
    name?: StringNullableWithAggregatesFilter<"DesignVersion"> | string | null
    description?: StringNullableWithAggregatesFilter<"DesignVersion"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"DesignVersion"> | string | null
    changesSummary?: StringNullableWithAggregatesFilter<"DesignVersion"> | string | null
    supportsCount?: IntWithAggregatesFilter<"DesignVersion"> | number
    clampsCount?: IntWithAggregatesFilter<"DesignVersion"> | number
    isAutoSave?: BoolWithAggregatesFilter<"DesignVersion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DesignVersion"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"DesignVersion"> | string | null
  }

  export type ExportWhereInput = {
    AND?: ExportWhereInput | ExportWhereInput[]
    OR?: ExportWhereInput[]
    NOT?: ExportWhereInput | ExportWhereInput[]
    id?: StringFilter<"Export"> | string
    projectId?: StringFilter<"Export"> | string
    userId?: StringFilter<"Export"> | string
    format?: EnumExportFormatFilter<"Export"> | $Enums.ExportFormat
    filename?: StringFilter<"Export"> | string
    fileSize?: IntNullableFilter<"Export"> | number | null
    exportData?: BytesNullableFilter<"Export"> | Buffer | null
    fileUrl?: StringNullableFilter<"Export"> | string | null
    settings?: JsonNullableFilter<"Export">
    includeSupports?: BoolFilter<"Export"> | boolean
    includeClamps?: BoolFilter<"Export"> | boolean
    includeBaseplate?: BoolFilter<"Export"> | boolean
    processingTime?: IntNullableFilter<"Export"> | number | null
    status?: EnumExportStatusFilter<"Export"> | $Enums.ExportStatus
    errorMessage?: StringNullableFilter<"Export"> | string | null
    numberOfExportsDone?: IntFilter<"Export"> | number
    downloadCount?: IntFilter<"Export"> | number
    lastDownloadedAt?: DateTimeNullableFilter<"Export"> | Date | string | null
    createdAt?: DateTimeFilter<"Export"> | Date | string
    completedAt?: DateTimeNullableFilter<"Export"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Export"> | Date | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    errorLogs?: ErrorLogListRelationFilter
  }

  export type ExportOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    exportData?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    includeSupports?: SortOrder
    includeClamps?: SortOrder
    includeBaseplate?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    numberOfExportsDone?: SortOrder
    downloadCount?: SortOrder
    lastDownloadedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    errorLogs?: ErrorLogOrderByRelationAggregateInput
  }

  export type ExportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExportWhereInput | ExportWhereInput[]
    OR?: ExportWhereInput[]
    NOT?: ExportWhereInput | ExportWhereInput[]
    projectId?: StringFilter<"Export"> | string
    userId?: StringFilter<"Export"> | string
    format?: EnumExportFormatFilter<"Export"> | $Enums.ExportFormat
    filename?: StringFilter<"Export"> | string
    fileSize?: IntNullableFilter<"Export"> | number | null
    exportData?: BytesNullableFilter<"Export"> | Buffer | null
    fileUrl?: StringNullableFilter<"Export"> | string | null
    settings?: JsonNullableFilter<"Export">
    includeSupports?: BoolFilter<"Export"> | boolean
    includeClamps?: BoolFilter<"Export"> | boolean
    includeBaseplate?: BoolFilter<"Export"> | boolean
    processingTime?: IntNullableFilter<"Export"> | number | null
    status?: EnumExportStatusFilter<"Export"> | $Enums.ExportStatus
    errorMessage?: StringNullableFilter<"Export"> | string | null
    numberOfExportsDone?: IntFilter<"Export"> | number
    downloadCount?: IntFilter<"Export"> | number
    lastDownloadedAt?: DateTimeNullableFilter<"Export"> | Date | string | null
    createdAt?: DateTimeFilter<"Export"> | Date | string
    completedAt?: DateTimeNullableFilter<"Export"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Export"> | Date | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    errorLogs?: ErrorLogListRelationFilter
  }, "id">

  export type ExportOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    exportData?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    includeSupports?: SortOrder
    includeClamps?: SortOrder
    includeBaseplate?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    numberOfExportsDone?: SortOrder
    downloadCount?: SortOrder
    lastDownloadedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ExportCountOrderByAggregateInput
    _avg?: ExportAvgOrderByAggregateInput
    _max?: ExportMaxOrderByAggregateInput
    _min?: ExportMinOrderByAggregateInput
    _sum?: ExportSumOrderByAggregateInput
  }

  export type ExportScalarWhereWithAggregatesInput = {
    AND?: ExportScalarWhereWithAggregatesInput | ExportScalarWhereWithAggregatesInput[]
    OR?: ExportScalarWhereWithAggregatesInput[]
    NOT?: ExportScalarWhereWithAggregatesInput | ExportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Export"> | string
    projectId?: StringWithAggregatesFilter<"Export"> | string
    userId?: StringWithAggregatesFilter<"Export"> | string
    format?: EnumExportFormatWithAggregatesFilter<"Export"> | $Enums.ExportFormat
    filename?: StringWithAggregatesFilter<"Export"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Export"> | number | null
    exportData?: BytesNullableWithAggregatesFilter<"Export"> | Buffer | null
    fileUrl?: StringNullableWithAggregatesFilter<"Export"> | string | null
    settings?: JsonNullableWithAggregatesFilter<"Export">
    includeSupports?: BoolWithAggregatesFilter<"Export"> | boolean
    includeClamps?: BoolWithAggregatesFilter<"Export"> | boolean
    includeBaseplate?: BoolWithAggregatesFilter<"Export"> | boolean
    processingTime?: IntNullableWithAggregatesFilter<"Export"> | number | null
    status?: EnumExportStatusWithAggregatesFilter<"Export"> | $Enums.ExportStatus
    errorMessage?: StringNullableWithAggregatesFilter<"Export"> | string | null
    numberOfExportsDone?: IntWithAggregatesFilter<"Export"> | number
    downloadCount?: IntWithAggregatesFilter<"Export"> | number
    lastDownloadedAt?: DateTimeNullableWithAggregatesFilter<"Export"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Export"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Export"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Export"> | Date | string | null
  }

  export type ErrorLogWhereInput = {
    AND?: ErrorLogWhereInput | ErrorLogWhereInput[]
    OR?: ErrorLogWhereInput[]
    NOT?: ErrorLogWhereInput | ErrorLogWhereInput[]
    id?: StringFilter<"ErrorLog"> | string
    userId?: StringNullableFilter<"ErrorLog"> | string | null
    projectId?: StringNullableFilter<"ErrorLog"> | string | null
    modelImportId?: StringNullableFilter<"ErrorLog"> | string | null
    exportId?: StringNullableFilter<"ErrorLog"> | string | null
    category?: EnumErrorCategoryFilter<"ErrorLog"> | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFilter<"ErrorLog"> | $Enums.ErrorSeverity
    errorCode?: StringFilter<"ErrorLog"> | string
    errorMessage?: StringFilter<"ErrorLog"> | string
    errorStack?: StringNullableFilter<"ErrorLog"> | string | null
    operation?: StringFilter<"ErrorLog"> | string
    step?: StringNullableFilter<"ErrorLog"> | string | null
    browserInfo?: JsonNullableFilter<"ErrorLog">
    deviceInfo?: JsonNullableFilter<"ErrorLog">
    url?: StringNullableFilter<"ErrorLog"> | string | null
    method?: StringNullableFilter<"ErrorLog"> | string | null
    statusCode?: IntNullableFilter<"ErrorLog"> | number | null
    userAction?: StringNullableFilter<"ErrorLog"> | string | null
    resolved?: BoolFilter<"ErrorLog"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ErrorLog"> | Date | string | null
    resolution?: StringNullableFilter<"ErrorLog"> | string | null
    metadata?: JsonNullableFilter<"ErrorLog">
    createdAt?: DateTimeFilter<"ErrorLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    modelImport?: XOR<ModelImportNullableRelationFilter, ModelImportWhereInput> | null
    export?: XOR<ExportNullableRelationFilter, ExportWhereInput> | null
  }

  export type ErrorLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    modelImportId?: SortOrderInput | SortOrder
    exportId?: SortOrderInput | SortOrder
    category?: SortOrder
    severity?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrderInput | SortOrder
    operation?: SortOrder
    step?: SortOrderInput | SortOrder
    browserInfo?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    userAction?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    modelImport?: ModelImportOrderByWithRelationInput
    export?: ExportOrderByWithRelationInput
  }

  export type ErrorLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ErrorLogWhereInput | ErrorLogWhereInput[]
    OR?: ErrorLogWhereInput[]
    NOT?: ErrorLogWhereInput | ErrorLogWhereInput[]
    userId?: StringNullableFilter<"ErrorLog"> | string | null
    projectId?: StringNullableFilter<"ErrorLog"> | string | null
    modelImportId?: StringNullableFilter<"ErrorLog"> | string | null
    exportId?: StringNullableFilter<"ErrorLog"> | string | null
    category?: EnumErrorCategoryFilter<"ErrorLog"> | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFilter<"ErrorLog"> | $Enums.ErrorSeverity
    errorCode?: StringFilter<"ErrorLog"> | string
    errorMessage?: StringFilter<"ErrorLog"> | string
    errorStack?: StringNullableFilter<"ErrorLog"> | string | null
    operation?: StringFilter<"ErrorLog"> | string
    step?: StringNullableFilter<"ErrorLog"> | string | null
    browserInfo?: JsonNullableFilter<"ErrorLog">
    deviceInfo?: JsonNullableFilter<"ErrorLog">
    url?: StringNullableFilter<"ErrorLog"> | string | null
    method?: StringNullableFilter<"ErrorLog"> | string | null
    statusCode?: IntNullableFilter<"ErrorLog"> | number | null
    userAction?: StringNullableFilter<"ErrorLog"> | string | null
    resolved?: BoolFilter<"ErrorLog"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ErrorLog"> | Date | string | null
    resolution?: StringNullableFilter<"ErrorLog"> | string | null
    metadata?: JsonNullableFilter<"ErrorLog">
    createdAt?: DateTimeFilter<"ErrorLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    modelImport?: XOR<ModelImportNullableRelationFilter, ModelImportWhereInput> | null
    export?: XOR<ExportNullableRelationFilter, ExportWhereInput> | null
  }, "id">

  export type ErrorLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    modelImportId?: SortOrderInput | SortOrder
    exportId?: SortOrderInput | SortOrder
    category?: SortOrder
    severity?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrderInput | SortOrder
    operation?: SortOrder
    step?: SortOrderInput | SortOrder
    browserInfo?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    userAction?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ErrorLogCountOrderByAggregateInput
    _avg?: ErrorLogAvgOrderByAggregateInput
    _max?: ErrorLogMaxOrderByAggregateInput
    _min?: ErrorLogMinOrderByAggregateInput
    _sum?: ErrorLogSumOrderByAggregateInput
  }

  export type ErrorLogScalarWhereWithAggregatesInput = {
    AND?: ErrorLogScalarWhereWithAggregatesInput | ErrorLogScalarWhereWithAggregatesInput[]
    OR?: ErrorLogScalarWhereWithAggregatesInput[]
    NOT?: ErrorLogScalarWhereWithAggregatesInput | ErrorLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ErrorLog"> | string
    userId?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    modelImportId?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    exportId?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    category?: EnumErrorCategoryWithAggregatesFilter<"ErrorLog"> | $Enums.ErrorCategory
    severity?: EnumErrorSeverityWithAggregatesFilter<"ErrorLog"> | $Enums.ErrorSeverity
    errorCode?: StringWithAggregatesFilter<"ErrorLog"> | string
    errorMessage?: StringWithAggregatesFilter<"ErrorLog"> | string
    errorStack?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    operation?: StringWithAggregatesFilter<"ErrorLog"> | string
    step?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    browserInfo?: JsonNullableWithAggregatesFilter<"ErrorLog">
    deviceInfo?: JsonNullableWithAggregatesFilter<"ErrorLog">
    url?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    method?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    statusCode?: IntNullableWithAggregatesFilter<"ErrorLog"> | number | null
    userAction?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    resolved?: BoolWithAggregatesFilter<"ErrorLog"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ErrorLog"> | Date | string | null
    resolution?: StringNullableWithAggregatesFilter<"ErrorLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ErrorLog">
    createdAt?: DateTimeWithAggregatesFilter<"ErrorLog"> | Date | string
  }

  export type SharedProjectWhereInput = {
    AND?: SharedProjectWhereInput | SharedProjectWhereInput[]
    OR?: SharedProjectWhereInput[]
    NOT?: SharedProjectWhereInput | SharedProjectWhereInput[]
    id?: StringFilter<"SharedProject"> | string
    projectId?: StringFilter<"SharedProject"> | string
    sharedBy?: StringFilter<"SharedProject"> | string
    sharedWith?: StringNullableFilter<"SharedProject"> | string | null
    permission?: StringFilter<"SharedProject"> | string
    shareType?: StringFilter<"SharedProject"> | string
    shareToken?: StringNullableFilter<"SharedProject"> | string | null
    accepted?: BoolFilter<"SharedProject"> | boolean
    revoked?: BoolFilter<"SharedProject"> | boolean
    createdAt?: DateTimeFilter<"SharedProject"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    sharedByUser?: XOR<UserRelationFilter, UserWhereInput>
    sharedWithUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SharedProjectOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrderInput | SortOrder
    permission?: SortOrder
    shareType?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    accepted?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    sharedByUser?: UserOrderByWithRelationInput
    sharedWithUser?: UserOrderByWithRelationInput
  }

  export type SharedProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareToken?: string
    AND?: SharedProjectWhereInput | SharedProjectWhereInput[]
    OR?: SharedProjectWhereInput[]
    NOT?: SharedProjectWhereInput | SharedProjectWhereInput[]
    projectId?: StringFilter<"SharedProject"> | string
    sharedBy?: StringFilter<"SharedProject"> | string
    sharedWith?: StringNullableFilter<"SharedProject"> | string | null
    permission?: StringFilter<"SharedProject"> | string
    shareType?: StringFilter<"SharedProject"> | string
    accepted?: BoolFilter<"SharedProject"> | boolean
    revoked?: BoolFilter<"SharedProject"> | boolean
    createdAt?: DateTimeFilter<"SharedProject"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    sharedByUser?: XOR<UserRelationFilter, UserWhereInput>
    sharedWithUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "shareToken">

  export type SharedProjectOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrderInput | SortOrder
    permission?: SortOrder
    shareType?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    accepted?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: SharedProjectCountOrderByAggregateInput
    _max?: SharedProjectMaxOrderByAggregateInput
    _min?: SharedProjectMinOrderByAggregateInput
  }

  export type SharedProjectScalarWhereWithAggregatesInput = {
    AND?: SharedProjectScalarWhereWithAggregatesInput | SharedProjectScalarWhereWithAggregatesInput[]
    OR?: SharedProjectScalarWhereWithAggregatesInput[]
    NOT?: SharedProjectScalarWhereWithAggregatesInput | SharedProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharedProject"> | string
    projectId?: StringWithAggregatesFilter<"SharedProject"> | string
    sharedBy?: StringWithAggregatesFilter<"SharedProject"> | string
    sharedWith?: StringNullableWithAggregatesFilter<"SharedProject"> | string | null
    permission?: StringWithAggregatesFilter<"SharedProject"> | string
    shareType?: StringWithAggregatesFilter<"SharedProject"> | string
    shareToken?: StringNullableWithAggregatesFilter<"SharedProject"> | string | null
    accepted?: BoolWithAggregatesFilter<"SharedProject"> | boolean
    revoked?: BoolWithAggregatesFilter<"SharedProject"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SharedProject"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"SharedProject"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"SharedProject"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SharedProject"> | Date | string | null
  }

  export type CloudBackupWhereInput = {
    AND?: CloudBackupWhereInput | CloudBackupWhereInput[]
    OR?: CloudBackupWhereInput[]
    NOT?: CloudBackupWhereInput | CloudBackupWhereInput[]
    id?: StringFilter<"CloudBackup"> | string
    projectId?: StringFilter<"CloudBackup"> | string
    userId?: StringFilter<"CloudBackup"> | string
    backupName?: StringNullableFilter<"CloudBackup"> | string | null
    compressedData?: BytesNullableFilter<"CloudBackup"> | Buffer | null
    fileSize?: IntFilter<"CloudBackup"> | number
    checksum?: StringFilter<"CloudBackup"> | string
    compressionType?: StringFilter<"CloudBackup"> | string
    originalSize?: IntNullableFilter<"CloudBackup"> | number | null
    metadata?: JsonNullableFilter<"CloudBackup">
    createdAt?: DateTimeFilter<"CloudBackup"> | Date | string
    accessedAt?: DateTimeNullableFilter<"CloudBackup"> | Date | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CloudBackupOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    backupName?: SortOrderInput | SortOrder
    compressedData?: SortOrderInput | SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    compressionType?: SortOrder
    originalSize?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    accessedAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CloudBackupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CloudBackupWhereInput | CloudBackupWhereInput[]
    OR?: CloudBackupWhereInput[]
    NOT?: CloudBackupWhereInput | CloudBackupWhereInput[]
    projectId?: StringFilter<"CloudBackup"> | string
    userId?: StringFilter<"CloudBackup"> | string
    backupName?: StringNullableFilter<"CloudBackup"> | string | null
    compressedData?: BytesNullableFilter<"CloudBackup"> | Buffer | null
    fileSize?: IntFilter<"CloudBackup"> | number
    checksum?: StringFilter<"CloudBackup"> | string
    compressionType?: StringFilter<"CloudBackup"> | string
    originalSize?: IntNullableFilter<"CloudBackup"> | number | null
    metadata?: JsonNullableFilter<"CloudBackup">
    createdAt?: DateTimeFilter<"CloudBackup"> | Date | string
    accessedAt?: DateTimeNullableFilter<"CloudBackup"> | Date | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CloudBackupOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    backupName?: SortOrderInput | SortOrder
    compressedData?: SortOrderInput | SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    compressionType?: SortOrder
    originalSize?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    accessedAt?: SortOrderInput | SortOrder
    _count?: CloudBackupCountOrderByAggregateInput
    _avg?: CloudBackupAvgOrderByAggregateInput
    _max?: CloudBackupMaxOrderByAggregateInput
    _min?: CloudBackupMinOrderByAggregateInput
    _sum?: CloudBackupSumOrderByAggregateInput
  }

  export type CloudBackupScalarWhereWithAggregatesInput = {
    AND?: CloudBackupScalarWhereWithAggregatesInput | CloudBackupScalarWhereWithAggregatesInput[]
    OR?: CloudBackupScalarWhereWithAggregatesInput[]
    NOT?: CloudBackupScalarWhereWithAggregatesInput | CloudBackupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CloudBackup"> | string
    projectId?: StringWithAggregatesFilter<"CloudBackup"> | string
    userId?: StringWithAggregatesFilter<"CloudBackup"> | string
    backupName?: StringNullableWithAggregatesFilter<"CloudBackup"> | string | null
    compressedData?: BytesNullableWithAggregatesFilter<"CloudBackup"> | Buffer | null
    fileSize?: IntWithAggregatesFilter<"CloudBackup"> | number
    checksum?: StringWithAggregatesFilter<"CloudBackup"> | string
    compressionType?: StringWithAggregatesFilter<"CloudBackup"> | string
    originalSize?: IntNullableWithAggregatesFilter<"CloudBackup"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"CloudBackup">
    createdAt?: DateTimeWithAggregatesFilter<"CloudBackup"> | Date | string
    accessedAt?: DateTimeNullableWithAggregatesFilter<"CloudBackup"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    status?: StringWithAggregatesFilter<"AuditLog"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NumExportsWhereInput = {
    AND?: NumExportsWhereInput | NumExportsWhereInput[]
    OR?: NumExportsWhereInput[]
    NOT?: NumExportsWhereInput | NumExportsWhereInput[]
    id?: StringFilter<"NumExports"> | string
    userId?: StringFilter<"NumExports"> | string
    exports?: IntFilter<"NumExports"> | number
    updatedAt?: DateTimeFilter<"NumExports"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NumExportsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    exports?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NumExportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NumExportsWhereInput | NumExportsWhereInput[]
    OR?: NumExportsWhereInput[]
    NOT?: NumExportsWhereInput | NumExportsWhereInput[]
    exports?: IntFilter<"NumExports"> | number
    updatedAt?: DateTimeFilter<"NumExports"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NumExportsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    exports?: SortOrder
    updatedAt?: SortOrder
    _count?: NumExportsCountOrderByAggregateInput
    _avg?: NumExportsAvgOrderByAggregateInput
    _max?: NumExportsMaxOrderByAggregateInput
    _min?: NumExportsMinOrderByAggregateInput
    _sum?: NumExportsSumOrderByAggregateInput
  }

  export type NumExportsScalarWhereWithAggregatesInput = {
    AND?: NumExportsScalarWhereWithAggregatesInput | NumExportsScalarWhereWithAggregatesInput[]
    OR?: NumExportsScalarWhereWithAggregatesInput[]
    NOT?: NumExportsScalarWhereWithAggregatesInput | NumExportsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NumExports"> | string
    userId?: StringWithAggregatesFilter<"NumExports"> | string
    exports?: IntWithAggregatesFilter<"NumExports"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"NumExports"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    replacedByToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    replacedByToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    replacedByToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseCreateInput = {
    id?: string
    licenseType: $Enums.LicenseType
    status?: $Enums.LicenseStatus
    dateStart: Date | string
    dateEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLicenseInput
  }

  export type LicenseUncheckedCreateInput = {
    id?: string
    userId: string
    licenseType: $Enums.LicenseType
    status?: $Enums.LicenseStatus
    dateStart: Date | string
    dateEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseType?: EnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLicenseNestedInput
  }

  export type LicenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    licenseType?: EnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseCreateManyInput = {
    id?: string
    userId: string
    licenseType: $Enums.LicenseType
    status?: $Enums.LicenseStatus
    dateStart: Date | string
    dateEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseType?: EnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    licenseType?: EnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    tier: $Enums.UserTier
    status?: $Enums.SubscriptionStatus
    billingCycle: string
    amount: number
    currency?: string
    modelLimit: number
    startDate: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    autoRenew?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    tier: $Enums.UserTier
    status?: $Enums.SubscriptionStatus
    billingCycle: string
    amount: number
    currency?: string
    modelLimit: number
    startDate: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    autoRenew?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    modelLimit?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    modelLimit?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    tier: $Enums.UserTier
    status?: $Enums.SubscriptionStatus
    billingCycle: string
    amount: number
    currency?: string
    modelLimit: number
    startDate: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    autoRenew?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    modelLimit?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    modelLimit?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelImportCreateInput = {
    id?: string
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutModelImportsInput
    project?: ProjectCreateNestedOneWithoutModelImportsInput
    errorLogs?: ErrorLogCreateNestedManyWithoutModelImportInput
  }

  export type ModelImportUncheckedCreateInput = {
    id?: string
    userId: string
    projectId?: string | null
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutModelImportInput
  }

  export type ModelImportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutModelImportsNestedInput
    project?: ProjectUpdateOneWithoutModelImportsNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutModelImportNestedInput
  }

  export type ModelImportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutModelImportNestedInput
  }

  export type ModelImportCreateManyInput = {
    id?: string
    userId: string
    projectId?: string | null
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ModelImportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelImportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectsInput
    modelImports?: ModelImportCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionCreateNestedManyWithoutProjectInput
    exports?: ExportCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutProjectInput
    exports?: ExportUncheckedCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    modelImports?: ModelImportUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUpdateManyWithoutProjectNestedInput
    exports?: ExportUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelImports?: ModelImportUncheckedUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutProjectNestedInput
    exports?: ExportUncheckedUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignVersionCreateInput = {
    id?: string
    versionNumber: number
    name?: string | null
    description?: string | null
    thumbnailUrl?: string | null
    changesSummary?: string | null
    supportsCount?: number
    clampsCount?: number
    isAutoSave?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    project: ProjectCreateNestedOneWithoutDesignVersionsInput
  }

  export type DesignVersionUncheckedCreateInput = {
    id?: string
    projectId: string
    versionNumber: number
    name?: string | null
    description?: string | null
    thumbnailUrl?: string | null
    changesSummary?: string | null
    supportsCount?: number
    clampsCount?: number
    isAutoSave?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type DesignVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    changesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    isAutoSave?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutDesignVersionsNestedInput
  }

  export type DesignVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    changesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    isAutoSave?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DesignVersionCreateManyInput = {
    id?: string
    projectId: string
    versionNumber: number
    name?: string | null
    description?: string | null
    thumbnailUrl?: string | null
    changesSummary?: string | null
    supportsCount?: number
    clampsCount?: number
    isAutoSave?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type DesignVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    changesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    isAutoSave?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DesignVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    changesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    isAutoSave?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportCreateInput = {
    id?: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutExportsInput
    user: UserCreateNestedOneWithoutExportsInput
    errorLogs?: ErrorLogCreateNestedManyWithoutExportInput
  }

  export type ExportUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutExportInput
  }

  export type ExportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutExportsNestedInput
    user?: UserUpdateOneRequiredWithoutExportsNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutExportNestedInput
  }

  export type ExportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutExportNestedInput
  }

  export type ExportCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type ExportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ErrorLogCreateInput = {
    id?: string
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutErrorLogsInput
    project?: ProjectCreateNestedOneWithoutErrorLogsInput
    modelImport?: ModelImportCreateNestedOneWithoutErrorLogsInput
    export?: ExportCreateNestedOneWithoutErrorLogsInput
  }

  export type ErrorLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    projectId?: string | null
    modelImportId?: string | null
    exportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ErrorLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutErrorLogsNestedInput
    project?: ProjectUpdateOneWithoutErrorLogsNestedInput
    modelImport?: ModelImportUpdateOneWithoutErrorLogsNestedInput
    export?: ExportUpdateOneWithoutErrorLogsNestedInput
  }

  export type ErrorLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelImportId?: NullableStringFieldUpdateOperationsInput | string | null
    exportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorLogCreateManyInput = {
    id?: string
    userId?: string | null
    projectId?: string | null
    modelImportId?: string | null
    exportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ErrorLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelImportId?: NullableStringFieldUpdateOperationsInput | string | null
    exportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedProjectCreateInput = {
    id?: string
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutSharedProjectsInput
    sharedByUser: UserCreateNestedOneWithoutSharedProjectsInput
    sharedWithUser?: UserCreateNestedOneWithoutReceivedSharesInput
  }

  export type SharedProjectUncheckedCreateInput = {
    id?: string
    projectId: string
    sharedBy: string
    sharedWith?: string | null
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type SharedProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutSharedProjectsNestedInput
    sharedByUser?: UserUpdateOneRequiredWithoutSharedProjectsNestedInput
    sharedWithUser?: UserUpdateOneWithoutReceivedSharesNestedInput
  }

  export type SharedProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedProjectCreateManyInput = {
    id?: string
    projectId: string
    sharedBy: string
    sharedWith?: string | null
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type SharedProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CloudBackupCreateInput = {
    id?: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutCloudBackupsInput
    user: UserCreateNestedOneWithoutCloudBackupsInput
  }

  export type CloudBackupUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
  }

  export type CloudBackupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutCloudBackupsNestedInput
    user?: UserUpdateOneRequiredWithoutCloudBackupsNestedInput
  }

  export type CloudBackupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CloudBackupCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
  }

  export type CloudBackupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CloudBackupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    status: string
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    status: string
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    status: string
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NumExportsCreateInput = {
    id?: string
    exports?: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNumExportsInput
  }

  export type NumExportsUncheckedCreateInput = {
    id?: string
    userId: string
    exports?: number
    updatedAt?: Date | string
  }

  export type NumExportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exports?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNumExportsNestedInput
  }

  export type NumExportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exports?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NumExportsCreateManyInput = {
    id?: string
    userId: string
    exports?: number
    updatedAt?: Date | string
  }

  export type NumExportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exports?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NumExportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exports?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserTierFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierFilter<$PrismaModel> | $Enums.UserTier
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type LicenseNullableRelationFilter = {
    is?: LicenseWhereInput | null
    isNot?: LicenseWhereInput | null
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ModelImportListRelationFilter = {
    every?: ModelImportWhereInput
    some?: ModelImportWhereInput
    none?: ModelImportWhereInput
  }

  export type ExportListRelationFilter = {
    every?: ExportWhereInput
    some?: ExportWhereInput
    none?: ExportWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ErrorLogListRelationFilter = {
    every?: ErrorLogWhereInput
    some?: ErrorLogWhereInput
    none?: ErrorLogWhereInput
  }

  export type CloudBackupListRelationFilter = {
    every?: CloudBackupWhereInput
    some?: CloudBackupWhereInput
    none?: CloudBackupWhereInput
  }

  export type SharedProjectListRelationFilter = {
    every?: SharedProjectWhereInput
    some?: SharedProjectWhereInput
    none?: SharedProjectWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NumExportsNullableRelationFilter = {
    is?: NumExportsWhereInput | null
    isNot?: NumExportsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelImportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ErrorLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CloudBackupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiry?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    organization?: SortOrder
    jobTitle?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    tier?: SortOrder
    modelLimit?: SortOrder
    modelsUsed?: SortOrder
    timeSpent?: SortOrder
    maxStepReached?: SortOrder
    lastSessionFinalStep?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    avatarUrl?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    modelLimit?: SortOrder
    modelsUsed?: SortOrder
    timeSpent?: SortOrder
    maxStepReached?: SortOrder
    lastSessionFinalStep?: SortOrder
    failedLoginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiry?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    organization?: SortOrder
    jobTitle?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    tier?: SortOrder
    modelLimit?: SortOrder
    modelsUsed?: SortOrder
    timeSpent?: SortOrder
    maxStepReached?: SortOrder
    lastSessionFinalStep?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiry?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiry?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    organization?: SortOrder
    jobTitle?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    tier?: SortOrder
    modelLimit?: SortOrder
    modelsUsed?: SortOrder
    timeSpent?: SortOrder
    maxStepReached?: SortOrder
    lastSessionFinalStep?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    modelLimit?: SortOrder
    modelsUsed?: SortOrder
    timeSpent?: SortOrder
    maxStepReached?: SortOrder
    lastSessionFinalStep?: SortOrder
    failedLoginAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierWithAggregatesFilter<$PrismaModel> | $Enums.UserTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTierFilter<$PrismaModel>
    _max?: NestedEnumUserTierFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrder
    replacedByToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrder
    replacedByToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    revokedAt?: SortOrder
    replacedByToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLicenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseType | EnumLicenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseTypeFilter<$PrismaModel> | $Enums.LicenseType
  }

  export type EnumLicenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseStatusFilter<$PrismaModel> | $Enums.LicenseStatus
  }

  export type LicenseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseType?: SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LicenseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseType?: SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LicenseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseType?: SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLicenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseType | EnumLicenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.LicenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseTypeFilter<$PrismaModel>
    _max?: NestedEnumLicenseTypeFilter<$PrismaModel>
  }

  export type EnumLicenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LicenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseStatusFilter<$PrismaModel>
    _max?: NestedEnumLicenseStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    modelLimit?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    cancelledAt?: SortOrder
    autoRenew?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    amount?: SortOrder
    modelLimit?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    modelLimit?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    cancelledAt?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    modelLimit?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    cancelledAt?: SortOrder
    autoRenew?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    amount?: SortOrder
    modelLimit?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    gatewayProvider?: SortOrder
    gatewayOrderId?: SortOrder
    gatewayPaymentId?: SortOrder
    gatewaySignature?: SortOrder
    transactionId?: SortOrder
    receiptUrl?: SortOrder
    invoiceUrl?: SortOrder
    failureReason?: SortOrder
    failureCode?: SortOrder
    refundedAmount?: SortOrder
    refundedAt?: SortOrder
    refundReason?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    refundedAmount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    gatewayProvider?: SortOrder
    gatewayOrderId?: SortOrder
    gatewayPaymentId?: SortOrder
    gatewaySignature?: SortOrder
    transactionId?: SortOrder
    receiptUrl?: SortOrder
    invoiceUrl?: SortOrder
    failureReason?: SortOrder
    failureCode?: SortOrder
    refundedAmount?: SortOrder
    refundedAt?: SortOrder
    refundReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    gatewayProvider?: SortOrder
    gatewayOrderId?: SortOrder
    gatewayPaymentId?: SortOrder
    gatewaySignature?: SortOrder
    transactionId?: SortOrder
    receiptUrl?: SortOrder
    invoiceUrl?: SortOrder
    failureReason?: SortOrder
    failureCode?: SortOrder
    refundedAmount?: SortOrder
    refundedAt?: SortOrder
    refundReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    refundedAmount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type EnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type ModelImportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileHash?: SortOrder
    modelData?: SortOrder
    thumbnailData?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    processingStartedAt?: SortOrder
    processingCompletedAt?: SortOrder
    processingDuration?: SortOrder
    vertexCount?: SortOrder
    faceCount?: SortOrder
    boundingBox?: SortOrder
    dimensions?: SortOrder
    volume?: SortOrder
    isValid?: SortOrder
    validationErrors?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    countsTowardLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ModelImportAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    progress?: SortOrder
    processingDuration?: SortOrder
    vertexCount?: SortOrder
    faceCount?: SortOrder
    volume?: SortOrder
  }

  export type ModelImportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileHash?: SortOrder
    modelData?: SortOrder
    thumbnailData?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    processingStartedAt?: SortOrder
    processingCompletedAt?: SortOrder
    processingDuration?: SortOrder
    vertexCount?: SortOrder
    faceCount?: SortOrder
    volume?: SortOrder
    isValid?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    countsTowardLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ModelImportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileSize?: SortOrder
    fileHash?: SortOrder
    modelData?: SortOrder
    thumbnailData?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    processingStartedAt?: SortOrder
    processingCompletedAt?: SortOrder
    processingDuration?: SortOrder
    vertexCount?: SortOrder
    faceCount?: SortOrder
    volume?: SortOrder
    isValid?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    countsTowardLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ModelImportSumOrderByAggregateInput = {
    fileSize?: SortOrder
    progress?: SortOrder
    processingDuration?: SortOrder
    vertexCount?: SortOrder
    faceCount?: SortOrder
    volume?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type EnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type DesignVersionListRelationFilter = {
    every?: DesignVersionWhereInput
    some?: DesignVersionWhereInput
    none?: DesignVersionWhereInput
  }

  export type DesignVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    modelFilename?: SortOrder
    modelFileType?: SortOrder
    modelFileSize?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    hasBaseplate?: SortOrder
    processingTime?: SortOrder
    toolingApplied?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastOpenedAt?: SortOrder
    completedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    modelFileSize?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    processingTime?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    modelFilename?: SortOrder
    modelFileType?: SortOrder
    modelFileSize?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    hasBaseplate?: SortOrder
    processingTime?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastOpenedAt?: SortOrder
    completedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    modelFilename?: SortOrder
    modelFileType?: SortOrder
    modelFileSize?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    hasBaseplate?: SortOrder
    processingTime?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastOpenedAt?: SortOrder
    completedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    modelFileSize?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    processingTime?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type DesignVersionProjectIdVersionNumberCompoundUniqueInput = {
    projectId: string
    versionNumber: number
  }

  export type DesignVersionCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    versionNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    changesSummary?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    isAutoSave?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DesignVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
  }

  export type DesignVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    versionNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    changesSummary?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    isAutoSave?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DesignVersionMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    versionNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    thumbnailUrl?: SortOrder
    changesSummary?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
    isAutoSave?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DesignVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
    supportsCount?: SortOrder
    clampsCount?: SortOrder
  }

  export type EnumExportFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportFormat | EnumExportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumExportFormatFilter<$PrismaModel> | $Enums.ExportFormat
  }

  export type EnumExportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportStatus | EnumExportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExportStatus[] | ListEnumExportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportStatus[] | ListEnumExportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExportStatusFilter<$PrismaModel> | $Enums.ExportStatus
  }

  export type ExportCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    exportData?: SortOrder
    fileUrl?: SortOrder
    settings?: SortOrder
    includeSupports?: SortOrder
    includeClamps?: SortOrder
    includeBaseplate?: SortOrder
    processingTime?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    numberOfExportsDone?: SortOrder
    downloadCount?: SortOrder
    lastDownloadedAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ExportAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    processingTime?: SortOrder
    numberOfExportsDone?: SortOrder
    downloadCount?: SortOrder
  }

  export type ExportMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    exportData?: SortOrder
    fileUrl?: SortOrder
    includeSupports?: SortOrder
    includeClamps?: SortOrder
    includeBaseplate?: SortOrder
    processingTime?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    numberOfExportsDone?: SortOrder
    downloadCount?: SortOrder
    lastDownloadedAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ExportMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    exportData?: SortOrder
    fileUrl?: SortOrder
    includeSupports?: SortOrder
    includeClamps?: SortOrder
    includeBaseplate?: SortOrder
    processingTime?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    numberOfExportsDone?: SortOrder
    downloadCount?: SortOrder
    lastDownloadedAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ExportSumOrderByAggregateInput = {
    fileSize?: SortOrder
    processingTime?: SortOrder
    numberOfExportsDone?: SortOrder
    downloadCount?: SortOrder
  }

  export type EnumExportFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportFormat | EnumExportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumExportFormatWithAggregatesFilter<$PrismaModel> | $Enums.ExportFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExportFormatFilter<$PrismaModel>
    _max?: NestedEnumExportFormatFilter<$PrismaModel>
  }

  export type EnumExportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportStatus | EnumExportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExportStatus[] | ListEnumExportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportStatus[] | ListEnumExportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExportStatusFilter<$PrismaModel>
    _max?: NestedEnumExportStatusFilter<$PrismaModel>
  }

  export type EnumErrorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorCategory | EnumErrorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorCategory[] | ListEnumErrorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ErrorCategory[] | ListEnumErrorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumErrorCategoryFilter<$PrismaModel> | $Enums.ErrorCategory
  }

  export type EnumErrorSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorSeverity | EnumErrorSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorSeverity[] | ListEnumErrorSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ErrorSeverity[] | ListEnumErrorSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumErrorSeverityFilter<$PrismaModel> | $Enums.ErrorSeverity
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ModelImportNullableRelationFilter = {
    is?: ModelImportWhereInput | null
    isNot?: ModelImportWhereInput | null
  }

  export type ExportNullableRelationFilter = {
    is?: ExportWhereInput | null
    isNot?: ExportWhereInput | null
  }

  export type ErrorLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    modelImportId?: SortOrder
    exportId?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    operation?: SortOrder
    step?: SortOrder
    browserInfo?: SortOrder
    deviceInfo?: SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    userAction?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolution?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ErrorLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
  }

  export type ErrorLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    modelImportId?: SortOrder
    exportId?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    operation?: SortOrder
    step?: SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    userAction?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
  }

  export type ErrorLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    modelImportId?: SortOrder
    exportId?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    operation?: SortOrder
    step?: SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    userAction?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
  }

  export type ErrorLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
  }

  export type EnumErrorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorCategory | EnumErrorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorCategory[] | ListEnumErrorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ErrorCategory[] | ListEnumErrorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumErrorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ErrorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumErrorCategoryFilter<$PrismaModel>
    _max?: NestedEnumErrorCategoryFilter<$PrismaModel>
  }

  export type EnumErrorSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorSeverity | EnumErrorSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorSeverity[] | ListEnumErrorSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ErrorSeverity[] | ListEnumErrorSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumErrorSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ErrorSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumErrorSeverityFilter<$PrismaModel>
    _max?: NestedEnumErrorSeverityFilter<$PrismaModel>
  }

  export type SharedProjectCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permission?: SortOrder
    shareType?: SortOrder
    shareToken?: SortOrder
    accepted?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SharedProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permission?: SortOrder
    shareType?: SortOrder
    shareToken?: SortOrder
    accepted?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SharedProjectMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permission?: SortOrder
    shareType?: SortOrder
    shareToken?: SortOrder
    accepted?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    acceptedAt?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CloudBackupCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    backupName?: SortOrder
    compressedData?: SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    compressionType?: SortOrder
    originalSize?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    accessedAt?: SortOrder
  }

  export type CloudBackupAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    originalSize?: SortOrder
  }

  export type CloudBackupMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    backupName?: SortOrder
    compressedData?: SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    compressionType?: SortOrder
    originalSize?: SortOrder
    createdAt?: SortOrder
    accessedAt?: SortOrder
  }

  export type CloudBackupMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    backupName?: SortOrder
    compressedData?: SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    compressionType?: SortOrder
    originalSize?: SortOrder
    createdAt?: SortOrder
    accessedAt?: SortOrder
  }

  export type CloudBackupSumOrderByAggregateInput = {
    fileSize?: SortOrder
    originalSize?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type NumExportsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exports?: SortOrder
    updatedAt?: SortOrder
  }

  export type NumExportsAvgOrderByAggregateInput = {
    exports?: SortOrder
  }

  export type NumExportsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exports?: SortOrder
    updatedAt?: SortOrder
  }

  export type NumExportsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exports?: SortOrder
    updatedAt?: SortOrder
  }

  export type NumExportsSumOrderByAggregateInput = {
    exports?: SortOrder
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type LicenseCreateNestedOneWithoutUserInput = {
    create?: XOR<LicenseCreateWithoutUserInput, LicenseUncheckedCreateWithoutUserInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutUserInput
    connect?: LicenseWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ModelImportCreateNestedManyWithoutUserInput = {
    create?: XOR<ModelImportCreateWithoutUserInput, ModelImportUncheckedCreateWithoutUserInput> | ModelImportCreateWithoutUserInput[] | ModelImportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModelImportCreateOrConnectWithoutUserInput | ModelImportCreateOrConnectWithoutUserInput[]
    createMany?: ModelImportCreateManyUserInputEnvelope
    connect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
  }

  export type ExportCreateNestedManyWithoutUserInput = {
    create?: XOR<ExportCreateWithoutUserInput, ExportUncheckedCreateWithoutUserInput> | ExportCreateWithoutUserInput[] | ExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExportCreateOrConnectWithoutUserInput | ExportCreateOrConnectWithoutUserInput[]
    createMany?: ExportCreateManyUserInputEnvelope
    connect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ErrorLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ErrorLogCreateWithoutUserInput, ErrorLogUncheckedCreateWithoutUserInput> | ErrorLogCreateWithoutUserInput[] | ErrorLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutUserInput | ErrorLogCreateOrConnectWithoutUserInput[]
    createMany?: ErrorLogCreateManyUserInputEnvelope
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
  }

  export type CloudBackupCreateNestedManyWithoutUserInput = {
    create?: XOR<CloudBackupCreateWithoutUserInput, CloudBackupUncheckedCreateWithoutUserInput> | CloudBackupCreateWithoutUserInput[] | CloudBackupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CloudBackupCreateOrConnectWithoutUserInput | CloudBackupCreateOrConnectWithoutUserInput[]
    createMany?: CloudBackupCreateManyUserInputEnvelope
    connect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
  }

  export type SharedProjectCreateNestedManyWithoutSharedByUserInput = {
    create?: XOR<SharedProjectCreateWithoutSharedByUserInput, SharedProjectUncheckedCreateWithoutSharedByUserInput> | SharedProjectCreateWithoutSharedByUserInput[] | SharedProjectUncheckedCreateWithoutSharedByUserInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutSharedByUserInput | SharedProjectCreateOrConnectWithoutSharedByUserInput[]
    createMany?: SharedProjectCreateManySharedByUserInputEnvelope
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
  }

  export type SharedProjectCreateNestedManyWithoutSharedWithUserInput = {
    create?: XOR<SharedProjectCreateWithoutSharedWithUserInput, SharedProjectUncheckedCreateWithoutSharedWithUserInput> | SharedProjectCreateWithoutSharedWithUserInput[] | SharedProjectUncheckedCreateWithoutSharedWithUserInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutSharedWithUserInput | SharedProjectCreateOrConnectWithoutSharedWithUserInput[]
    createMany?: SharedProjectCreateManySharedWithUserInputEnvelope
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NumExportsCreateNestedOneWithoutUserInput = {
    create?: XOR<NumExportsCreateWithoutUserInput, NumExportsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NumExportsCreateOrConnectWithoutUserInput
    connect?: NumExportsWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type LicenseUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LicenseCreateWithoutUserInput, LicenseUncheckedCreateWithoutUserInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutUserInput
    connect?: LicenseWhereUniqueInput
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ModelImportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ModelImportCreateWithoutUserInput, ModelImportUncheckedCreateWithoutUserInput> | ModelImportCreateWithoutUserInput[] | ModelImportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModelImportCreateOrConnectWithoutUserInput | ModelImportCreateOrConnectWithoutUserInput[]
    createMany?: ModelImportCreateManyUserInputEnvelope
    connect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
  }

  export type ExportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExportCreateWithoutUserInput, ExportUncheckedCreateWithoutUserInput> | ExportCreateWithoutUserInput[] | ExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExportCreateOrConnectWithoutUserInput | ExportCreateOrConnectWithoutUserInput[]
    createMany?: ExportCreateManyUserInputEnvelope
    connect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ErrorLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ErrorLogCreateWithoutUserInput, ErrorLogUncheckedCreateWithoutUserInput> | ErrorLogCreateWithoutUserInput[] | ErrorLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutUserInput | ErrorLogCreateOrConnectWithoutUserInput[]
    createMany?: ErrorLogCreateManyUserInputEnvelope
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
  }

  export type CloudBackupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CloudBackupCreateWithoutUserInput, CloudBackupUncheckedCreateWithoutUserInput> | CloudBackupCreateWithoutUserInput[] | CloudBackupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CloudBackupCreateOrConnectWithoutUserInput | CloudBackupCreateOrConnectWithoutUserInput[]
    createMany?: CloudBackupCreateManyUserInputEnvelope
    connect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
  }

  export type SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput = {
    create?: XOR<SharedProjectCreateWithoutSharedByUserInput, SharedProjectUncheckedCreateWithoutSharedByUserInput> | SharedProjectCreateWithoutSharedByUserInput[] | SharedProjectUncheckedCreateWithoutSharedByUserInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutSharedByUserInput | SharedProjectCreateOrConnectWithoutSharedByUserInput[]
    createMany?: SharedProjectCreateManySharedByUserInputEnvelope
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
  }

  export type SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput = {
    create?: XOR<SharedProjectCreateWithoutSharedWithUserInput, SharedProjectUncheckedCreateWithoutSharedWithUserInput> | SharedProjectCreateWithoutSharedWithUserInput[] | SharedProjectUncheckedCreateWithoutSharedWithUserInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutSharedWithUserInput | SharedProjectCreateOrConnectWithoutSharedWithUserInput[]
    createMany?: SharedProjectCreateManySharedWithUserInputEnvelope
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NumExportsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NumExportsCreateWithoutUserInput, NumExportsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NumExportsCreateOrConnectWithoutUserInput
    connect?: NumExportsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserTierFieldUpdateOperationsInput = {
    set?: $Enums.UserTier
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type LicenseUpdateOneWithoutUserNestedInput = {
    create?: XOR<LicenseCreateWithoutUserInput, LicenseUncheckedCreateWithoutUserInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutUserInput
    upsert?: LicenseUpsertWithoutUserInput
    disconnect?: LicenseWhereInput | boolean
    delete?: LicenseWhereInput | boolean
    connect?: LicenseWhereUniqueInput
    update?: XOR<XOR<LicenseUpdateToOneWithWhereWithoutUserInput, LicenseUpdateWithoutUserInput>, LicenseUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ModelImportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModelImportCreateWithoutUserInput, ModelImportUncheckedCreateWithoutUserInput> | ModelImportCreateWithoutUserInput[] | ModelImportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModelImportCreateOrConnectWithoutUserInput | ModelImportCreateOrConnectWithoutUserInput[]
    upsert?: ModelImportUpsertWithWhereUniqueWithoutUserInput | ModelImportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModelImportCreateManyUserInputEnvelope
    set?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    disconnect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    delete?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    connect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    update?: ModelImportUpdateWithWhereUniqueWithoutUserInput | ModelImportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModelImportUpdateManyWithWhereWithoutUserInput | ModelImportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModelImportScalarWhereInput | ModelImportScalarWhereInput[]
  }

  export type ExportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExportCreateWithoutUserInput, ExportUncheckedCreateWithoutUserInput> | ExportCreateWithoutUserInput[] | ExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExportCreateOrConnectWithoutUserInput | ExportCreateOrConnectWithoutUserInput[]
    upsert?: ExportUpsertWithWhereUniqueWithoutUserInput | ExportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExportCreateManyUserInputEnvelope
    set?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    disconnect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    delete?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    connect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    update?: ExportUpdateWithWhereUniqueWithoutUserInput | ExportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExportUpdateManyWithWhereWithoutUserInput | ExportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExportScalarWhereInput | ExportScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ErrorLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ErrorLogCreateWithoutUserInput, ErrorLogUncheckedCreateWithoutUserInput> | ErrorLogCreateWithoutUserInput[] | ErrorLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutUserInput | ErrorLogCreateOrConnectWithoutUserInput[]
    upsert?: ErrorLogUpsertWithWhereUniqueWithoutUserInput | ErrorLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ErrorLogCreateManyUserInputEnvelope
    set?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    disconnect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    delete?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    update?: ErrorLogUpdateWithWhereUniqueWithoutUserInput | ErrorLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ErrorLogUpdateManyWithWhereWithoutUserInput | ErrorLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
  }

  export type CloudBackupUpdateManyWithoutUserNestedInput = {
    create?: XOR<CloudBackupCreateWithoutUserInput, CloudBackupUncheckedCreateWithoutUserInput> | CloudBackupCreateWithoutUserInput[] | CloudBackupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CloudBackupCreateOrConnectWithoutUserInput | CloudBackupCreateOrConnectWithoutUserInput[]
    upsert?: CloudBackupUpsertWithWhereUniqueWithoutUserInput | CloudBackupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CloudBackupCreateManyUserInputEnvelope
    set?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    disconnect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    delete?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    connect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    update?: CloudBackupUpdateWithWhereUniqueWithoutUserInput | CloudBackupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CloudBackupUpdateManyWithWhereWithoutUserInput | CloudBackupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CloudBackupScalarWhereInput | CloudBackupScalarWhereInput[]
  }

  export type SharedProjectUpdateManyWithoutSharedByUserNestedInput = {
    create?: XOR<SharedProjectCreateWithoutSharedByUserInput, SharedProjectUncheckedCreateWithoutSharedByUserInput> | SharedProjectCreateWithoutSharedByUserInput[] | SharedProjectUncheckedCreateWithoutSharedByUserInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutSharedByUserInput | SharedProjectCreateOrConnectWithoutSharedByUserInput[]
    upsert?: SharedProjectUpsertWithWhereUniqueWithoutSharedByUserInput | SharedProjectUpsertWithWhereUniqueWithoutSharedByUserInput[]
    createMany?: SharedProjectCreateManySharedByUserInputEnvelope
    set?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    disconnect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    delete?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    update?: SharedProjectUpdateWithWhereUniqueWithoutSharedByUserInput | SharedProjectUpdateWithWhereUniqueWithoutSharedByUserInput[]
    updateMany?: SharedProjectUpdateManyWithWhereWithoutSharedByUserInput | SharedProjectUpdateManyWithWhereWithoutSharedByUserInput[]
    deleteMany?: SharedProjectScalarWhereInput | SharedProjectScalarWhereInput[]
  }

  export type SharedProjectUpdateManyWithoutSharedWithUserNestedInput = {
    create?: XOR<SharedProjectCreateWithoutSharedWithUserInput, SharedProjectUncheckedCreateWithoutSharedWithUserInput> | SharedProjectCreateWithoutSharedWithUserInput[] | SharedProjectUncheckedCreateWithoutSharedWithUserInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutSharedWithUserInput | SharedProjectCreateOrConnectWithoutSharedWithUserInput[]
    upsert?: SharedProjectUpsertWithWhereUniqueWithoutSharedWithUserInput | SharedProjectUpsertWithWhereUniqueWithoutSharedWithUserInput[]
    createMany?: SharedProjectCreateManySharedWithUserInputEnvelope
    set?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    disconnect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    delete?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    update?: SharedProjectUpdateWithWhereUniqueWithoutSharedWithUserInput | SharedProjectUpdateWithWhereUniqueWithoutSharedWithUserInput[]
    updateMany?: SharedProjectUpdateManyWithWhereWithoutSharedWithUserInput | SharedProjectUpdateManyWithWhereWithoutSharedWithUserInput[]
    deleteMany?: SharedProjectScalarWhereInput | SharedProjectScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NumExportsUpdateOneWithoutUserNestedInput = {
    create?: XOR<NumExportsCreateWithoutUserInput, NumExportsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NumExportsCreateOrConnectWithoutUserInput
    upsert?: NumExportsUpsertWithoutUserInput
    disconnect?: NumExportsWhereInput | boolean
    delete?: NumExportsWhereInput | boolean
    connect?: NumExportsWhereUniqueInput
    update?: XOR<XOR<NumExportsUpdateToOneWithWhereWithoutUserInput, NumExportsUpdateWithoutUserInput>, NumExportsUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type LicenseUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LicenseCreateWithoutUserInput, LicenseUncheckedCreateWithoutUserInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutUserInput
    upsert?: LicenseUpsertWithoutUserInput
    disconnect?: LicenseWhereInput | boolean
    delete?: LicenseWhereInput | boolean
    connect?: LicenseWhereUniqueInput
    update?: XOR<XOR<LicenseUpdateToOneWithWhereWithoutUserInput, LicenseUpdateWithoutUserInput>, LicenseUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ModelImportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModelImportCreateWithoutUserInput, ModelImportUncheckedCreateWithoutUserInput> | ModelImportCreateWithoutUserInput[] | ModelImportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModelImportCreateOrConnectWithoutUserInput | ModelImportCreateOrConnectWithoutUserInput[]
    upsert?: ModelImportUpsertWithWhereUniqueWithoutUserInput | ModelImportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModelImportCreateManyUserInputEnvelope
    set?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    disconnect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    delete?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    connect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    update?: ModelImportUpdateWithWhereUniqueWithoutUserInput | ModelImportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModelImportUpdateManyWithWhereWithoutUserInput | ModelImportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModelImportScalarWhereInput | ModelImportScalarWhereInput[]
  }

  export type ExportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExportCreateWithoutUserInput, ExportUncheckedCreateWithoutUserInput> | ExportCreateWithoutUserInput[] | ExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExportCreateOrConnectWithoutUserInput | ExportCreateOrConnectWithoutUserInput[]
    upsert?: ExportUpsertWithWhereUniqueWithoutUserInput | ExportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExportCreateManyUserInputEnvelope
    set?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    disconnect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    delete?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    connect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    update?: ExportUpdateWithWhereUniqueWithoutUserInput | ExportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExportUpdateManyWithWhereWithoutUserInput | ExportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExportScalarWhereInput | ExportScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ErrorLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ErrorLogCreateWithoutUserInput, ErrorLogUncheckedCreateWithoutUserInput> | ErrorLogCreateWithoutUserInput[] | ErrorLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutUserInput | ErrorLogCreateOrConnectWithoutUserInput[]
    upsert?: ErrorLogUpsertWithWhereUniqueWithoutUserInput | ErrorLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ErrorLogCreateManyUserInputEnvelope
    set?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    disconnect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    delete?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    update?: ErrorLogUpdateWithWhereUniqueWithoutUserInput | ErrorLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ErrorLogUpdateManyWithWhereWithoutUserInput | ErrorLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
  }

  export type CloudBackupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CloudBackupCreateWithoutUserInput, CloudBackupUncheckedCreateWithoutUserInput> | CloudBackupCreateWithoutUserInput[] | CloudBackupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CloudBackupCreateOrConnectWithoutUserInput | CloudBackupCreateOrConnectWithoutUserInput[]
    upsert?: CloudBackupUpsertWithWhereUniqueWithoutUserInput | CloudBackupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CloudBackupCreateManyUserInputEnvelope
    set?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    disconnect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    delete?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    connect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    update?: CloudBackupUpdateWithWhereUniqueWithoutUserInput | CloudBackupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CloudBackupUpdateManyWithWhereWithoutUserInput | CloudBackupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CloudBackupScalarWhereInput | CloudBackupScalarWhereInput[]
  }

  export type SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput = {
    create?: XOR<SharedProjectCreateWithoutSharedByUserInput, SharedProjectUncheckedCreateWithoutSharedByUserInput> | SharedProjectCreateWithoutSharedByUserInput[] | SharedProjectUncheckedCreateWithoutSharedByUserInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutSharedByUserInput | SharedProjectCreateOrConnectWithoutSharedByUserInput[]
    upsert?: SharedProjectUpsertWithWhereUniqueWithoutSharedByUserInput | SharedProjectUpsertWithWhereUniqueWithoutSharedByUserInput[]
    createMany?: SharedProjectCreateManySharedByUserInputEnvelope
    set?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    disconnect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    delete?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    update?: SharedProjectUpdateWithWhereUniqueWithoutSharedByUserInput | SharedProjectUpdateWithWhereUniqueWithoutSharedByUserInput[]
    updateMany?: SharedProjectUpdateManyWithWhereWithoutSharedByUserInput | SharedProjectUpdateManyWithWhereWithoutSharedByUserInput[]
    deleteMany?: SharedProjectScalarWhereInput | SharedProjectScalarWhereInput[]
  }

  export type SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput = {
    create?: XOR<SharedProjectCreateWithoutSharedWithUserInput, SharedProjectUncheckedCreateWithoutSharedWithUserInput> | SharedProjectCreateWithoutSharedWithUserInput[] | SharedProjectUncheckedCreateWithoutSharedWithUserInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutSharedWithUserInput | SharedProjectCreateOrConnectWithoutSharedWithUserInput[]
    upsert?: SharedProjectUpsertWithWhereUniqueWithoutSharedWithUserInput | SharedProjectUpsertWithWhereUniqueWithoutSharedWithUserInput[]
    createMany?: SharedProjectCreateManySharedWithUserInputEnvelope
    set?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    disconnect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    delete?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    update?: SharedProjectUpdateWithWhereUniqueWithoutSharedWithUserInput | SharedProjectUpdateWithWhereUniqueWithoutSharedWithUserInput[]
    updateMany?: SharedProjectUpdateManyWithWhereWithoutSharedWithUserInput | SharedProjectUpdateManyWithWhereWithoutSharedWithUserInput[]
    deleteMany?: SharedProjectScalarWhereInput | SharedProjectScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NumExportsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NumExportsCreateWithoutUserInput, NumExportsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NumExportsCreateOrConnectWithoutUserInput
    upsert?: NumExportsUpsertWithoutUserInput
    disconnect?: NumExportsWhereInput | boolean
    delete?: NumExportsWhereInput | boolean
    connect?: NumExportsWhereUniqueInput
    update?: XOR<XOR<NumExportsUpdateToOneWithWhereWithoutUserInput, NumExportsUpdateWithoutUserInput>, NumExportsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutLicenseInput = {
    create?: XOR<UserCreateWithoutLicenseInput, UserUncheckedCreateWithoutLicenseInput>
    connectOrCreate?: UserCreateOrConnectWithoutLicenseInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLicenseTypeFieldUpdateOperationsInput = {
    set?: $Enums.LicenseType
  }

  export type EnumLicenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LicenseStatus
  }

  export type UserUpdateOneRequiredWithoutLicenseNestedInput = {
    create?: XOR<UserCreateWithoutLicenseInput, UserUncheckedCreateWithoutLicenseInput>
    connectOrCreate?: UserCreateOrConnectWithoutLicenseInput
    upsert?: UserUpsertWithoutLicenseInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLicenseInput, UserUpdateWithoutLicenseInput>, UserUncheckedUpdateWithoutLicenseInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionUpsertWithoutPaymentsInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionUpdateWithoutPaymentsInput>, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutModelImportsInput = {
    create?: XOR<UserCreateWithoutModelImportsInput, UserUncheckedCreateWithoutModelImportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModelImportsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutModelImportsInput = {
    create?: XOR<ProjectCreateWithoutModelImportsInput, ProjectUncheckedCreateWithoutModelImportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutModelImportsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ErrorLogCreateNestedManyWithoutModelImportInput = {
    create?: XOR<ErrorLogCreateWithoutModelImportInput, ErrorLogUncheckedCreateWithoutModelImportInput> | ErrorLogCreateWithoutModelImportInput[] | ErrorLogUncheckedCreateWithoutModelImportInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutModelImportInput | ErrorLogCreateOrConnectWithoutModelImportInput[]
    createMany?: ErrorLogCreateManyModelImportInputEnvelope
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
  }

  export type ErrorLogUncheckedCreateNestedManyWithoutModelImportInput = {
    create?: XOR<ErrorLogCreateWithoutModelImportInput, ErrorLogUncheckedCreateWithoutModelImportInput> | ErrorLogCreateWithoutModelImportInput[] | ErrorLogUncheckedCreateWithoutModelImportInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutModelImportInput | ErrorLogCreateOrConnectWithoutModelImportInput[]
    createMany?: ErrorLogCreateManyModelImportInputEnvelope
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type EnumImportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutModelImportsNestedInput = {
    create?: XOR<UserCreateWithoutModelImportsInput, UserUncheckedCreateWithoutModelImportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModelImportsInput
    upsert?: UserUpsertWithoutModelImportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModelImportsInput, UserUpdateWithoutModelImportsInput>, UserUncheckedUpdateWithoutModelImportsInput>
  }

  export type ProjectUpdateOneWithoutModelImportsNestedInput = {
    create?: XOR<ProjectCreateWithoutModelImportsInput, ProjectUncheckedCreateWithoutModelImportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutModelImportsInput
    upsert?: ProjectUpsertWithoutModelImportsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutModelImportsInput, ProjectUpdateWithoutModelImportsInput>, ProjectUncheckedUpdateWithoutModelImportsInput>
  }

  export type ErrorLogUpdateManyWithoutModelImportNestedInput = {
    create?: XOR<ErrorLogCreateWithoutModelImportInput, ErrorLogUncheckedCreateWithoutModelImportInput> | ErrorLogCreateWithoutModelImportInput[] | ErrorLogUncheckedCreateWithoutModelImportInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutModelImportInput | ErrorLogCreateOrConnectWithoutModelImportInput[]
    upsert?: ErrorLogUpsertWithWhereUniqueWithoutModelImportInput | ErrorLogUpsertWithWhereUniqueWithoutModelImportInput[]
    createMany?: ErrorLogCreateManyModelImportInputEnvelope
    set?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    disconnect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    delete?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    update?: ErrorLogUpdateWithWhereUniqueWithoutModelImportInput | ErrorLogUpdateWithWhereUniqueWithoutModelImportInput[]
    updateMany?: ErrorLogUpdateManyWithWhereWithoutModelImportInput | ErrorLogUpdateManyWithWhereWithoutModelImportInput[]
    deleteMany?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
  }

  export type ErrorLogUncheckedUpdateManyWithoutModelImportNestedInput = {
    create?: XOR<ErrorLogCreateWithoutModelImportInput, ErrorLogUncheckedCreateWithoutModelImportInput> | ErrorLogCreateWithoutModelImportInput[] | ErrorLogUncheckedCreateWithoutModelImportInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutModelImportInput | ErrorLogCreateOrConnectWithoutModelImportInput[]
    upsert?: ErrorLogUpsertWithWhereUniqueWithoutModelImportInput | ErrorLogUpsertWithWhereUniqueWithoutModelImportInput[]
    createMany?: ErrorLogCreateManyModelImportInputEnvelope
    set?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    disconnect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    delete?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    update?: ErrorLogUpdateWithWhereUniqueWithoutModelImportInput | ErrorLogUpdateWithWhereUniqueWithoutModelImportInput[]
    updateMany?: ErrorLogUpdateManyWithWhereWithoutModelImportInput | ErrorLogUpdateManyWithWhereWithoutModelImportInput[]
    deleteMany?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ModelImportCreateNestedManyWithoutProjectInput = {
    create?: XOR<ModelImportCreateWithoutProjectInput, ModelImportUncheckedCreateWithoutProjectInput> | ModelImportCreateWithoutProjectInput[] | ModelImportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelImportCreateOrConnectWithoutProjectInput | ModelImportCreateOrConnectWithoutProjectInput[]
    createMany?: ModelImportCreateManyProjectInputEnvelope
    connect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
  }

  export type DesignVersionCreateNestedManyWithoutProjectInput = {
    create?: XOR<DesignVersionCreateWithoutProjectInput, DesignVersionUncheckedCreateWithoutProjectInput> | DesignVersionCreateWithoutProjectInput[] | DesignVersionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutProjectInput | DesignVersionCreateOrConnectWithoutProjectInput[]
    createMany?: DesignVersionCreateManyProjectInputEnvelope
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
  }

  export type ExportCreateNestedManyWithoutProjectInput = {
    create?: XOR<ExportCreateWithoutProjectInput, ExportUncheckedCreateWithoutProjectInput> | ExportCreateWithoutProjectInput[] | ExportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ExportCreateOrConnectWithoutProjectInput | ExportCreateOrConnectWithoutProjectInput[]
    createMany?: ExportCreateManyProjectInputEnvelope
    connect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
  }

  export type CloudBackupCreateNestedManyWithoutProjectInput = {
    create?: XOR<CloudBackupCreateWithoutProjectInput, CloudBackupUncheckedCreateWithoutProjectInput> | CloudBackupCreateWithoutProjectInput[] | CloudBackupUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CloudBackupCreateOrConnectWithoutProjectInput | CloudBackupCreateOrConnectWithoutProjectInput[]
    createMany?: CloudBackupCreateManyProjectInputEnvelope
    connect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
  }

  export type SharedProjectCreateNestedManyWithoutProjectInput = {
    create?: XOR<SharedProjectCreateWithoutProjectInput, SharedProjectUncheckedCreateWithoutProjectInput> | SharedProjectCreateWithoutProjectInput[] | SharedProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutProjectInput | SharedProjectCreateOrConnectWithoutProjectInput[]
    createMany?: SharedProjectCreateManyProjectInputEnvelope
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
  }

  export type ErrorLogCreateNestedManyWithoutProjectInput = {
    create?: XOR<ErrorLogCreateWithoutProjectInput, ErrorLogUncheckedCreateWithoutProjectInput> | ErrorLogCreateWithoutProjectInput[] | ErrorLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutProjectInput | ErrorLogCreateOrConnectWithoutProjectInput[]
    createMany?: ErrorLogCreateManyProjectInputEnvelope
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
  }

  export type ModelImportUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ModelImportCreateWithoutProjectInput, ModelImportUncheckedCreateWithoutProjectInput> | ModelImportCreateWithoutProjectInput[] | ModelImportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelImportCreateOrConnectWithoutProjectInput | ModelImportCreateOrConnectWithoutProjectInput[]
    createMany?: ModelImportCreateManyProjectInputEnvelope
    connect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
  }

  export type DesignVersionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DesignVersionCreateWithoutProjectInput, DesignVersionUncheckedCreateWithoutProjectInput> | DesignVersionCreateWithoutProjectInput[] | DesignVersionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutProjectInput | DesignVersionCreateOrConnectWithoutProjectInput[]
    createMany?: DesignVersionCreateManyProjectInputEnvelope
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
  }

  export type ExportUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ExportCreateWithoutProjectInput, ExportUncheckedCreateWithoutProjectInput> | ExportCreateWithoutProjectInput[] | ExportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ExportCreateOrConnectWithoutProjectInput | ExportCreateOrConnectWithoutProjectInput[]
    createMany?: ExportCreateManyProjectInputEnvelope
    connect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
  }

  export type CloudBackupUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CloudBackupCreateWithoutProjectInput, CloudBackupUncheckedCreateWithoutProjectInput> | CloudBackupCreateWithoutProjectInput[] | CloudBackupUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CloudBackupCreateOrConnectWithoutProjectInput | CloudBackupCreateOrConnectWithoutProjectInput[]
    createMany?: CloudBackupCreateManyProjectInputEnvelope
    connect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
  }

  export type SharedProjectUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SharedProjectCreateWithoutProjectInput, SharedProjectUncheckedCreateWithoutProjectInput> | SharedProjectCreateWithoutProjectInput[] | SharedProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutProjectInput | SharedProjectCreateOrConnectWithoutProjectInput[]
    createMany?: SharedProjectCreateManyProjectInputEnvelope
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
  }

  export type ErrorLogUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ErrorLogCreateWithoutProjectInput, ErrorLogUncheckedCreateWithoutProjectInput> | ErrorLogCreateWithoutProjectInput[] | ErrorLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutProjectInput | ErrorLogCreateOrConnectWithoutProjectInput[]
    createMany?: ErrorLogCreateManyProjectInputEnvelope
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type ModelImportUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ModelImportCreateWithoutProjectInput, ModelImportUncheckedCreateWithoutProjectInput> | ModelImportCreateWithoutProjectInput[] | ModelImportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelImportCreateOrConnectWithoutProjectInput | ModelImportCreateOrConnectWithoutProjectInput[]
    upsert?: ModelImportUpsertWithWhereUniqueWithoutProjectInput | ModelImportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ModelImportCreateManyProjectInputEnvelope
    set?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    disconnect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    delete?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    connect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    update?: ModelImportUpdateWithWhereUniqueWithoutProjectInput | ModelImportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ModelImportUpdateManyWithWhereWithoutProjectInput | ModelImportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ModelImportScalarWhereInput | ModelImportScalarWhereInput[]
  }

  export type DesignVersionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DesignVersionCreateWithoutProjectInput, DesignVersionUncheckedCreateWithoutProjectInput> | DesignVersionCreateWithoutProjectInput[] | DesignVersionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutProjectInput | DesignVersionCreateOrConnectWithoutProjectInput[]
    upsert?: DesignVersionUpsertWithWhereUniqueWithoutProjectInput | DesignVersionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DesignVersionCreateManyProjectInputEnvelope
    set?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    disconnect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    delete?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    update?: DesignVersionUpdateWithWhereUniqueWithoutProjectInput | DesignVersionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DesignVersionUpdateManyWithWhereWithoutProjectInput | DesignVersionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
  }

  export type ExportUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ExportCreateWithoutProjectInput, ExportUncheckedCreateWithoutProjectInput> | ExportCreateWithoutProjectInput[] | ExportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ExportCreateOrConnectWithoutProjectInput | ExportCreateOrConnectWithoutProjectInput[]
    upsert?: ExportUpsertWithWhereUniqueWithoutProjectInput | ExportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ExportCreateManyProjectInputEnvelope
    set?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    disconnect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    delete?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    connect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    update?: ExportUpdateWithWhereUniqueWithoutProjectInput | ExportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ExportUpdateManyWithWhereWithoutProjectInput | ExportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ExportScalarWhereInput | ExportScalarWhereInput[]
  }

  export type CloudBackupUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CloudBackupCreateWithoutProjectInput, CloudBackupUncheckedCreateWithoutProjectInput> | CloudBackupCreateWithoutProjectInput[] | CloudBackupUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CloudBackupCreateOrConnectWithoutProjectInput | CloudBackupCreateOrConnectWithoutProjectInput[]
    upsert?: CloudBackupUpsertWithWhereUniqueWithoutProjectInput | CloudBackupUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CloudBackupCreateManyProjectInputEnvelope
    set?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    disconnect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    delete?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    connect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    update?: CloudBackupUpdateWithWhereUniqueWithoutProjectInput | CloudBackupUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CloudBackupUpdateManyWithWhereWithoutProjectInput | CloudBackupUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CloudBackupScalarWhereInput | CloudBackupScalarWhereInput[]
  }

  export type SharedProjectUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SharedProjectCreateWithoutProjectInput, SharedProjectUncheckedCreateWithoutProjectInput> | SharedProjectCreateWithoutProjectInput[] | SharedProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutProjectInput | SharedProjectCreateOrConnectWithoutProjectInput[]
    upsert?: SharedProjectUpsertWithWhereUniqueWithoutProjectInput | SharedProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SharedProjectCreateManyProjectInputEnvelope
    set?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    disconnect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    delete?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    update?: SharedProjectUpdateWithWhereUniqueWithoutProjectInput | SharedProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SharedProjectUpdateManyWithWhereWithoutProjectInput | SharedProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SharedProjectScalarWhereInput | SharedProjectScalarWhereInput[]
  }

  export type ErrorLogUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ErrorLogCreateWithoutProjectInput, ErrorLogUncheckedCreateWithoutProjectInput> | ErrorLogCreateWithoutProjectInput[] | ErrorLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutProjectInput | ErrorLogCreateOrConnectWithoutProjectInput[]
    upsert?: ErrorLogUpsertWithWhereUniqueWithoutProjectInput | ErrorLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ErrorLogCreateManyProjectInputEnvelope
    set?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    disconnect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    delete?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    update?: ErrorLogUpdateWithWhereUniqueWithoutProjectInput | ErrorLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ErrorLogUpdateManyWithWhereWithoutProjectInput | ErrorLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
  }

  export type ModelImportUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ModelImportCreateWithoutProjectInput, ModelImportUncheckedCreateWithoutProjectInput> | ModelImportCreateWithoutProjectInput[] | ModelImportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModelImportCreateOrConnectWithoutProjectInput | ModelImportCreateOrConnectWithoutProjectInput[]
    upsert?: ModelImportUpsertWithWhereUniqueWithoutProjectInput | ModelImportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ModelImportCreateManyProjectInputEnvelope
    set?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    disconnect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    delete?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    connect?: ModelImportWhereUniqueInput | ModelImportWhereUniqueInput[]
    update?: ModelImportUpdateWithWhereUniqueWithoutProjectInput | ModelImportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ModelImportUpdateManyWithWhereWithoutProjectInput | ModelImportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ModelImportScalarWhereInput | ModelImportScalarWhereInput[]
  }

  export type DesignVersionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DesignVersionCreateWithoutProjectInput, DesignVersionUncheckedCreateWithoutProjectInput> | DesignVersionCreateWithoutProjectInput[] | DesignVersionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DesignVersionCreateOrConnectWithoutProjectInput | DesignVersionCreateOrConnectWithoutProjectInput[]
    upsert?: DesignVersionUpsertWithWhereUniqueWithoutProjectInput | DesignVersionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DesignVersionCreateManyProjectInputEnvelope
    set?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    disconnect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    delete?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    connect?: DesignVersionWhereUniqueInput | DesignVersionWhereUniqueInput[]
    update?: DesignVersionUpdateWithWhereUniqueWithoutProjectInput | DesignVersionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DesignVersionUpdateManyWithWhereWithoutProjectInput | DesignVersionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
  }

  export type ExportUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ExportCreateWithoutProjectInput, ExportUncheckedCreateWithoutProjectInput> | ExportCreateWithoutProjectInput[] | ExportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ExportCreateOrConnectWithoutProjectInput | ExportCreateOrConnectWithoutProjectInput[]
    upsert?: ExportUpsertWithWhereUniqueWithoutProjectInput | ExportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ExportCreateManyProjectInputEnvelope
    set?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    disconnect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    delete?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    connect?: ExportWhereUniqueInput | ExportWhereUniqueInput[]
    update?: ExportUpdateWithWhereUniqueWithoutProjectInput | ExportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ExportUpdateManyWithWhereWithoutProjectInput | ExportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ExportScalarWhereInput | ExportScalarWhereInput[]
  }

  export type CloudBackupUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CloudBackupCreateWithoutProjectInput, CloudBackupUncheckedCreateWithoutProjectInput> | CloudBackupCreateWithoutProjectInput[] | CloudBackupUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CloudBackupCreateOrConnectWithoutProjectInput | CloudBackupCreateOrConnectWithoutProjectInput[]
    upsert?: CloudBackupUpsertWithWhereUniqueWithoutProjectInput | CloudBackupUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CloudBackupCreateManyProjectInputEnvelope
    set?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    disconnect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    delete?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    connect?: CloudBackupWhereUniqueInput | CloudBackupWhereUniqueInput[]
    update?: CloudBackupUpdateWithWhereUniqueWithoutProjectInput | CloudBackupUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CloudBackupUpdateManyWithWhereWithoutProjectInput | CloudBackupUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CloudBackupScalarWhereInput | CloudBackupScalarWhereInput[]
  }

  export type SharedProjectUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SharedProjectCreateWithoutProjectInput, SharedProjectUncheckedCreateWithoutProjectInput> | SharedProjectCreateWithoutProjectInput[] | SharedProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SharedProjectCreateOrConnectWithoutProjectInput | SharedProjectCreateOrConnectWithoutProjectInput[]
    upsert?: SharedProjectUpsertWithWhereUniqueWithoutProjectInput | SharedProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SharedProjectCreateManyProjectInputEnvelope
    set?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    disconnect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    delete?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    connect?: SharedProjectWhereUniqueInput | SharedProjectWhereUniqueInput[]
    update?: SharedProjectUpdateWithWhereUniqueWithoutProjectInput | SharedProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SharedProjectUpdateManyWithWhereWithoutProjectInput | SharedProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SharedProjectScalarWhereInput | SharedProjectScalarWhereInput[]
  }

  export type ErrorLogUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ErrorLogCreateWithoutProjectInput, ErrorLogUncheckedCreateWithoutProjectInput> | ErrorLogCreateWithoutProjectInput[] | ErrorLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutProjectInput | ErrorLogCreateOrConnectWithoutProjectInput[]
    upsert?: ErrorLogUpsertWithWhereUniqueWithoutProjectInput | ErrorLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ErrorLogCreateManyProjectInputEnvelope
    set?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    disconnect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    delete?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    update?: ErrorLogUpdateWithWhereUniqueWithoutProjectInput | ErrorLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ErrorLogUpdateManyWithWhereWithoutProjectInput | ErrorLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutDesignVersionsInput = {
    create?: XOR<ProjectCreateWithoutDesignVersionsInput, ProjectUncheckedCreateWithoutDesignVersionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDesignVersionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutDesignVersionsNestedInput = {
    create?: XOR<ProjectCreateWithoutDesignVersionsInput, ProjectUncheckedCreateWithoutDesignVersionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDesignVersionsInput
    upsert?: ProjectUpsertWithoutDesignVersionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDesignVersionsInput, ProjectUpdateWithoutDesignVersionsInput>, ProjectUncheckedUpdateWithoutDesignVersionsInput>
  }

  export type ProjectCreateNestedOneWithoutExportsInput = {
    create?: XOR<ProjectCreateWithoutExportsInput, ProjectUncheckedCreateWithoutExportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutExportsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExportsInput = {
    create?: XOR<UserCreateWithoutExportsInput, UserUncheckedCreateWithoutExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExportsInput
    connect?: UserWhereUniqueInput
  }

  export type ErrorLogCreateNestedManyWithoutExportInput = {
    create?: XOR<ErrorLogCreateWithoutExportInput, ErrorLogUncheckedCreateWithoutExportInput> | ErrorLogCreateWithoutExportInput[] | ErrorLogUncheckedCreateWithoutExportInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutExportInput | ErrorLogCreateOrConnectWithoutExportInput[]
    createMany?: ErrorLogCreateManyExportInputEnvelope
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
  }

  export type ErrorLogUncheckedCreateNestedManyWithoutExportInput = {
    create?: XOR<ErrorLogCreateWithoutExportInput, ErrorLogUncheckedCreateWithoutExportInput> | ErrorLogCreateWithoutExportInput[] | ErrorLogUncheckedCreateWithoutExportInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutExportInput | ErrorLogCreateOrConnectWithoutExportInput[]
    createMany?: ErrorLogCreateManyExportInputEnvelope
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
  }

  export type EnumExportFormatFieldUpdateOperationsInput = {
    set?: $Enums.ExportFormat
  }

  export type EnumExportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExportStatus
  }

  export type ProjectUpdateOneRequiredWithoutExportsNestedInput = {
    create?: XOR<ProjectCreateWithoutExportsInput, ProjectUncheckedCreateWithoutExportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutExportsInput
    upsert?: ProjectUpsertWithoutExportsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutExportsInput, ProjectUpdateWithoutExportsInput>, ProjectUncheckedUpdateWithoutExportsInput>
  }

  export type UserUpdateOneRequiredWithoutExportsNestedInput = {
    create?: XOR<UserCreateWithoutExportsInput, UserUncheckedCreateWithoutExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExportsInput
    upsert?: UserUpsertWithoutExportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExportsInput, UserUpdateWithoutExportsInput>, UserUncheckedUpdateWithoutExportsInput>
  }

  export type ErrorLogUpdateManyWithoutExportNestedInput = {
    create?: XOR<ErrorLogCreateWithoutExportInput, ErrorLogUncheckedCreateWithoutExportInput> | ErrorLogCreateWithoutExportInput[] | ErrorLogUncheckedCreateWithoutExportInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutExportInput | ErrorLogCreateOrConnectWithoutExportInput[]
    upsert?: ErrorLogUpsertWithWhereUniqueWithoutExportInput | ErrorLogUpsertWithWhereUniqueWithoutExportInput[]
    createMany?: ErrorLogCreateManyExportInputEnvelope
    set?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    disconnect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    delete?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    update?: ErrorLogUpdateWithWhereUniqueWithoutExportInput | ErrorLogUpdateWithWhereUniqueWithoutExportInput[]
    updateMany?: ErrorLogUpdateManyWithWhereWithoutExportInput | ErrorLogUpdateManyWithWhereWithoutExportInput[]
    deleteMany?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
  }

  export type ErrorLogUncheckedUpdateManyWithoutExportNestedInput = {
    create?: XOR<ErrorLogCreateWithoutExportInput, ErrorLogUncheckedCreateWithoutExportInput> | ErrorLogCreateWithoutExportInput[] | ErrorLogUncheckedCreateWithoutExportInput[]
    connectOrCreate?: ErrorLogCreateOrConnectWithoutExportInput | ErrorLogCreateOrConnectWithoutExportInput[]
    upsert?: ErrorLogUpsertWithWhereUniqueWithoutExportInput | ErrorLogUpsertWithWhereUniqueWithoutExportInput[]
    createMany?: ErrorLogCreateManyExportInputEnvelope
    set?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    disconnect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    delete?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    connect?: ErrorLogWhereUniqueInput | ErrorLogWhereUniqueInput[]
    update?: ErrorLogUpdateWithWhereUniqueWithoutExportInput | ErrorLogUpdateWithWhereUniqueWithoutExportInput[]
    updateMany?: ErrorLogUpdateManyWithWhereWithoutExportInput | ErrorLogUpdateManyWithWhereWithoutExportInput[]
    deleteMany?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutErrorLogsInput = {
    create?: XOR<UserCreateWithoutErrorLogsInput, UserUncheckedCreateWithoutErrorLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutErrorLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutErrorLogsInput = {
    create?: XOR<ProjectCreateWithoutErrorLogsInput, ProjectUncheckedCreateWithoutErrorLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutErrorLogsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ModelImportCreateNestedOneWithoutErrorLogsInput = {
    create?: XOR<ModelImportCreateWithoutErrorLogsInput, ModelImportUncheckedCreateWithoutErrorLogsInput>
    connectOrCreate?: ModelImportCreateOrConnectWithoutErrorLogsInput
    connect?: ModelImportWhereUniqueInput
  }

  export type ExportCreateNestedOneWithoutErrorLogsInput = {
    create?: XOR<ExportCreateWithoutErrorLogsInput, ExportUncheckedCreateWithoutErrorLogsInput>
    connectOrCreate?: ExportCreateOrConnectWithoutErrorLogsInput
    connect?: ExportWhereUniqueInput
  }

  export type EnumErrorCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ErrorCategory
  }

  export type EnumErrorSeverityFieldUpdateOperationsInput = {
    set?: $Enums.ErrorSeverity
  }

  export type UserUpdateOneWithoutErrorLogsNestedInput = {
    create?: XOR<UserCreateWithoutErrorLogsInput, UserUncheckedCreateWithoutErrorLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutErrorLogsInput
    upsert?: UserUpsertWithoutErrorLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutErrorLogsInput, UserUpdateWithoutErrorLogsInput>, UserUncheckedUpdateWithoutErrorLogsInput>
  }

  export type ProjectUpdateOneWithoutErrorLogsNestedInput = {
    create?: XOR<ProjectCreateWithoutErrorLogsInput, ProjectUncheckedCreateWithoutErrorLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutErrorLogsInput
    upsert?: ProjectUpsertWithoutErrorLogsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutErrorLogsInput, ProjectUpdateWithoutErrorLogsInput>, ProjectUncheckedUpdateWithoutErrorLogsInput>
  }

  export type ModelImportUpdateOneWithoutErrorLogsNestedInput = {
    create?: XOR<ModelImportCreateWithoutErrorLogsInput, ModelImportUncheckedCreateWithoutErrorLogsInput>
    connectOrCreate?: ModelImportCreateOrConnectWithoutErrorLogsInput
    upsert?: ModelImportUpsertWithoutErrorLogsInput
    disconnect?: ModelImportWhereInput | boolean
    delete?: ModelImportWhereInput | boolean
    connect?: ModelImportWhereUniqueInput
    update?: XOR<XOR<ModelImportUpdateToOneWithWhereWithoutErrorLogsInput, ModelImportUpdateWithoutErrorLogsInput>, ModelImportUncheckedUpdateWithoutErrorLogsInput>
  }

  export type ExportUpdateOneWithoutErrorLogsNestedInput = {
    create?: XOR<ExportCreateWithoutErrorLogsInput, ExportUncheckedCreateWithoutErrorLogsInput>
    connectOrCreate?: ExportCreateOrConnectWithoutErrorLogsInput
    upsert?: ExportUpsertWithoutErrorLogsInput
    disconnect?: ExportWhereInput | boolean
    delete?: ExportWhereInput | boolean
    connect?: ExportWhereUniqueInput
    update?: XOR<XOR<ExportUpdateToOneWithWhereWithoutErrorLogsInput, ExportUpdateWithoutErrorLogsInput>, ExportUncheckedUpdateWithoutErrorLogsInput>
  }

  export type ProjectCreateNestedOneWithoutSharedProjectsInput = {
    create?: XOR<ProjectCreateWithoutSharedProjectsInput, ProjectUncheckedCreateWithoutSharedProjectsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSharedProjectsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedProjectsInput = {
    create?: XOR<UserCreateWithoutSharedProjectsInput, UserUncheckedCreateWithoutSharedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedSharesInput = {
    create?: XOR<UserCreateWithoutReceivedSharesInput, UserUncheckedCreateWithoutReceivedSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedSharesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutSharedProjectsNestedInput = {
    create?: XOR<ProjectCreateWithoutSharedProjectsInput, ProjectUncheckedCreateWithoutSharedProjectsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSharedProjectsInput
    upsert?: ProjectUpsertWithoutSharedProjectsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSharedProjectsInput, ProjectUpdateWithoutSharedProjectsInput>, ProjectUncheckedUpdateWithoutSharedProjectsInput>
  }

  export type UserUpdateOneRequiredWithoutSharedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutSharedProjectsInput, UserUncheckedCreateWithoutSharedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedProjectsInput
    upsert?: UserUpsertWithoutSharedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedProjectsInput, UserUpdateWithoutSharedProjectsInput>, UserUncheckedUpdateWithoutSharedProjectsInput>
  }

  export type UserUpdateOneWithoutReceivedSharesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedSharesInput, UserUncheckedCreateWithoutReceivedSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedSharesInput
    upsert?: UserUpsertWithoutReceivedSharesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedSharesInput, UserUpdateWithoutReceivedSharesInput>, UserUncheckedUpdateWithoutReceivedSharesInput>
  }

  export type ProjectCreateNestedOneWithoutCloudBackupsInput = {
    create?: XOR<ProjectCreateWithoutCloudBackupsInput, ProjectUncheckedCreateWithoutCloudBackupsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCloudBackupsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCloudBackupsInput = {
    create?: XOR<UserCreateWithoutCloudBackupsInput, UserUncheckedCreateWithoutCloudBackupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCloudBackupsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutCloudBackupsNestedInput = {
    create?: XOR<ProjectCreateWithoutCloudBackupsInput, ProjectUncheckedCreateWithoutCloudBackupsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCloudBackupsInput
    upsert?: ProjectUpsertWithoutCloudBackupsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCloudBackupsInput, ProjectUpdateWithoutCloudBackupsInput>, ProjectUncheckedUpdateWithoutCloudBackupsInput>
  }

  export type UserUpdateOneRequiredWithoutCloudBackupsNestedInput = {
    create?: XOR<UserCreateWithoutCloudBackupsInput, UserUncheckedCreateWithoutCloudBackupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCloudBackupsInput
    upsert?: UserUpsertWithoutCloudBackupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCloudBackupsInput, UserUpdateWithoutCloudBackupsInput>, UserUncheckedUpdateWithoutCloudBackupsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutNumExportsInput = {
    create?: XOR<UserCreateWithoutNumExportsInput, UserUncheckedCreateWithoutNumExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNumExportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNumExportsNestedInput = {
    create?: XOR<UserCreateWithoutNumExportsInput, UserUncheckedCreateWithoutNumExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNumExportsInput
    upsert?: UserUpsertWithoutNumExportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNumExportsInput, UserUpdateWithoutNumExportsInput>, UserUncheckedUpdateWithoutNumExportsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserTierFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierFilter<$PrismaModel> | $Enums.UserTier
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTier | EnumUserTierFieldRefInput<$PrismaModel>
    in?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTier[] | ListEnumUserTierFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTierWithAggregatesFilter<$PrismaModel> | $Enums.UserTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTierFilter<$PrismaModel>
    _max?: NestedEnumUserTierFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumLicenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseType | EnumLicenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseTypeFilter<$PrismaModel> | $Enums.LicenseType
  }

  export type NestedEnumLicenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseStatusFilter<$PrismaModel> | $Enums.LicenseStatus
  }

  export type NestedEnumLicenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseType | EnumLicenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.LicenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseTypeFilter<$PrismaModel>
    _max?: NestedEnumLicenseTypeFilter<$PrismaModel>
  }

  export type NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LicenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseStatusFilter<$PrismaModel>
    _max?: NestedEnumLicenseStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedEnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedEnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumExportFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportFormat | EnumExportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumExportFormatFilter<$PrismaModel> | $Enums.ExportFormat
  }

  export type NestedEnumExportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportStatus | EnumExportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExportStatus[] | ListEnumExportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportStatus[] | ListEnumExportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExportStatusFilter<$PrismaModel> | $Enums.ExportStatus
  }

  export type NestedEnumExportFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportFormat | EnumExportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumExportFormatWithAggregatesFilter<$PrismaModel> | $Enums.ExportFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExportFormatFilter<$PrismaModel>
    _max?: NestedEnumExportFormatFilter<$PrismaModel>
  }

  export type NestedEnumExportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportStatus | EnumExportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExportStatus[] | ListEnumExportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportStatus[] | ListEnumExportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExportStatusFilter<$PrismaModel>
    _max?: NestedEnumExportStatusFilter<$PrismaModel>
  }

  export type NestedEnumErrorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorCategory | EnumErrorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorCategory[] | ListEnumErrorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ErrorCategory[] | ListEnumErrorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumErrorCategoryFilter<$PrismaModel> | $Enums.ErrorCategory
  }

  export type NestedEnumErrorSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorSeverity | EnumErrorSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorSeverity[] | ListEnumErrorSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ErrorSeverity[] | ListEnumErrorSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumErrorSeverityFilter<$PrismaModel> | $Enums.ErrorSeverity
  }

  export type NestedEnumErrorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorCategory | EnumErrorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorCategory[] | ListEnumErrorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ErrorCategory[] | ListEnumErrorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumErrorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ErrorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumErrorCategoryFilter<$PrismaModel>
    _max?: NestedEnumErrorCategoryFilter<$PrismaModel>
  }

  export type NestedEnumErrorSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorSeverity | EnumErrorSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorSeverity[] | ListEnumErrorSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ErrorSeverity[] | ListEnumErrorSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumErrorSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ErrorSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumErrorSeverityFilter<$PrismaModel>
    _max?: NestedEnumErrorSeverityFilter<$PrismaModel>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    replacedByToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    replacedByToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LicenseCreateWithoutUserInput = {
    id?: string
    licenseType: $Enums.LicenseType
    status?: $Enums.LicenseStatus
    dateStart: Date | string
    dateEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseUncheckedCreateWithoutUserInput = {
    id?: string
    licenseType: $Enums.LicenseType
    status?: $Enums.LicenseStatus
    dateStart: Date | string
    dateEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseCreateOrConnectWithoutUserInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutUserInput, LicenseUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    tier: $Enums.UserTier
    status?: $Enums.SubscriptionStatus
    billingCycle: string
    amount: number
    currency?: string
    modelLimit: number
    startDate: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    autoRenew?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    tier: $Enums.UserTier
    status?: $Enums.SubscriptionStatus
    billingCycle: string
    amount: number
    currency?: string
    modelLimit: number
    startDate: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    autoRenew?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    modelImports?: ModelImportCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionCreateNestedManyWithoutProjectInput
    exports?: ExportCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutProjectInput
    exports?: ExportUncheckedCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ModelImportCreateWithoutUserInput = {
    id?: string
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project?: ProjectCreateNestedOneWithoutModelImportsInput
    errorLogs?: ErrorLogCreateNestedManyWithoutModelImportInput
  }

  export type ModelImportUncheckedCreateWithoutUserInput = {
    id?: string
    projectId?: string | null
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutModelImportInput
  }

  export type ModelImportCreateOrConnectWithoutUserInput = {
    where: ModelImportWhereUniqueInput
    create: XOR<ModelImportCreateWithoutUserInput, ModelImportUncheckedCreateWithoutUserInput>
  }

  export type ModelImportCreateManyUserInputEnvelope = {
    data: ModelImportCreateManyUserInput | ModelImportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExportCreateWithoutUserInput = {
    id?: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutExportsInput
    errorLogs?: ErrorLogCreateNestedManyWithoutExportInput
  }

  export type ExportUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutExportInput
  }

  export type ExportCreateOrConnectWithoutUserInput = {
    where: ExportWhereUniqueInput
    create: XOR<ExportCreateWithoutUserInput, ExportUncheckedCreateWithoutUserInput>
  }

  export type ExportCreateManyUserInputEnvelope = {
    data: ExportCreateManyUserInput | ExportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    subscriptionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ErrorLogCreateWithoutUserInput = {
    id?: string
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    project?: ProjectCreateNestedOneWithoutErrorLogsInput
    modelImport?: ModelImportCreateNestedOneWithoutErrorLogsInput
    export?: ExportCreateNestedOneWithoutErrorLogsInput
  }

  export type ErrorLogUncheckedCreateWithoutUserInput = {
    id?: string
    projectId?: string | null
    modelImportId?: string | null
    exportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ErrorLogCreateOrConnectWithoutUserInput = {
    where: ErrorLogWhereUniqueInput
    create: XOR<ErrorLogCreateWithoutUserInput, ErrorLogUncheckedCreateWithoutUserInput>
  }

  export type ErrorLogCreateManyUserInputEnvelope = {
    data: ErrorLogCreateManyUserInput | ErrorLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CloudBackupCreateWithoutUserInput = {
    id?: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutCloudBackupsInput
  }

  export type CloudBackupUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
  }

  export type CloudBackupCreateOrConnectWithoutUserInput = {
    where: CloudBackupWhereUniqueInput
    create: XOR<CloudBackupCreateWithoutUserInput, CloudBackupUncheckedCreateWithoutUserInput>
  }

  export type CloudBackupCreateManyUserInputEnvelope = {
    data: CloudBackupCreateManyUserInput | CloudBackupCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SharedProjectCreateWithoutSharedByUserInput = {
    id?: string
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutSharedProjectsInput
    sharedWithUser?: UserCreateNestedOneWithoutReceivedSharesInput
  }

  export type SharedProjectUncheckedCreateWithoutSharedByUserInput = {
    id?: string
    projectId: string
    sharedWith?: string | null
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type SharedProjectCreateOrConnectWithoutSharedByUserInput = {
    where: SharedProjectWhereUniqueInput
    create: XOR<SharedProjectCreateWithoutSharedByUserInput, SharedProjectUncheckedCreateWithoutSharedByUserInput>
  }

  export type SharedProjectCreateManySharedByUserInputEnvelope = {
    data: SharedProjectCreateManySharedByUserInput | SharedProjectCreateManySharedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SharedProjectCreateWithoutSharedWithUserInput = {
    id?: string
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutSharedProjectsInput
    sharedByUser: UserCreateNestedOneWithoutSharedProjectsInput
  }

  export type SharedProjectUncheckedCreateWithoutSharedWithUserInput = {
    id?: string
    projectId: string
    sharedBy: string
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type SharedProjectCreateOrConnectWithoutSharedWithUserInput = {
    where: SharedProjectWhereUniqueInput
    create: XOR<SharedProjectCreateWithoutSharedWithUserInput, SharedProjectUncheckedCreateWithoutSharedWithUserInput>
  }

  export type SharedProjectCreateManySharedWithUserInputEnvelope = {
    data: SharedProjectCreateManySharedWithUserInput | SharedProjectCreateManySharedWithUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    status: string
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    status: string
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NumExportsCreateWithoutUserInput = {
    id?: string
    exports?: number
    updatedAt?: Date | string
  }

  export type NumExportsUncheckedCreateWithoutUserInput = {
    id?: string
    exports?: number
    updatedAt?: Date | string
  }

  export type NumExportsCreateOrConnectWithoutUserInput = {
    where: NumExportsWhereUniqueInput
    create: XOR<NumExportsCreateWithoutUserInput, NumExportsUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    tokenHash?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    replacedByToken?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type LicenseUpsertWithoutUserInput = {
    update: XOR<LicenseUpdateWithoutUserInput, LicenseUncheckedUpdateWithoutUserInput>
    create: XOR<LicenseCreateWithoutUserInput, LicenseUncheckedCreateWithoutUserInput>
    where?: LicenseWhereInput
  }

  export type LicenseUpdateToOneWithWhereWithoutUserInput = {
    where?: LicenseWhereInput
    data: XOR<LicenseUpdateWithoutUserInput, LicenseUncheckedUpdateWithoutUserInput>
  }

  export type LicenseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseType?: EnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseType?: EnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    modelLimit?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    modelLimit?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    thumbnailUrl?: StringNullableFilter<"Project"> | string | null
    modelFilename?: StringNullableFilter<"Project"> | string | null
    modelFileType?: StringNullableFilter<"Project"> | string | null
    modelFileSize?: IntNullableFilter<"Project"> | number | null
    supportsCount?: IntFilter<"Project"> | number
    clampsCount?: IntFilter<"Project"> | number
    hasBaseplate?: BoolFilter<"Project"> | boolean
    processingTime?: IntNullableFilter<"Project"> | number | null
    toolingApplied?: JsonNullableFilter<"Project">
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    isPublic?: BoolFilter<"Project"> | boolean
    shareToken?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    lastOpenedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
  }

  export type ModelImportUpsertWithWhereUniqueWithoutUserInput = {
    where: ModelImportWhereUniqueInput
    update: XOR<ModelImportUpdateWithoutUserInput, ModelImportUncheckedUpdateWithoutUserInput>
    create: XOR<ModelImportCreateWithoutUserInput, ModelImportUncheckedCreateWithoutUserInput>
  }

  export type ModelImportUpdateWithWhereUniqueWithoutUserInput = {
    where: ModelImportWhereUniqueInput
    data: XOR<ModelImportUpdateWithoutUserInput, ModelImportUncheckedUpdateWithoutUserInput>
  }

  export type ModelImportUpdateManyWithWhereWithoutUserInput = {
    where: ModelImportScalarWhereInput
    data: XOR<ModelImportUpdateManyMutationInput, ModelImportUncheckedUpdateManyWithoutUserInput>
  }

  export type ModelImportScalarWhereInput = {
    AND?: ModelImportScalarWhereInput | ModelImportScalarWhereInput[]
    OR?: ModelImportScalarWhereInput[]
    NOT?: ModelImportScalarWhereInput | ModelImportScalarWhereInput[]
    id?: StringFilter<"ModelImport"> | string
    userId?: StringFilter<"ModelImport"> | string
    projectId?: StringNullableFilter<"ModelImport"> | string | null
    filename?: StringFilter<"ModelImport"> | string
    originalFilename?: StringFilter<"ModelImport"> | string
    fileSize?: IntFilter<"ModelImport"> | number
    fileHash?: StringNullableFilter<"ModelImport"> | string | null
    modelData?: BytesNullableFilter<"ModelImport"> | Buffer | null
    thumbnailData?: BytesNullableFilter<"ModelImport"> | Buffer | null
    status?: EnumImportStatusFilter<"ModelImport"> | $Enums.ImportStatus
    progress?: IntFilter<"ModelImport"> | number
    processingStartedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
    processingCompletedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
    processingDuration?: IntNullableFilter<"ModelImport"> | number | null
    vertexCount?: IntNullableFilter<"ModelImport"> | number | null
    faceCount?: IntNullableFilter<"ModelImport"> | number | null
    boundingBox?: JsonNullableFilter<"ModelImport">
    dimensions?: JsonNullableFilter<"ModelImport">
    volume?: FloatNullableFilter<"ModelImport"> | number | null
    isValid?: BoolFilter<"ModelImport"> | boolean
    validationErrors?: JsonNullableFilter<"ModelImport">
    errorMessage?: StringNullableFilter<"ModelImport"> | string | null
    errorCode?: StringNullableFilter<"ModelImport"> | string | null
    countsTowardLimit?: BoolFilter<"ModelImport"> | boolean
    createdAt?: DateTimeFilter<"ModelImport"> | Date | string
    updatedAt?: DateTimeFilter<"ModelImport"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ModelImport"> | Date | string | null
  }

  export type ExportUpsertWithWhereUniqueWithoutUserInput = {
    where: ExportWhereUniqueInput
    update: XOR<ExportUpdateWithoutUserInput, ExportUncheckedUpdateWithoutUserInput>
    create: XOR<ExportCreateWithoutUserInput, ExportUncheckedCreateWithoutUserInput>
  }

  export type ExportUpdateWithWhereUniqueWithoutUserInput = {
    where: ExportWhereUniqueInput
    data: XOR<ExportUpdateWithoutUserInput, ExportUncheckedUpdateWithoutUserInput>
  }

  export type ExportUpdateManyWithWhereWithoutUserInput = {
    where: ExportScalarWhereInput
    data: XOR<ExportUpdateManyMutationInput, ExportUncheckedUpdateManyWithoutUserInput>
  }

  export type ExportScalarWhereInput = {
    AND?: ExportScalarWhereInput | ExportScalarWhereInput[]
    OR?: ExportScalarWhereInput[]
    NOT?: ExportScalarWhereInput | ExportScalarWhereInput[]
    id?: StringFilter<"Export"> | string
    projectId?: StringFilter<"Export"> | string
    userId?: StringFilter<"Export"> | string
    format?: EnumExportFormatFilter<"Export"> | $Enums.ExportFormat
    filename?: StringFilter<"Export"> | string
    fileSize?: IntNullableFilter<"Export"> | number | null
    exportData?: BytesNullableFilter<"Export"> | Buffer | null
    fileUrl?: StringNullableFilter<"Export"> | string | null
    settings?: JsonNullableFilter<"Export">
    includeSupports?: BoolFilter<"Export"> | boolean
    includeClamps?: BoolFilter<"Export"> | boolean
    includeBaseplate?: BoolFilter<"Export"> | boolean
    processingTime?: IntNullableFilter<"Export"> | number | null
    status?: EnumExportStatusFilter<"Export"> | $Enums.ExportStatus
    errorMessage?: StringNullableFilter<"Export"> | string | null
    numberOfExportsDone?: IntFilter<"Export"> | number
    downloadCount?: IntFilter<"Export"> | number
    lastDownloadedAt?: DateTimeNullableFilter<"Export"> | Date | string | null
    createdAt?: DateTimeFilter<"Export"> | Date | string
    completedAt?: DateTimeNullableFilter<"Export"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Export"> | Date | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    gatewayProvider?: StringFilter<"Payment"> | string
    gatewayOrderId?: StringNullableFilter<"Payment"> | string | null
    gatewayPaymentId?: StringNullableFilter<"Payment"> | string | null
    gatewaySignature?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    invoiceUrl?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    failureCode?: StringNullableFilter<"Payment"> | string | null
    refundedAmount?: FloatNullableFilter<"Payment"> | number | null
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    refundReason?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
  }

  export type ErrorLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ErrorLogWhereUniqueInput
    update: XOR<ErrorLogUpdateWithoutUserInput, ErrorLogUncheckedUpdateWithoutUserInput>
    create: XOR<ErrorLogCreateWithoutUserInput, ErrorLogUncheckedCreateWithoutUserInput>
  }

  export type ErrorLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ErrorLogWhereUniqueInput
    data: XOR<ErrorLogUpdateWithoutUserInput, ErrorLogUncheckedUpdateWithoutUserInput>
  }

  export type ErrorLogUpdateManyWithWhereWithoutUserInput = {
    where: ErrorLogScalarWhereInput
    data: XOR<ErrorLogUpdateManyMutationInput, ErrorLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ErrorLogScalarWhereInput = {
    AND?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
    OR?: ErrorLogScalarWhereInput[]
    NOT?: ErrorLogScalarWhereInput | ErrorLogScalarWhereInput[]
    id?: StringFilter<"ErrorLog"> | string
    userId?: StringNullableFilter<"ErrorLog"> | string | null
    projectId?: StringNullableFilter<"ErrorLog"> | string | null
    modelImportId?: StringNullableFilter<"ErrorLog"> | string | null
    exportId?: StringNullableFilter<"ErrorLog"> | string | null
    category?: EnumErrorCategoryFilter<"ErrorLog"> | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFilter<"ErrorLog"> | $Enums.ErrorSeverity
    errorCode?: StringFilter<"ErrorLog"> | string
    errorMessage?: StringFilter<"ErrorLog"> | string
    errorStack?: StringNullableFilter<"ErrorLog"> | string | null
    operation?: StringFilter<"ErrorLog"> | string
    step?: StringNullableFilter<"ErrorLog"> | string | null
    browserInfo?: JsonNullableFilter<"ErrorLog">
    deviceInfo?: JsonNullableFilter<"ErrorLog">
    url?: StringNullableFilter<"ErrorLog"> | string | null
    method?: StringNullableFilter<"ErrorLog"> | string | null
    statusCode?: IntNullableFilter<"ErrorLog"> | number | null
    userAction?: StringNullableFilter<"ErrorLog"> | string | null
    resolved?: BoolFilter<"ErrorLog"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ErrorLog"> | Date | string | null
    resolution?: StringNullableFilter<"ErrorLog"> | string | null
    metadata?: JsonNullableFilter<"ErrorLog">
    createdAt?: DateTimeFilter<"ErrorLog"> | Date | string
  }

  export type CloudBackupUpsertWithWhereUniqueWithoutUserInput = {
    where: CloudBackupWhereUniqueInput
    update: XOR<CloudBackupUpdateWithoutUserInput, CloudBackupUncheckedUpdateWithoutUserInput>
    create: XOR<CloudBackupCreateWithoutUserInput, CloudBackupUncheckedCreateWithoutUserInput>
  }

  export type CloudBackupUpdateWithWhereUniqueWithoutUserInput = {
    where: CloudBackupWhereUniqueInput
    data: XOR<CloudBackupUpdateWithoutUserInput, CloudBackupUncheckedUpdateWithoutUserInput>
  }

  export type CloudBackupUpdateManyWithWhereWithoutUserInput = {
    where: CloudBackupScalarWhereInput
    data: XOR<CloudBackupUpdateManyMutationInput, CloudBackupUncheckedUpdateManyWithoutUserInput>
  }

  export type CloudBackupScalarWhereInput = {
    AND?: CloudBackupScalarWhereInput | CloudBackupScalarWhereInput[]
    OR?: CloudBackupScalarWhereInput[]
    NOT?: CloudBackupScalarWhereInput | CloudBackupScalarWhereInput[]
    id?: StringFilter<"CloudBackup"> | string
    projectId?: StringFilter<"CloudBackup"> | string
    userId?: StringFilter<"CloudBackup"> | string
    backupName?: StringNullableFilter<"CloudBackup"> | string | null
    compressedData?: BytesNullableFilter<"CloudBackup"> | Buffer | null
    fileSize?: IntFilter<"CloudBackup"> | number
    checksum?: StringFilter<"CloudBackup"> | string
    compressionType?: StringFilter<"CloudBackup"> | string
    originalSize?: IntNullableFilter<"CloudBackup"> | number | null
    metadata?: JsonNullableFilter<"CloudBackup">
    createdAt?: DateTimeFilter<"CloudBackup"> | Date | string
    accessedAt?: DateTimeNullableFilter<"CloudBackup"> | Date | string | null
  }

  export type SharedProjectUpsertWithWhereUniqueWithoutSharedByUserInput = {
    where: SharedProjectWhereUniqueInput
    update: XOR<SharedProjectUpdateWithoutSharedByUserInput, SharedProjectUncheckedUpdateWithoutSharedByUserInput>
    create: XOR<SharedProjectCreateWithoutSharedByUserInput, SharedProjectUncheckedCreateWithoutSharedByUserInput>
  }

  export type SharedProjectUpdateWithWhereUniqueWithoutSharedByUserInput = {
    where: SharedProjectWhereUniqueInput
    data: XOR<SharedProjectUpdateWithoutSharedByUserInput, SharedProjectUncheckedUpdateWithoutSharedByUserInput>
  }

  export type SharedProjectUpdateManyWithWhereWithoutSharedByUserInput = {
    where: SharedProjectScalarWhereInput
    data: XOR<SharedProjectUpdateManyMutationInput, SharedProjectUncheckedUpdateManyWithoutSharedByUserInput>
  }

  export type SharedProjectScalarWhereInput = {
    AND?: SharedProjectScalarWhereInput | SharedProjectScalarWhereInput[]
    OR?: SharedProjectScalarWhereInput[]
    NOT?: SharedProjectScalarWhereInput | SharedProjectScalarWhereInput[]
    id?: StringFilter<"SharedProject"> | string
    projectId?: StringFilter<"SharedProject"> | string
    sharedBy?: StringFilter<"SharedProject"> | string
    sharedWith?: StringNullableFilter<"SharedProject"> | string | null
    permission?: StringFilter<"SharedProject"> | string
    shareType?: StringFilter<"SharedProject"> | string
    shareToken?: StringNullableFilter<"SharedProject"> | string | null
    accepted?: BoolFilter<"SharedProject"> | boolean
    revoked?: BoolFilter<"SharedProject"> | boolean
    createdAt?: DateTimeFilter<"SharedProject"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SharedProject"> | Date | string | null
  }

  export type SharedProjectUpsertWithWhereUniqueWithoutSharedWithUserInput = {
    where: SharedProjectWhereUniqueInput
    update: XOR<SharedProjectUpdateWithoutSharedWithUserInput, SharedProjectUncheckedUpdateWithoutSharedWithUserInput>
    create: XOR<SharedProjectCreateWithoutSharedWithUserInput, SharedProjectUncheckedCreateWithoutSharedWithUserInput>
  }

  export type SharedProjectUpdateWithWhereUniqueWithoutSharedWithUserInput = {
    where: SharedProjectWhereUniqueInput
    data: XOR<SharedProjectUpdateWithoutSharedWithUserInput, SharedProjectUncheckedUpdateWithoutSharedWithUserInput>
  }

  export type SharedProjectUpdateManyWithWhereWithoutSharedWithUserInput = {
    where: SharedProjectScalarWhereInput
    data: XOR<SharedProjectUpdateManyMutationInput, SharedProjectUncheckedUpdateManyWithoutSharedWithUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NumExportsUpsertWithoutUserInput = {
    update: XOR<NumExportsUpdateWithoutUserInput, NumExportsUncheckedUpdateWithoutUserInput>
    create: XOR<NumExportsCreateWithoutUserInput, NumExportsUncheckedCreateWithoutUserInput>
    where?: NumExportsWhereInput
  }

  export type NumExportsUpdateToOneWithWhereWithoutUserInput = {
    where?: NumExportsWhereInput
    data: XOR<NumExportsUpdateWithoutUserInput, NumExportsUncheckedUpdateWithoutUserInput>
  }

  export type NumExportsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exports?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NumExportsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exports?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutLicenseInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLicenseInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLicenseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLicenseInput, UserUncheckedCreateWithoutLicenseInput>
  }

  export type UserUpsertWithoutLicenseInput = {
    update: XOR<UserUpdateWithoutLicenseInput, UserUncheckedUpdateWithoutLicenseInput>
    create: XOR<UserCreateWithoutLicenseInput, UserUncheckedCreateWithoutLicenseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLicenseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLicenseInput, UserUncheckedUpdateWithoutLicenseInput>
  }

  export type UserUpdateWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateManySubscriptionInputEnvelope = {
    data: PaymentCreateManySubscriptionInput | PaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionCreateWithoutPaymentsInput = {
    id?: string
    tier: $Enums.UserTier
    status?: $Enums.SubscriptionStatus
    billingCycle: string
    amount: number
    currency?: string
    modelLimit: number
    startDate: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    autoRenew?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    tier: $Enums.UserTier
    status?: $Enums.SubscriptionStatus
    billingCycle: string
    amount: number
    currency?: string
    modelLimit: number
    startDate: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    autoRenew?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    modelLimit?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    modelLimit?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutModelImportsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutModelImportsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutModelImportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModelImportsInput, UserUncheckedCreateWithoutModelImportsInput>
  }

  export type ProjectCreateWithoutModelImportsInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectsInput
    designVersions?: DesignVersionCreateNestedManyWithoutProjectInput
    exports?: ExportCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutModelImportsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutProjectInput
    exports?: ExportUncheckedCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutModelImportsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutModelImportsInput, ProjectUncheckedCreateWithoutModelImportsInput>
  }

  export type ErrorLogCreateWithoutModelImportInput = {
    id?: string
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutErrorLogsInput
    project?: ProjectCreateNestedOneWithoutErrorLogsInput
    export?: ExportCreateNestedOneWithoutErrorLogsInput
  }

  export type ErrorLogUncheckedCreateWithoutModelImportInput = {
    id?: string
    userId?: string | null
    projectId?: string | null
    exportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ErrorLogCreateOrConnectWithoutModelImportInput = {
    where: ErrorLogWhereUniqueInput
    create: XOR<ErrorLogCreateWithoutModelImportInput, ErrorLogUncheckedCreateWithoutModelImportInput>
  }

  export type ErrorLogCreateManyModelImportInputEnvelope = {
    data: ErrorLogCreateManyModelImportInput | ErrorLogCreateManyModelImportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutModelImportsInput = {
    update: XOR<UserUpdateWithoutModelImportsInput, UserUncheckedUpdateWithoutModelImportsInput>
    create: XOR<UserCreateWithoutModelImportsInput, UserUncheckedCreateWithoutModelImportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModelImportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModelImportsInput, UserUncheckedUpdateWithoutModelImportsInput>
  }

  export type UserUpdateWithoutModelImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutModelImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutModelImportsInput = {
    update: XOR<ProjectUpdateWithoutModelImportsInput, ProjectUncheckedUpdateWithoutModelImportsInput>
    create: XOR<ProjectCreateWithoutModelImportsInput, ProjectUncheckedCreateWithoutModelImportsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutModelImportsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutModelImportsInput, ProjectUncheckedUpdateWithoutModelImportsInput>
  }

  export type ProjectUpdateWithoutModelImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    designVersions?: DesignVersionUpdateManyWithoutProjectNestedInput
    exports?: ExportUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutModelImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designVersions?: DesignVersionUncheckedUpdateManyWithoutProjectNestedInput
    exports?: ExportUncheckedUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ErrorLogUpsertWithWhereUniqueWithoutModelImportInput = {
    where: ErrorLogWhereUniqueInput
    update: XOR<ErrorLogUpdateWithoutModelImportInput, ErrorLogUncheckedUpdateWithoutModelImportInput>
    create: XOR<ErrorLogCreateWithoutModelImportInput, ErrorLogUncheckedCreateWithoutModelImportInput>
  }

  export type ErrorLogUpdateWithWhereUniqueWithoutModelImportInput = {
    where: ErrorLogWhereUniqueInput
    data: XOR<ErrorLogUpdateWithoutModelImportInput, ErrorLogUncheckedUpdateWithoutModelImportInput>
  }

  export type ErrorLogUpdateManyWithWhereWithoutModelImportInput = {
    where: ErrorLogScalarWhereInput
    data: XOR<ErrorLogUpdateManyMutationInput, ErrorLogUncheckedUpdateManyWithoutModelImportInput>
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type ModelImportCreateWithoutProjectInput = {
    id?: string
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutModelImportsInput
    errorLogs?: ErrorLogCreateNestedManyWithoutModelImportInput
  }

  export type ModelImportUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutModelImportInput
  }

  export type ModelImportCreateOrConnectWithoutProjectInput = {
    where: ModelImportWhereUniqueInput
    create: XOR<ModelImportCreateWithoutProjectInput, ModelImportUncheckedCreateWithoutProjectInput>
  }

  export type ModelImportCreateManyProjectInputEnvelope = {
    data: ModelImportCreateManyProjectInput | ModelImportCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DesignVersionCreateWithoutProjectInput = {
    id?: string
    versionNumber: number
    name?: string | null
    description?: string | null
    thumbnailUrl?: string | null
    changesSummary?: string | null
    supportsCount?: number
    clampsCount?: number
    isAutoSave?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type DesignVersionUncheckedCreateWithoutProjectInput = {
    id?: string
    versionNumber: number
    name?: string | null
    description?: string | null
    thumbnailUrl?: string | null
    changesSummary?: string | null
    supportsCount?: number
    clampsCount?: number
    isAutoSave?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type DesignVersionCreateOrConnectWithoutProjectInput = {
    where: DesignVersionWhereUniqueInput
    create: XOR<DesignVersionCreateWithoutProjectInput, DesignVersionUncheckedCreateWithoutProjectInput>
  }

  export type DesignVersionCreateManyProjectInputEnvelope = {
    data: DesignVersionCreateManyProjectInput | DesignVersionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ExportCreateWithoutProjectInput = {
    id?: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutExportsInput
    errorLogs?: ErrorLogCreateNestedManyWithoutExportInput
  }

  export type ExportUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutExportInput
  }

  export type ExportCreateOrConnectWithoutProjectInput = {
    where: ExportWhereUniqueInput
    create: XOR<ExportCreateWithoutProjectInput, ExportUncheckedCreateWithoutProjectInput>
  }

  export type ExportCreateManyProjectInputEnvelope = {
    data: ExportCreateManyProjectInput | ExportCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CloudBackupCreateWithoutProjectInput = {
    id?: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCloudBackupsInput
  }

  export type CloudBackupUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
  }

  export type CloudBackupCreateOrConnectWithoutProjectInput = {
    where: CloudBackupWhereUniqueInput
    create: XOR<CloudBackupCreateWithoutProjectInput, CloudBackupUncheckedCreateWithoutProjectInput>
  }

  export type CloudBackupCreateManyProjectInputEnvelope = {
    data: CloudBackupCreateManyProjectInput | CloudBackupCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SharedProjectCreateWithoutProjectInput = {
    id?: string
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    sharedByUser: UserCreateNestedOneWithoutSharedProjectsInput
    sharedWithUser?: UserCreateNestedOneWithoutReceivedSharesInput
  }

  export type SharedProjectUncheckedCreateWithoutProjectInput = {
    id?: string
    sharedBy: string
    sharedWith?: string | null
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type SharedProjectCreateOrConnectWithoutProjectInput = {
    where: SharedProjectWhereUniqueInput
    create: XOR<SharedProjectCreateWithoutProjectInput, SharedProjectUncheckedCreateWithoutProjectInput>
  }

  export type SharedProjectCreateManyProjectInputEnvelope = {
    data: SharedProjectCreateManyProjectInput | SharedProjectCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ErrorLogCreateWithoutProjectInput = {
    id?: string
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutErrorLogsInput
    modelImport?: ModelImportCreateNestedOneWithoutErrorLogsInput
    export?: ExportCreateNestedOneWithoutErrorLogsInput
  }

  export type ErrorLogUncheckedCreateWithoutProjectInput = {
    id?: string
    userId?: string | null
    modelImportId?: string | null
    exportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ErrorLogCreateOrConnectWithoutProjectInput = {
    where: ErrorLogWhereUniqueInput
    create: XOR<ErrorLogCreateWithoutProjectInput, ErrorLogUncheckedCreateWithoutProjectInput>
  }

  export type ErrorLogCreateManyProjectInputEnvelope = {
    data: ErrorLogCreateManyProjectInput | ErrorLogCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ModelImportUpsertWithWhereUniqueWithoutProjectInput = {
    where: ModelImportWhereUniqueInput
    update: XOR<ModelImportUpdateWithoutProjectInput, ModelImportUncheckedUpdateWithoutProjectInput>
    create: XOR<ModelImportCreateWithoutProjectInput, ModelImportUncheckedCreateWithoutProjectInput>
  }

  export type ModelImportUpdateWithWhereUniqueWithoutProjectInput = {
    where: ModelImportWhereUniqueInput
    data: XOR<ModelImportUpdateWithoutProjectInput, ModelImportUncheckedUpdateWithoutProjectInput>
  }

  export type ModelImportUpdateManyWithWhereWithoutProjectInput = {
    where: ModelImportScalarWhereInput
    data: XOR<ModelImportUpdateManyMutationInput, ModelImportUncheckedUpdateManyWithoutProjectInput>
  }

  export type DesignVersionUpsertWithWhereUniqueWithoutProjectInput = {
    where: DesignVersionWhereUniqueInput
    update: XOR<DesignVersionUpdateWithoutProjectInput, DesignVersionUncheckedUpdateWithoutProjectInput>
    create: XOR<DesignVersionCreateWithoutProjectInput, DesignVersionUncheckedCreateWithoutProjectInput>
  }

  export type DesignVersionUpdateWithWhereUniqueWithoutProjectInput = {
    where: DesignVersionWhereUniqueInput
    data: XOR<DesignVersionUpdateWithoutProjectInput, DesignVersionUncheckedUpdateWithoutProjectInput>
  }

  export type DesignVersionUpdateManyWithWhereWithoutProjectInput = {
    where: DesignVersionScalarWhereInput
    data: XOR<DesignVersionUpdateManyMutationInput, DesignVersionUncheckedUpdateManyWithoutProjectInput>
  }

  export type DesignVersionScalarWhereInput = {
    AND?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
    OR?: DesignVersionScalarWhereInput[]
    NOT?: DesignVersionScalarWhereInput | DesignVersionScalarWhereInput[]
    id?: StringFilter<"DesignVersion"> | string
    projectId?: StringFilter<"DesignVersion"> | string
    versionNumber?: IntFilter<"DesignVersion"> | number
    name?: StringNullableFilter<"DesignVersion"> | string | null
    description?: StringNullableFilter<"DesignVersion"> | string | null
    thumbnailUrl?: StringNullableFilter<"DesignVersion"> | string | null
    changesSummary?: StringNullableFilter<"DesignVersion"> | string | null
    supportsCount?: IntFilter<"DesignVersion"> | number
    clampsCount?: IntFilter<"DesignVersion"> | number
    isAutoSave?: BoolFilter<"DesignVersion"> | boolean
    createdAt?: DateTimeFilter<"DesignVersion"> | Date | string
    createdBy?: StringNullableFilter<"DesignVersion"> | string | null
  }

  export type ExportUpsertWithWhereUniqueWithoutProjectInput = {
    where: ExportWhereUniqueInput
    update: XOR<ExportUpdateWithoutProjectInput, ExportUncheckedUpdateWithoutProjectInput>
    create: XOR<ExportCreateWithoutProjectInput, ExportUncheckedCreateWithoutProjectInput>
  }

  export type ExportUpdateWithWhereUniqueWithoutProjectInput = {
    where: ExportWhereUniqueInput
    data: XOR<ExportUpdateWithoutProjectInput, ExportUncheckedUpdateWithoutProjectInput>
  }

  export type ExportUpdateManyWithWhereWithoutProjectInput = {
    where: ExportScalarWhereInput
    data: XOR<ExportUpdateManyMutationInput, ExportUncheckedUpdateManyWithoutProjectInput>
  }

  export type CloudBackupUpsertWithWhereUniqueWithoutProjectInput = {
    where: CloudBackupWhereUniqueInput
    update: XOR<CloudBackupUpdateWithoutProjectInput, CloudBackupUncheckedUpdateWithoutProjectInput>
    create: XOR<CloudBackupCreateWithoutProjectInput, CloudBackupUncheckedCreateWithoutProjectInput>
  }

  export type CloudBackupUpdateWithWhereUniqueWithoutProjectInput = {
    where: CloudBackupWhereUniqueInput
    data: XOR<CloudBackupUpdateWithoutProjectInput, CloudBackupUncheckedUpdateWithoutProjectInput>
  }

  export type CloudBackupUpdateManyWithWhereWithoutProjectInput = {
    where: CloudBackupScalarWhereInput
    data: XOR<CloudBackupUpdateManyMutationInput, CloudBackupUncheckedUpdateManyWithoutProjectInput>
  }

  export type SharedProjectUpsertWithWhereUniqueWithoutProjectInput = {
    where: SharedProjectWhereUniqueInput
    update: XOR<SharedProjectUpdateWithoutProjectInput, SharedProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<SharedProjectCreateWithoutProjectInput, SharedProjectUncheckedCreateWithoutProjectInput>
  }

  export type SharedProjectUpdateWithWhereUniqueWithoutProjectInput = {
    where: SharedProjectWhereUniqueInput
    data: XOR<SharedProjectUpdateWithoutProjectInput, SharedProjectUncheckedUpdateWithoutProjectInput>
  }

  export type SharedProjectUpdateManyWithWhereWithoutProjectInput = {
    where: SharedProjectScalarWhereInput
    data: XOR<SharedProjectUpdateManyMutationInput, SharedProjectUncheckedUpdateManyWithoutProjectInput>
  }

  export type ErrorLogUpsertWithWhereUniqueWithoutProjectInput = {
    where: ErrorLogWhereUniqueInput
    update: XOR<ErrorLogUpdateWithoutProjectInput, ErrorLogUncheckedUpdateWithoutProjectInput>
    create: XOR<ErrorLogCreateWithoutProjectInput, ErrorLogUncheckedCreateWithoutProjectInput>
  }

  export type ErrorLogUpdateWithWhereUniqueWithoutProjectInput = {
    where: ErrorLogWhereUniqueInput
    data: XOR<ErrorLogUpdateWithoutProjectInput, ErrorLogUncheckedUpdateWithoutProjectInput>
  }

  export type ErrorLogUpdateManyWithWhereWithoutProjectInput = {
    where: ErrorLogScalarWhereInput
    data: XOR<ErrorLogUpdateManyMutationInput, ErrorLogUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutDesignVersionsInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectsInput
    modelImports?: ModelImportCreateNestedManyWithoutProjectInput
    exports?: ExportCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDesignVersionsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutProjectInput
    exports?: ExportUncheckedCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDesignVersionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDesignVersionsInput, ProjectUncheckedCreateWithoutDesignVersionsInput>
  }

  export type ProjectUpsertWithoutDesignVersionsInput = {
    update: XOR<ProjectUpdateWithoutDesignVersionsInput, ProjectUncheckedUpdateWithoutDesignVersionsInput>
    create: XOR<ProjectCreateWithoutDesignVersionsInput, ProjectUncheckedCreateWithoutDesignVersionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDesignVersionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDesignVersionsInput, ProjectUncheckedUpdateWithoutDesignVersionsInput>
  }

  export type ProjectUpdateWithoutDesignVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    modelImports?: ModelImportUpdateManyWithoutProjectNestedInput
    exports?: ExportUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDesignVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelImports?: ModelImportUncheckedUpdateManyWithoutProjectNestedInput
    exports?: ExportUncheckedUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutExportsInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectsInput
    modelImports?: ModelImportCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutExportsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutExportsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutExportsInput, ProjectUncheckedCreateWithoutExportsInput>
  }

  export type UserCreateWithoutExportsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExportsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExportsInput, UserUncheckedCreateWithoutExportsInput>
  }

  export type ErrorLogCreateWithoutExportInput = {
    id?: string
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutErrorLogsInput
    project?: ProjectCreateNestedOneWithoutErrorLogsInput
    modelImport?: ModelImportCreateNestedOneWithoutErrorLogsInput
  }

  export type ErrorLogUncheckedCreateWithoutExportInput = {
    id?: string
    userId?: string | null
    projectId?: string | null
    modelImportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ErrorLogCreateOrConnectWithoutExportInput = {
    where: ErrorLogWhereUniqueInput
    create: XOR<ErrorLogCreateWithoutExportInput, ErrorLogUncheckedCreateWithoutExportInput>
  }

  export type ErrorLogCreateManyExportInputEnvelope = {
    data: ErrorLogCreateManyExportInput | ErrorLogCreateManyExportInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutExportsInput = {
    update: XOR<ProjectUpdateWithoutExportsInput, ProjectUncheckedUpdateWithoutExportsInput>
    create: XOR<ProjectCreateWithoutExportsInput, ProjectUncheckedCreateWithoutExportsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutExportsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutExportsInput, ProjectUncheckedUpdateWithoutExportsInput>
  }

  export type ProjectUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    modelImports?: ModelImportUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelImports?: ModelImportUncheckedUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutExportsInput = {
    update: XOR<UserUpdateWithoutExportsInput, UserUncheckedUpdateWithoutExportsInput>
    create: XOR<UserCreateWithoutExportsInput, UserUncheckedCreateWithoutExportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExportsInput, UserUncheckedUpdateWithoutExportsInput>
  }

  export type UserUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ErrorLogUpsertWithWhereUniqueWithoutExportInput = {
    where: ErrorLogWhereUniqueInput
    update: XOR<ErrorLogUpdateWithoutExportInput, ErrorLogUncheckedUpdateWithoutExportInput>
    create: XOR<ErrorLogCreateWithoutExportInput, ErrorLogUncheckedCreateWithoutExportInput>
  }

  export type ErrorLogUpdateWithWhereUniqueWithoutExportInput = {
    where: ErrorLogWhereUniqueInput
    data: XOR<ErrorLogUpdateWithoutExportInput, ErrorLogUncheckedUpdateWithoutExportInput>
  }

  export type ErrorLogUpdateManyWithWhereWithoutExportInput = {
    where: ErrorLogScalarWhereInput
    data: XOR<ErrorLogUpdateManyMutationInput, ErrorLogUncheckedUpdateManyWithoutExportInput>
  }

  export type UserCreateWithoutErrorLogsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutErrorLogsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutErrorLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutErrorLogsInput, UserUncheckedCreateWithoutErrorLogsInput>
  }

  export type ProjectCreateWithoutErrorLogsInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectsInput
    modelImports?: ModelImportCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionCreateNestedManyWithoutProjectInput
    exports?: ExportCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutErrorLogsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutProjectInput
    exports?: ExportUncheckedCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutErrorLogsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutErrorLogsInput, ProjectUncheckedCreateWithoutErrorLogsInput>
  }

  export type ModelImportCreateWithoutErrorLogsInput = {
    id?: string
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutModelImportsInput
    project?: ProjectCreateNestedOneWithoutModelImportsInput
  }

  export type ModelImportUncheckedCreateWithoutErrorLogsInput = {
    id?: string
    userId: string
    projectId?: string | null
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ModelImportCreateOrConnectWithoutErrorLogsInput = {
    where: ModelImportWhereUniqueInput
    create: XOR<ModelImportCreateWithoutErrorLogsInput, ModelImportUncheckedCreateWithoutErrorLogsInput>
  }

  export type ExportCreateWithoutErrorLogsInput = {
    id?: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutExportsInput
    user: UserCreateNestedOneWithoutExportsInput
  }

  export type ExportUncheckedCreateWithoutErrorLogsInput = {
    id?: string
    projectId: string
    userId: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type ExportCreateOrConnectWithoutErrorLogsInput = {
    where: ExportWhereUniqueInput
    create: XOR<ExportCreateWithoutErrorLogsInput, ExportUncheckedCreateWithoutErrorLogsInput>
  }

  export type UserUpsertWithoutErrorLogsInput = {
    update: XOR<UserUpdateWithoutErrorLogsInput, UserUncheckedUpdateWithoutErrorLogsInput>
    create: XOR<UserCreateWithoutErrorLogsInput, UserUncheckedCreateWithoutErrorLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutErrorLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutErrorLogsInput, UserUncheckedUpdateWithoutErrorLogsInput>
  }

  export type UserUpdateWithoutErrorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutErrorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutErrorLogsInput = {
    update: XOR<ProjectUpdateWithoutErrorLogsInput, ProjectUncheckedUpdateWithoutErrorLogsInput>
    create: XOR<ProjectCreateWithoutErrorLogsInput, ProjectUncheckedCreateWithoutErrorLogsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutErrorLogsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutErrorLogsInput, ProjectUncheckedUpdateWithoutErrorLogsInput>
  }

  export type ProjectUpdateWithoutErrorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    modelImports?: ModelImportUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUpdateManyWithoutProjectNestedInput
    exports?: ExportUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutErrorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelImports?: ModelImportUncheckedUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutProjectNestedInput
    exports?: ExportUncheckedUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ModelImportUpsertWithoutErrorLogsInput = {
    update: XOR<ModelImportUpdateWithoutErrorLogsInput, ModelImportUncheckedUpdateWithoutErrorLogsInput>
    create: XOR<ModelImportCreateWithoutErrorLogsInput, ModelImportUncheckedCreateWithoutErrorLogsInput>
    where?: ModelImportWhereInput
  }

  export type ModelImportUpdateToOneWithWhereWithoutErrorLogsInput = {
    where?: ModelImportWhereInput
    data: XOR<ModelImportUpdateWithoutErrorLogsInput, ModelImportUncheckedUpdateWithoutErrorLogsInput>
  }

  export type ModelImportUpdateWithoutErrorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutModelImportsNestedInput
    project?: ProjectUpdateOneWithoutModelImportsNestedInput
  }

  export type ModelImportUncheckedUpdateWithoutErrorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportUpsertWithoutErrorLogsInput = {
    update: XOR<ExportUpdateWithoutErrorLogsInput, ExportUncheckedUpdateWithoutErrorLogsInput>
    create: XOR<ExportCreateWithoutErrorLogsInput, ExportUncheckedCreateWithoutErrorLogsInput>
    where?: ExportWhereInput
  }

  export type ExportUpdateToOneWithWhereWithoutErrorLogsInput = {
    where?: ExportWhereInput
    data: XOR<ExportUpdateWithoutErrorLogsInput, ExportUncheckedUpdateWithoutErrorLogsInput>
  }

  export type ExportUpdateWithoutErrorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutExportsNestedInput
    user?: UserUpdateOneRequiredWithoutExportsNestedInput
  }

  export type ExportUncheckedUpdateWithoutErrorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectCreateWithoutSharedProjectsInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectsInput
    modelImports?: ModelImportCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionCreateNestedManyWithoutProjectInput
    exports?: ExportCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSharedProjectsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutProjectInput
    exports?: ExportUncheckedCreateNestedManyWithoutProjectInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSharedProjectsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSharedProjectsInput, ProjectUncheckedCreateWithoutSharedProjectsInput>
  }

  export type UserCreateWithoutSharedProjectsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedProjectsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedProjectsInput, UserUncheckedCreateWithoutSharedProjectsInput>
  }

  export type UserCreateWithoutReceivedSharesInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedSharesInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedSharesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedSharesInput, UserUncheckedCreateWithoutReceivedSharesInput>
  }

  export type ProjectUpsertWithoutSharedProjectsInput = {
    update: XOR<ProjectUpdateWithoutSharedProjectsInput, ProjectUncheckedUpdateWithoutSharedProjectsInput>
    create: XOR<ProjectCreateWithoutSharedProjectsInput, ProjectUncheckedCreateWithoutSharedProjectsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSharedProjectsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSharedProjectsInput, ProjectUncheckedUpdateWithoutSharedProjectsInput>
  }

  export type ProjectUpdateWithoutSharedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    modelImports?: ModelImportUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUpdateManyWithoutProjectNestedInput
    exports?: ExportUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSharedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelImports?: ModelImportUncheckedUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutProjectNestedInput
    exports?: ExportUncheckedUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutSharedProjectsInput = {
    update: XOR<UserUpdateWithoutSharedProjectsInput, UserUncheckedUpdateWithoutSharedProjectsInput>
    create: XOR<UserCreateWithoutSharedProjectsInput, UserUncheckedCreateWithoutSharedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedProjectsInput, UserUncheckedUpdateWithoutSharedProjectsInput>
  }

  export type UserUpdateWithoutSharedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedSharesInput = {
    update: XOR<UserUpdateWithoutReceivedSharesInput, UserUncheckedUpdateWithoutReceivedSharesInput>
    create: XOR<UserCreateWithoutReceivedSharesInput, UserUncheckedCreateWithoutReceivedSharesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedSharesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedSharesInput, UserUncheckedUpdateWithoutReceivedSharesInput>
  }

  export type UserUpdateWithoutReceivedSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProjectCreateWithoutCloudBackupsInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectsInput
    modelImports?: ModelImportCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionCreateNestedManyWithoutProjectInput
    exports?: ExportCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCloudBackupsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutProjectInput
    designVersions?: DesignVersionUncheckedCreateNestedManyWithoutProjectInput
    exports?: ExportUncheckedCreateNestedManyWithoutProjectInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutProjectInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCloudBackupsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCloudBackupsInput, ProjectUncheckedCreateWithoutCloudBackupsInput>
  }

  export type UserCreateWithoutCloudBackupsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCloudBackupsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCloudBackupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCloudBackupsInput, UserUncheckedCreateWithoutCloudBackupsInput>
  }

  export type ProjectUpsertWithoutCloudBackupsInput = {
    update: XOR<ProjectUpdateWithoutCloudBackupsInput, ProjectUncheckedUpdateWithoutCloudBackupsInput>
    create: XOR<ProjectCreateWithoutCloudBackupsInput, ProjectUncheckedCreateWithoutCloudBackupsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCloudBackupsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCloudBackupsInput, ProjectUncheckedUpdateWithoutCloudBackupsInput>
  }

  export type ProjectUpdateWithoutCloudBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    modelImports?: ModelImportUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUpdateManyWithoutProjectNestedInput
    exports?: ExportUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCloudBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelImports?: ModelImportUncheckedUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutProjectNestedInput
    exports?: ExportUncheckedUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCloudBackupsInput = {
    update: XOR<UserUpdateWithoutCloudBackupsInput, UserUncheckedUpdateWithoutCloudBackupsInput>
    create: XOR<UserCreateWithoutCloudBackupsInput, UserUncheckedCreateWithoutCloudBackupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCloudBackupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCloudBackupsInput, UserUncheckedUpdateWithoutCloudBackupsInput>
  }

  export type UserUpdateWithoutCloudBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCloudBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    numExports?: NumExportsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    numExports?: NumExportsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    numExports?: NumExportsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    numExports?: NumExportsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutNumExportsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    license?: LicenseCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    modelImports?: ModelImportCreateNestedManyWithoutUserInput
    exports?: ExportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNumExportsInput = {
    id?: string
    email: string
    passwordHash: string
    emailVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiry?: Date | string | null
    name: string
    phoneNumber?: string | null
    organization?: string | null
    jobTitle?: string | null
    country?: string | null
    industry?: string | null
    tier?: $Enums.UserTier
    modelLimit?: number
    modelsUsed?: number
    timeSpent?: number
    maxStepReached?: number
    lastSessionFinalStep?: number
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    mfaEnabled?: boolean
    mfaSecret?: string | null
    avatarUrl?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    license?: LicenseUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    modelImports?: ModelImportUncheckedCreateNestedManyWithoutUserInput
    exports?: ExportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    errorLogs?: ErrorLogUncheckedCreateNestedManyWithoutUserInput
    cloudBackups?: CloudBackupUncheckedCreateNestedManyWithoutUserInput
    sharedProjects?: SharedProjectUncheckedCreateNestedManyWithoutSharedByUserInput
    receivedShares?: SharedProjectUncheckedCreateNestedManyWithoutSharedWithUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNumExportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNumExportsInput, UserUncheckedCreateWithoutNumExportsInput>
  }

  export type UserUpsertWithoutNumExportsInput = {
    update: XOR<UserUpdateWithoutNumExportsInput, UserUncheckedUpdateWithoutNumExportsInput>
    create: XOR<UserCreateWithoutNumExportsInput, UserUncheckedCreateWithoutNumExportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNumExportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNumExportsInput, UserUncheckedUpdateWithoutNumExportsInput>
  }

  export type UserUpdateWithoutNumExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    license?: LicenseUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUpdateManyWithoutUserNestedInput
    exports?: ExportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNumExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumUserTierFieldUpdateOperationsInput | $Enums.UserTier
    modelLimit?: IntFieldUpdateOperationsInput | number
    modelsUsed?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    maxStepReached?: IntFieldUpdateOperationsInput | number
    lastSessionFinalStep?: IntFieldUpdateOperationsInput | number
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    license?: LicenseUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    modelImports?: ModelImportUncheckedUpdateManyWithoutUserNestedInput
    exports?: ExportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutUserNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutUserNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutSharedByUserNestedInput
    receivedShares?: SharedProjectUncheckedUpdateManyWithoutSharedWithUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    revokedAt?: Date | string | null
    replacedByToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ProjectCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    thumbnailUrl?: string | null
    modelFilename?: string | null
    modelFileType?: string | null
    modelFileSize?: number | null
    supportsCount?: number
    clampsCount?: number
    hasBaseplate?: boolean
    processingTime?: number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProjectStatus
    isPublic?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastOpenedAt?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ModelImportCreateManyUserInput = {
    id?: string
    projectId?: string | null
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ExportCreateManyUserInput = {
    id?: string
    projectId: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    subscriptionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ErrorLogCreateManyUserInput = {
    id?: string
    projectId?: string | null
    modelImportId?: string | null
    exportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CloudBackupCreateManyUserInput = {
    id?: string
    projectId: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
  }

  export type SharedProjectCreateManySharedByUserInput = {
    id?: string
    projectId: string
    sharedWith?: string | null
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type SharedProjectCreateManySharedWithUserInput = {
    id?: string
    projectId: string
    sharedBy: string
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    status: string
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelImports?: ModelImportUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUpdateManyWithoutProjectNestedInput
    exports?: ExportUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modelImports?: ModelImportUncheckedUpdateManyWithoutProjectNestedInput
    designVersions?: DesignVersionUncheckedUpdateManyWithoutProjectNestedInput
    exports?: ExportUncheckedUpdateManyWithoutProjectNestedInput
    cloudBackups?: CloudBackupUncheckedUpdateManyWithoutProjectNestedInput
    sharedProjects?: SharedProjectUncheckedUpdateManyWithoutProjectNestedInput
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    modelFilename?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileType?: NullableStringFieldUpdateOperationsInput | string | null
    modelFileSize?: NullableIntFieldUpdateOperationsInput | number | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    hasBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    toolingApplied?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelImportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneWithoutModelImportsNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutModelImportNestedInput
  }

  export type ModelImportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutModelImportNestedInput
  }

  export type ModelImportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutExportsNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutExportNestedInput
  }

  export type ExportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutExportNestedInput
  }

  export type ExportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ErrorLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutErrorLogsNestedInput
    modelImport?: ModelImportUpdateOneWithoutErrorLogsNestedInput
    export?: ExportUpdateOneWithoutErrorLogsNestedInput
  }

  export type ErrorLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelImportId?: NullableStringFieldUpdateOperationsInput | string | null
    exportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelImportId?: NullableStringFieldUpdateOperationsInput | string | null
    exportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CloudBackupUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutCloudBackupsNestedInput
  }

  export type CloudBackupUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CloudBackupUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedProjectUpdateWithoutSharedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutSharedProjectsNestedInput
    sharedWithUser?: UserUpdateOneWithoutReceivedSharesNestedInput
  }

  export type SharedProjectUncheckedUpdateWithoutSharedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedProjectUncheckedUpdateManyWithoutSharedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedProjectUpdateWithoutSharedWithUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutSharedProjectsNestedInput
    sharedByUser?: UserUpdateOneRequiredWithoutSharedProjectsNestedInput
  }

  export type SharedProjectUncheckedUpdateWithoutSharedWithUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedProjectUncheckedUpdateManyWithoutSharedWithUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManySubscriptionInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    gatewayProvider: string
    gatewayOrderId?: string | null
    gatewayPaymentId?: string | null
    gatewaySignature?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceUrl?: string | null
    failureReason?: string | null
    failureCode?: string | null
    refundedAmount?: number | null
    refundedAt?: Date | string | null
    refundReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    gatewayProvider?: StringFieldUpdateOperationsInput | string
    gatewayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewaySignature?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    failureCode?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ErrorLogCreateManyModelImportInput = {
    id?: string
    userId?: string | null
    projectId?: string | null
    exportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ErrorLogUpdateWithoutModelImportInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutErrorLogsNestedInput
    project?: ProjectUpdateOneWithoutErrorLogsNestedInput
    export?: ExportUpdateOneWithoutErrorLogsNestedInput
  }

  export type ErrorLogUncheckedUpdateWithoutModelImportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    exportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorLogUncheckedUpdateManyWithoutModelImportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    exportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelImportCreateManyProjectInput = {
    id?: string
    userId: string
    filename: string
    originalFilename: string
    fileSize: number
    fileHash?: string | null
    modelData?: Buffer | null
    thumbnailData?: Buffer | null
    status?: $Enums.ImportStatus
    progress?: number
    processingStartedAt?: Date | string | null
    processingCompletedAt?: Date | string | null
    processingDuration?: number | null
    vertexCount?: number | null
    faceCount?: number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: number | null
    isValid?: boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    errorCode?: string | null
    countsTowardLimit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DesignVersionCreateManyProjectInput = {
    id?: string
    versionNumber: number
    name?: string | null
    description?: string | null
    thumbnailUrl?: string | null
    changesSummary?: string | null
    supportsCount?: number
    clampsCount?: number
    isAutoSave?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type ExportCreateManyProjectInput = {
    id?: string
    userId: string
    format: $Enums.ExportFormat
    filename: string
    fileSize?: number | null
    exportData?: Buffer | null
    fileUrl?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: boolean
    includeClamps?: boolean
    includeBaseplate?: boolean
    processingTime?: number | null
    status?: $Enums.ExportStatus
    errorMessage?: string | null
    numberOfExportsDone?: number
    downloadCount?: number
    lastDownloadedAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type CloudBackupCreateManyProjectInput = {
    id?: string
    userId: string
    backupName?: string | null
    compressedData?: Buffer | null
    fileSize: number
    checksum: string
    compressionType?: string
    originalSize?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    accessedAt?: Date | string | null
  }

  export type SharedProjectCreateManyProjectInput = {
    id?: string
    sharedBy: string
    sharedWith?: string | null
    permission?: string
    shareType: string
    shareToken?: string | null
    accepted?: boolean
    revoked?: boolean
    createdAt?: Date | string
    acceptedAt?: Date | string | null
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type ErrorLogCreateManyProjectInput = {
    id?: string
    userId?: string | null
    modelImportId?: string | null
    exportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ModelImportUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutModelImportsNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutModelImportNestedInput
  }

  export type ModelImportUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutModelImportNestedInput
  }

  export type ModelImportUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    modelData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    thumbnailData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    progress?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingDuration?: NullableIntFieldUpdateOperationsInput | number | null
    vertexCount?: NullableIntFieldUpdateOperationsInput | number | null
    faceCount?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: NullableJsonNullValueInput | InputJsonValue
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    countsTowardLimit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DesignVersionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    changesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    isAutoSave?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DesignVersionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    changesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    isAutoSave?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DesignVersionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    changesSummary?: NullableStringFieldUpdateOperationsInput | string | null
    supportsCount?: IntFieldUpdateOperationsInput | number
    clampsCount?: IntFieldUpdateOperationsInput | number
    isAutoSave?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutExportsNestedInput
    errorLogs?: ErrorLogUpdateManyWithoutExportNestedInput
  }

  export type ExportUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorLogs?: ErrorLogUncheckedUpdateManyWithoutExportNestedInput
  }

  export type ExportUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    exportData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    includeSupports?: BoolFieldUpdateOperationsInput | boolean
    includeClamps?: BoolFieldUpdateOperationsInput | boolean
    includeBaseplate?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumExportStatusFieldUpdateOperationsInput | $Enums.ExportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfExportsDone?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    lastDownloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CloudBackupUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCloudBackupsNestedInput
  }

  export type CloudBackupUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CloudBackupUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    backupName?: NullableStringFieldUpdateOperationsInput | string | null
    compressedData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    fileSize?: IntFieldUpdateOperationsInput | number
    checksum?: StringFieldUpdateOperationsInput | string
    compressionType?: StringFieldUpdateOperationsInput | string
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedProjectUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sharedByUser?: UserUpdateOneRequiredWithoutSharedProjectsNestedInput
    sharedWithUser?: UserUpdateOneWithoutReceivedSharesNestedInput
  }

  export type SharedProjectUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedProjectUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    accepted?: BoolFieldUpdateOperationsInput | boolean
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ErrorLogUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutErrorLogsNestedInput
    modelImport?: ModelImportUpdateOneWithoutErrorLogsNestedInput
    export?: ExportUpdateOneWithoutErrorLogsNestedInput
  }

  export type ErrorLogUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    modelImportId?: NullableStringFieldUpdateOperationsInput | string | null
    exportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorLogUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    modelImportId?: NullableStringFieldUpdateOperationsInput | string | null
    exportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorLogCreateManyExportInput = {
    id?: string
    userId?: string | null
    projectId?: string | null
    modelImportId?: string | null
    category: $Enums.ErrorCategory
    severity?: $Enums.ErrorSeverity
    errorCode: string
    errorMessage: string
    errorStack?: string | null
    operation: string
    step?: string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    method?: string | null
    statusCode?: number | null
    userAction?: string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolution?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ErrorLogUpdateWithoutExportInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutErrorLogsNestedInput
    project?: ProjectUpdateOneWithoutErrorLogsNestedInput
    modelImport?: ModelImportUpdateOneWithoutErrorLogsNestedInput
  }

  export type ErrorLogUncheckedUpdateWithoutExportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelImportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorLogUncheckedUpdateManyWithoutExportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    modelImportId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumErrorCategoryFieldUpdateOperationsInput | $Enums.ErrorCategory
    severity?: EnumErrorSeverityFieldUpdateOperationsInput | $Enums.ErrorSeverity
    errorCode?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    step?: NullableStringFieldUpdateOperationsInput | string | null
    browserInfo?: NullableJsonNullValueInput | InputJsonValue
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelImportCountOutputTypeDefaultArgs instead
     */
    export type ModelImportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelImportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExportCountOutputTypeDefaultArgs instead
     */
    export type ExportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LicenseDefaultArgs instead
     */
    export type LicenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LicenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelImportDefaultArgs instead
     */
    export type ModelImportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelImportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DesignVersionDefaultArgs instead
     */
    export type DesignVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DesignVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExportDefaultArgs instead
     */
    export type ExportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ErrorLogDefaultArgs instead
     */
    export type ErrorLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ErrorLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SharedProjectDefaultArgs instead
     */
    export type SharedProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SharedProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CloudBackupDefaultArgs instead
     */
    export type CloudBackupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CloudBackupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NumExportsDefaultArgs instead
     */
    export type NumExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NumExportsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}